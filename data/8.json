{
    "800": {
        "file_id": 99,
        "content": "# deprecated. use serial for both controllers\nfrom __future__ import print_function\nimport hid\nimport time\n# enumerate USB devices\n# manufacturer_string -> \"winkeyless.kr\"\n# shall be what we expect.\nfor d in hid.enumerate():\n    keys = list(d.keys())\n    keys.sort()\n    for key in keys:\n        print(\"%s : %s\" % (key, d[key]))\n    print()\ndevices = {\n    0: {\n        \"vendor_id\": 8352,\n        \"product_id\": 16941,\n    },  # 0, could be mouse.\n    1: {\n        \"vendor_id\": 8352,\n        \"product_id\": 16941,\n    },  # 1\n}\n# the same!\n# try opening a device, then perform write and read\n# may you write keyboard and mouse commands to different devices, by using `h.open(d)` (may still be the same as below)\nh = hid.device()\ntry:\n    print(\"Opening the device\")\n    h.open(devices[0][\"vendor_id\"], devices[0][\"product_id\"])\n    # h.open(0x534C, 0x0001)  # TREZOR VendorID/ProductID\n    # print(dir(h))\n    # 'get_feature_report', 'get_indexed_string', 'get_input_report', 'get_manufacturer_string', 'get_product_string', 'get_seri",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_hidraw.py:1-41"
    },
    "801": {
        "file_id": 99,
        "content": "Enumerating USB devices with specified manufacturer string, comparing expected devices, and attempting to open a device for further operations.",
        "type": "comment"
    },
    "802": {
        "file_id": 99,
        "content": "al_number_string',\n    # print(h.open_path)\n    print(\"Manufacturer: %s\" % h.get_manufacturer_string())\n    print(\"Product: %s\" % h.get_product_string())\n    print(\"Serial No: %s\" % h.get_serial_number_string())\n    # enable non-blocking mode\n    h.set_nonblocking(1)\n    # write some data to the device\n    # what data is this anyway?\n    print(\"Write the data\")\n    h.write([0, 63, 35, 35] + [0] * 61)\n    # wait\n    time.sleep(0.05)\n    # read back the answer\n    print(\"Read the data\")\n    while True:\n        d = h.read(64)\n        if d:\n            print(d)\n        else:\n            break\n    print(\"Closing the device\")\n    h.close()\nexcept IOError as ex:\n    print(ex)\n    print(\"hid error:\")\n    print(h.error())\n    print(\"\")\n    print(\"You probably don't have the hard-coded device.\")\n    print(\"Update the h.open() line in this script with the one\")\n    print(\"from the enumeration list output above and try again.\")\nprint(\"Done\")",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_hidraw.py:41-80"
    },
    "803": {
        "file_id": 99,
        "content": "This code tests the interaction with a USB device using HID API. It prints manufacturer, product, and serial number. Writes data to the device, waits for response, reads back the data, and closes the device connection. Code may require adjustment for specific devices as it uses hard-coded device path.",
        "type": "comment"
    },
    "804": {
        "file_id": 100,
        "content": "/hardware_capture_hid_power_control/test_video_capture.py",
        "type": "filepath"
    },
    "805": {
        "file_id": 100,
        "content": "The code snippet is attempting to configure a video capture device using OpenCV library, set up video properties, read frames from the camera, save them as images and display using ffplay. However, it's facing issues with not being able to faithfully configure the device.",
        "type": "summary"
    },
    "806": {
        "file_id": 100,
        "content": "# lsusb -v\n# Actions Microelectronics Co. Display capture-UVC05\n# ls /dev/video*\n# ls /sys/class/video4linux\n# v4l2-ctl --list-devices\n# get resolution/modes\n# v4l2-ctl --list-formats-ext\n# video2&3 are capture card.\nimport cv2\n# can't you reset?\ncamera_id = 2  # use the smallest camera id of particular device (the only working one)\n# without setting!\n# CV_CAP_PROP_FRAME_WIDTH: '640.0'\n# CV_CAP_PROP_FRAME_HEIGHT : '480.0'\n# CV_CAP_PROP_FRAME_FPS : '30.0'\n# CV_CAP_PROP_FRAME_FOURCC : '1196444237.0'\n# CV_CAP_PROP_FRAME_FORMAT : '16.0'\n# camera_id = 0\n# cam 1,3 not working.\ncap = cv2.VideoCapture(camera_id)\n# oops. not working for cam2, cause we are using it in obs? (yes! and cv2 will reset this thing to 640x480 just after opening the camera.)\n# resolution not right...\n# cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1080)\n# cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1920)\n# cv2 is not faithfully changing settings of the capture device.\n# cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)\n# cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1024)\n# cannot strent",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_video_capture.py:1-38"
    },
    "807": {
        "file_id": 100,
        "content": "Code snippet is attempting to configure a video capture device using OpenCV (cv2) library. It's trying different resolution settings but encountering issues with the device not being faithfully configured.",
        "type": "comment"
    },
    "808": {
        "file_id": 100,
        "content": "ch!\n# CV_CAP_PROP_FRAME_WIDTH: '1280.0'\n# CV_CAP_PROP_FRAME_HEIGHT : '1024.0'\n# showing values of the properties\nprint(\"CV_CAP_PROP_FRAME_WIDTH: '{}'\".format(cap.get(cv2.CAP_PROP_FRAME_WIDTH)))\nprint(\"CV_CAP_PROP_FRAME_HEIGHT : '{}'\".format(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))\nprint(\"CV_CAP_PROP_FRAME_FPS : '{}'\".format(cap.get(cv2.CAP_PROP_FPS)))\nprint(\"CV_CAP_PROP_FRAME_FOURCC : '{}'\".format(cap.get(cv2.CAP_PROP_FOURCC)))\nprint(\"CV_CAP_PROP_FRAME_FORMAT : '{}'\".format(cap.get(cv2.CAP_PROP_FORMAT)))\n# cv2.CAP_PROP_SETTINGS\nret, frame = cap.read()\n# Display the resulting frame\ncv2.imwrite(output_path := \"output.png\", frame)  # from \"no_signal\" to something!\nimport os\nos.system(f\"ffplay {output_path}\")\n# cv2.imshow('frame', frame)\n# cv2.waitKey(0)",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_video_capture.py:38-58"
    },
    "809": {
        "file_id": 100,
        "content": "Code snippet is setting up video capture properties, reading a frame from the camera and then saving it as an image. It also shows the values of various properties like width, height, FPS (frames per second), fourcc (a code that defines the pixel format) and format of the video stream. Finally, it displays the captured frame using ffplay (a media player).",
        "type": "comment"
    },
    "810": {
        "file_id": 101,
        "content": "/hid_utils.py",
        "type": "filepath"
    },
    "811": {
        "file_id": 101,
        "content": "This code defines classes and functions for input operations, specifically handling mouse scroll events and translating key literals to XK_KEYSYMs using abstract methods. It checks the starting key and sorts the XK_KEYSYMs based on distance before storing the translation in a dictionary and writing it to a file.",
        "type": "summary"
    },
    "812": {
        "file_id": 101,
        "content": "# TODO: display grabbing abstract class\n# TODO: for relative control apis, use them as fallback for absolute apis (somehow calibrated, with feedback) when possible\n# TODO: check out ROS package index: https://index.ros.org/packages/\nfrom enum import Enum, auto, Flag\nfrom beartype.vale import Is\nfrom typing_extensions import Annotated, TypeAlias\nfrom conscious_struct import HIDActionTypes, HIDActionBase\nfrom log_utils import logger_print\nfrom typing import Dict, Tuple, Union\nfrom abc import ABC, abstractmethod\n# TODO: use abstract implementation pattern (template)\nclass HIDInterface(ABC):\n    def key_press(self, key_literal: HIDActionTypes.keys):\n        \"\"\"\n        Press one of key literals.\n        \"\"\"\n        return self._key_press(key_literal=key_literal)\n    @abstractmethod\n    def _key_press(self, key_literal: HIDActionTypes.keys):\n        ...\n    def key_release(self, key_literal: HIDActionTypes.keys):\n        \"\"\"\n        Release one of key literals.\n        \"\"\"\n        return self._key_release(key_lite",
        "type": "code",
        "location": "/hid_utils.py:1-30"
    },
    "813": {
        "file_id": 101,
        "content": "Code is importing required modules and defining an abstract class called HIDInterface with methods for key press and release.",
        "type": "comment"
    },
    "814": {
        "file_id": 101,
        "content": "ral=key_literal)\n    @abstractmethod\n    def _key_release(self, key_literal: HIDActionTypes.keys):\n        ...\n    def mouse_move(self, x: Union[int, float], y: Union[int, float]):\n        \"\"\"\n        Move mouse to absolute position (x, y).\n        \"\"\"\n        return self._mouse_move(x=x, y=y)\n    @abstractmethod\n    def _mouse_move(self, x: Union[int, float], y: Union[int, float]):\n        ...\n    def mouse_click(\n        self,\n        x: Union[int, float],\n        y: Union[int, float],\n        button_literal: HIDActionTypes.mouse_buttons,\n        pressed: bool,\n    ):\n        \"\"\"\n        Press or release one of mouse button literals at absolute position (x, y).\n        \"\"\"\n        return self._mouse_click(\n            x=x, y=y, button_literal=button_literal, pressed=pressed\n        )\n    @abstractmethod\n    def _mouse_click(\n        self,\n        x: Union[int, float],\n        y: Union[int, float],\n        button_literal: HIDActionTypes.mouse_buttons,\n        pressed: bool,\n    ):\n        ...\n    def mouse_scroll(\n    ",
        "type": "code",
        "location": "/hid_utils.py:30-71"
    },
    "815": {
        "file_id": 101,
        "content": "This code defines abstract methods for mouse movement, click actions, and key releases in a HID (Human Interface Device) interface. The class must implement these methods to interact with the device. The methods take parameters like position (x, y), button literal, and whether to press or release.",
        "type": "comment"
    },
    "816": {
        "file_id": 101,
        "content": "    self,\n        x: Union[int, float],\n        y: Union[int, float],\n        dx: Union[int, float],\n        dy: Union[int, float],\n    ):\n        \"\"\"\n        Scroll mouse (dx, dy) at absolute position (x, y).\n        \"\"\"\n        return self._mouse_scroll(x=x, y=y, dx=dx, dy=dy)\n    @abstractmethod\n    def _mouse_scroll(\n        self,\n        x: Union[int, float],\n        y: Union[int, float],\n        dx: Union[int, float],\n        dy: Union[int, float],\n    ):\n        ...\ndef length_limit(l):\n    return Is[lambda b: len(b) == l]\n# import Xlib\n# python-xlib\nimport os\nsourcefile_dirname = os.path.dirname(os.path.abspath(__file__))\nkey_literal_to_xk_keysym_translation_table_path = os.path.join(\n    sourcefile_dirname, \"KL2XKS.json\"\n)\nfrom functools import lru_cache\nimport json\n@lru_cache\ndef getKL2XKS() -> Dict[str, str]:\n    with open(key_literal_to_xk_keysym_translation_table_path, \"r\") as f:\n        KL2XKS = json.loads(f.read())\n    return KL2XKS\nfrom beartype import beartype\n@beartype\ndef strip_key_literal(key_literal: ",
        "type": "code",
        "location": "/hid_utils.py:71-121"
    },
    "817": {
        "file_id": 101,
        "content": "The code appears to be part of a larger module and seems to define functions for handling mouse scroll events. It first defines an abstract method for the `_mouse_scroll` function, which takes in x and y coordinates along with dx and dy (amount of scroll) as parameters. The `length_limit` function is defined as a helper function that checks if a byte-like object's length equals to specified length. Additionally, there are imports from Xlib and other modules, but the exact functionality of these is not clear without more context.",
        "type": "comment"
    },
    "818": {
        "file_id": 101,
        "content": "HIDActionTypes.keys) -> Tuple[bool, bool, str]:\n    # defer strip/lstrip.\n    # it is not a bug. do not report.\n    is_special, is_media = False, False\n    keychar = ...\n    if key_literal.startswith(prefix := \"Key.\"):\n        is_special = True\n        keychar = key_literal.replace(prefix, \"\")\n        if keychar.startswith(prefix := \"media_\"):\n            is_media = True\n            keychar = keychar.replace(prefix, \"\")\n    if len(key_literal) == 3:\n        if not (key_literal[0] == key_literal[2] != (keychar := key_literal[1])):\n            raise Exception(f\"Abnormal enclosed keychar: {repr(key_literal)}\")\n    if keychar == Ellipsis:\n        raise Exception(f\"Unable to strip key literal: {repr(key_literal)}\")\n    else:\n        return is_special, is_media, keychar\n@beartype\ndef key_literal_to_xk_keysym(key_literal: HIDActionTypes.keys) -> Union[None, str]:\n    # is_special, is_media, stripped_key_literal = strip_key_literal(key_literal)\n    KL2XKS = getKL2XKS()\n    xk_keysym = KL2XKS.get(key_literal, None)\n ",
        "type": "code",
        "location": "/hid_utils.py:121-146"
    },
    "819": {
        "file_id": 101,
        "content": "Function \"strip_key_literal\" checks if the given key literal is a special or media key and returns its stripped name. If the key literal has an abnormal enclosed keychar, it raises an exception. If the keychar is Ellipsis, it raises an exception as well. Otherwise, it returns a tuple of whether it's a special or media key, the stripped key character if it is a special key with a \"media_\" prefix, and the original key literal without prefixes if not special.",
        "type": "comment"
    },
    "820": {
        "file_id": 101,
        "content": "   if xk_keysym is None:\n        print(f\"skipping translating key literal {repr(key_literal)} to xk_keysym.\")\n    return xk_keysym\n    # Xlib.XK.string_to_keysym(stripped_key_literal)\n    # generate this translation table statically, then we will review.\ndef byte_with_length_limit(l):\n    return Annotated[bytes, length_limit(l)]\none_byte: TypeAlias = byte_with_length_limit(1)\ntwo_bytes: TypeAlias = byte_with_length_limit(2)\nfour_bytes: TypeAlias = byte_with_length_limit(4)\nsix_bytes: TypeAlias = byte_with_length_limit(6)\neight_bytes: TypeAlias = byte_with_length_limit(8)\nnon_neg_int: TypeAlias = Annotated[int, Is[lambda i: i >= 0]]\npos_int: TypeAlias = Annotated[int, Is[lambda i: i > 0]]\nmovement: TypeAlias = Annotated[\n    int, Is[lambda i: i >= -126 and i <= 126]\n]  # this is hardware limit. software might not be limited. (shall we adapt to software limit instead of hardware)\nclass ControlCode(Flag):\n    # @staticmethod\n    # def _generate_next_value_(name, start, count, last_values):\n    #     return 2",
        "type": "code",
        "location": "/hid_utils.py:146-174"
    },
    "821": {
        "file_id": 101,
        "content": "This code defines several type aliases for different byte lengths and some integer ranges. It also has a class called ControlCode which is defined as a Flag. The code seems to be related to handling key literals, XK keysyms, and potentially input validation based on these types.",
        "type": "comment"
    },
    "822": {
        "file_id": 101,
        "content": " ** (count)\n    NULL = 0\n    LEFT_CONTROL = auto()\n    LEFT_SHIFT = auto()\n    LEFT_ALT = auto()\n    LEFT_GUI = auto()\n    RIGHT_CONTROL = auto()\n    RIGHT_SHIFT = auto()\n    RIGHT_ALT = auto()\n    RIGHT_GUI = auto()\nclass MouseButton(Flag):\n    # class MouseButton(Enum):\n    # @staticmethod\n    # def _generate_next_value_(name, start, count, last_values):\n    #     return 2 ** (count)\n    NULL = 0\n    LEFT = auto()\n    RIGHT = auto()\n    MIDDLE = auto()\nclass MultimediaKey(Flag):\n    # class MultimediaKey(Enum):\n    # @staticmethod\n    # def _generate_next_value_(name, start, count, last_values):\n    #     return 2 ** (count)\n    Null = 0\n    # row 1\n    VolumeUp = auto()\n    VolumeDown = auto()\n    Mute = auto()\n    PlayPause = auto()\n    NextTrack = auto()\n    PreviousTrack = auto()\n    CDStop = auto()\n    Eject = auto()\n    # row 2\n    EMail = auto()\n    WWWSearch = auto()\n    WWWFavourites = auto()\n    WWWHome = auto()\n    WWWBack = auto()\n    WWWForward = auto()\n    WWWStop = auto()\n    Refresh = auto()\n    # row 3\n    Med",
        "type": "code",
        "location": "/hid_utils.py:174-229"
    },
    "823": {
        "file_id": 101,
        "content": "This code defines classes for different types of buttons (MouseButton, MultimediaKey) using the Flag and Enum classes. It represents each button as a power of 2, with NULL or Null being 0. The code also includes definitions for various multimedia keys organized into three rows.",
        "type": "comment"
    },
    "824": {
        "file_id": 101,
        "content": "ia = auto()\n    Explorer = auto()\n    Calculator = auto()\n    ScreenSave = auto()\n    MyComputer = auto()\n    Minimize = auto()\n    Record = auto()\n    Rewind = auto()\nassert len(MultimediaKey.__members__) == 3 * 8 + 1  # include \"Null\"\nclass ACPIKey(Flag):\n    Null = 0  # for clearing all \"ACPI\" keys.\n    Power = auto()\n    Sleep = auto()\n    Wakeup = auto()\nif __name__ == \"__main__\":\n    # generate that table.\n    import Levenshtein as L\n    import keysymdef\n    unicode_str_to_xk_keysym = {}\n    xk_keysyms = []\n    xk_keysyms_lut = {}\n    for xk_keysym, _, unicode_int in keysymdef.keysymdef:\n        unicode_str = None\n        as_unicode_char = False\n        if unicode_int:\n            try:\n                unicode_str = chr(unicode_int)\n                unicode_str_to_xk_keysym[unicode_str] = xk_keysym\n                as_unicode_char = True\n            except:\n                pass\n        xk_keysym_lower = xk_keysym.lower()\n        xk_keysyms_lut[xk_keysym_lower] = xk_keysym\n        # if not as_unicode_char:\n        xk",
        "type": "code",
        "location": "/hid_utils.py:229-273"
    },
    "825": {
        "file_id": 101,
        "content": "The code is defining classes and variables for handling various input operations. It creates classes like MultimediaKey, ACPIKey, Explorer, Calculator, etc., which are used to handle specific types of key inputs. It also generates a table mapping Unicode strings to xk_keysyms. The purpose seems to be related to handling different keys and their associated functions in an input-processing system.",
        "type": "comment"
    },
    "826": {
        "file_id": 101,
        "content": "_keysyms.append(xk_keysym_lower)  # for space.\n    KL2XKS = {}\n    # import rich\n    # rich.print(xk_keysyms_lut)\n    # breakpoint()\n    keywords_translation_table = dict(\n        cmd=\"super\",\n        ctrl=\"control\",\n        _left=\"_l\",\n        _right=\"_r\",\n        esc=\"escape\",\n        enter=\"return\",\n        # we do not use xf86 (multimedia) keys. or shall we? how to handle the play/pause button then?\n    )\n    def translate(string: str, translation_table: Dict[str, str]):\n        for k, v in translation_table.items():\n            string = string.replace(k, v)\n        return string\n    import re\n    for key_literal in HIDActionBase.keys:  # nearly instant. no need for progressbar.\n        is_special, is_media, stripped_key_literal = strip_key_literal(key_literal)\n        if is_media:\n            continue\n        # media prefix is removed.\n        # if \"eth\" in stripped_key_literal.lower():\n        #     breakpoint()\n        if stripped_key_literal in unicode_str_to_xk_keysym.keys():\n            keysym = unicod",
        "type": "code",
        "location": "/hid_utils.py:273-305"
    },
    "827": {
        "file_id": 101,
        "content": "The code defines a translation table for converting keyboard literals to their respective meanings. It then defines a function called `translate` that replaces the keywords in a string with their corresponding translations using a dictionary. The code also imports the `re` module and loops over each key literal, stripping any special or media prefixes before checking if it exists in the unicode-to-xk_keysym mapping. If it does, it breaks execution.",
        "type": "comment"
    },
    "828": {
        "file_id": 101,
        "content": "e_str_to_xk_keysym[stripped_key_literal]\n        else:\n            # import humps\n            stripped_key_literal = translate(\n                re.sub(\n                    r\"^(alt|control|cmd|shift)$\", r\"\\1_l\", stripped_key_literal.lower()\n                ),\n                keywords_translation_table,\n            )\n            # if \"return\" in stripped_key_literal:\n            #     breakpoint()\n            xk_keysyms.sort(\n                key=lambda keysym: L.distance(keysym.lower(), stripped_key_literal)\n            )\n            keysym = xk_keysyms.pop(0)\n        KL2XKS.update(val := {key_literal: xk_keysyms_lut[keysym]})\n        print(val, key_literal, stripped_key_literal)\n    with open(key_literal_to_xk_keysym_translation_table_path, \"w+\") as f:\n        f.write(json.dumps(KL2XKS, ensure_ascii=False, indent=4))\n    logger_print(\"write to:\", key_literal_to_xk_keysym_translation_table_path)",
        "type": "code",
        "location": "/hid_utils.py:305-324"
    },
    "829": {
        "file_id": 101,
        "content": "This code is translating key literals to XK_KEYSYMs, storing the translation in a dictionary and writing it to a file. It first checks if the key literal starts with \"alt\", \"control\", \"cmd\", or \"shift\" and adds an underscore before the letter if it does. Then it sorts the XK_KEYSYMs based on the distance between their lowercase strings and the stripped_key_literal, selects the closest one and updates a dictionary of key literals to their respective XK_KEYSYMs. Finally, it writes this dictionary to a file.",
        "type": "comment"
    },
    "830": {
        "file_id": 102,
        "content": "/hotkey_listener.py",
        "type": "filepath"
    },
    "831": {
        "file_id": 102,
        "content": "The code imports the keyboard module from pynput library, defines functions for handling key presses and releases, includes a dictionary mapping keyboard keys to ASCII codes or special characters, but the hotkey listener is not currently running.",
        "type": "summary"
    },
    "832": {
        "file_id": 102,
        "content": "from pynput import keyboard\ndef on_press(key):\n    if type(key) != str:\n        key = str(key)\n    print((\"key_press\", key))\ndef on_release(key):\n    if type(key) != str:\n        key = str(key)\n    print((\"key_release\", key))\n# keyboard_listener = keyboard.Listener(on_press=on_press, on_release=on_release)\n# keyboard_listener.run()\nkeycode_ctrl = {\n    \"a\": \"\\x01\",\n    \"b\": \"\\x02\",\n    \"c\": \"\\x03\",\n    \"d\": \"\\x04\",\n    \"e\": \"\\x05\",\n    \"f\": \"\\x06\",\n    \"g\": \"\\x07\",\n    \"h\": \"\\x08\",\n    \"i\": \"\\x09\",\n    \"j\": \"\\x0a\",\n    \"k\": \"\\x0b\",\n    \"l\": \"\\x0c\",\n    \"m\": \"\\x0d\",\n    \"n\": \"\\x0e\",\n    \"o\": \"\\x0f\",\n    \"p\": \"\\x10\",\n    \"q\": \"\\x11\",\n    \"r\": \"\\x12\",\n    \"s\": \"\\x13\",\n    \"t\": \"\\x14\",\n    \"u\": \"\\x15\",\n    \"v\": \"\\x16\",\n    \"w\": \"\\x17\",\n    \"x\": \"\\x18\",\n    \"y\": \"\\x19\",\n    \"z\": \"\\x1a\",\n    \"[\": \"\\x1b\",\n    \"[\": \"<219>\",\n    \"]\": \"\\x1d\",\n    \"]\": \"<221>\",\n    \"-\": \"\\x1f\",\n    \"-\": \"<189>\",\n    \"=\": \"<187>\",\n    \"`\": \"<192>\",\n    \"0\": \"<48>\",\n    \"1\": \"<49>\",\n    \"2\": \"<50>\",\n    \"3\": \"<51>\",\n    \"4\": \"<52>\",\n    \"5\": \"<53>\",\n    \"6\": \"<54>\",\n",
        "type": "code",
        "location": "/hotkey_listener.py:1-61"
    },
    "833": {
        "file_id": 102,
        "content": "This code imports the keyboard module from pynput library and defines two functions for handling key presses and releases. The hotkey listener is not running currently. It also contains a dictionary mapping keyboard keys to their corresponding ASCII codes or special characters.",
        "type": "comment"
    },
    "834": {
        "file_id": 102,
        "content": "    \"7\": \"<55>\",\n    \"8\": \"<56>\",\n    \"9\": \"<57>\",\n    \"\\\\\": \"\\x1c\",\n    \"\\\\\": \"<220>\",\n    \";\": \"<186>\",\n    \"'\": \"<222>\",\n    \"<\": \"<188>\",\n    \">\": \"<190>\",\n    \"?\": \"<191>\",\n}\nprint({v: k for k, v in keycode_ctrl.items()})",
        "type": "code",
        "location": "/hotkey_listener.py:61-72"
    },
    "835": {
        "file_id": 102,
        "content": "Mapping keycode to control dictionary.",
        "type": "comment"
    },
    "836": {
        "file_id": 103,
        "content": "/hotkey_tester.py",
        "type": "filepath"
    },
    "837": {
        "file_id": 103,
        "content": "Code is disabling all hotkeys by pressing the Control key.",
        "type": "summary"
    },
    "838": {
        "file_id": 103,
        "content": "import pyautogui\nimport pynput\n# you simply deprecate all hotkeys.\nkeyboard_controller = pynput.keyboard.Controller()\nkeyboard_controller.press(pynput.keyboard.Key.ctrl)\npyautogui.typewrite('1')\nkeyboard_controller.release(pynput.keyboard.Key.ctrl)",
        "type": "code",
        "location": "/hotkey_tester.py:1-10"
    },
    "839": {
        "file_id": 103,
        "content": "Code is disabling all hotkeys by pressing the Control key.",
        "type": "comment"
    },
    "840": {
        "file_id": 104,
        "content": "/install_nvidia_container_toolkit.sh",
        "type": "filepath"
    },
    "841": {
        "file_id": 104,
        "content": "This code determines the Debian version for Kali 2022.2, checks for the kernel version (5.16), and sets the distribution to \"debian11\". It then installs the NVIDIA container toolkit by adding a GPG key, updating a source list, and installing the necessary packages from the specified repository.",
        "type": "summary"
    },
    "842": {
        "file_id": 104,
        "content": "# figure out what version of debian is for kali 2022.2\n# `uname -a` to get debian kernel version (5.16) -> bullseye (debian 11)\n# supported versions:\n# ref: https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html\n# distribution=$(. /etc/os-release;echo $ID$VERSION_ID) \\\ndistribution=\"debian11\" \\\n      && curl -fsSL -k https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \\\n      && curl -s -L -k https://nvidia.github.io/libnvidia-container/experimental/$distribution/libnvidia-container.list | \\\n         sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \\\n         sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list",
        "type": "code",
        "location": "/install_nvidia_container_toolkit.sh:1-12"
    },
    "843": {
        "file_id": 104,
        "content": "This code determines the Debian version for Kali 2022.2, checks for the kernel version (5.16), and sets the distribution to \"debian11\". It then installs the NVIDIA container toolkit by adding a GPG key, updating a source list, and installing the necessary packages from the specified repository.",
        "type": "comment"
    },
    "844": {
        "file_id": 105,
        "content": "/jinja_utils.py",
        "type": "filepath"
    },
    "845": {
        "file_id": 105,
        "content": "This code imports modules, defines functions to manipulate Python code, performs type checks using pyright linter, handles file updates and outputs formatted code, uses Jinja2 templates for execution, and converts variables into Python.",
        "type": "summary"
    },
    "846": {
        "file_id": 105,
        "content": "from log_utils import logger_print\nimport subprocess\nfrom tempfile import TemporaryDirectory\nimport black\n# from humps import kebabize\nimport jinja2\nimport shutil\nimport os\nimport pyright_utils  # for checking if really installed.\nimport re\n# live share's triple quote issue isn't fixed.\nimport humps  # default to snake case!\nimport ast\ndef remove_typehint(paramDef: str) -> str:\n    tree_def = ast.parse(\"def func({}): ...\".format(paramDef)).body[0]\n    args = []\n    for elem in ast.walk(tree_def):\n        if isinstance(elem, ast.arg):\n            argName = elem.arg  # str\n            args.append(argName)\n    return \",\".join([f\"{argName}={argName}\" for argName in args])\ndef camelize_with_space(string):\n    return humps.camelize(string.replace(\" \", \"-\"))\n# ref: https://www.geeksforgeeks.org/python-program-to-convert-camel-case-string-to-snake-case/\ndef c2s(_str):\n    \"\"\"\n    Camel case to snake case.\n    \"\"\"\n    # return humps.kebabize(_str).replace(\"-\", \"_\")\n    # res = [_str[0].lower()]\n    # for c in _str[1:]:\n    #",
        "type": "code",
        "location": "/jinja_utils.py:1-43"
    },
    "847": {
        "file_id": 105,
        "content": "This code imports various modules and defines functions to manipulate Python code, such as removing type hints and converting variable names between different cases. It also includes a function to convert camel case to snake case.",
        "type": "comment"
    },
    "848": {
        "file_id": 105,
        "content": "     if c in (\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"):\n    #         res.append(\"_\")\n    #         res.append(c.lower())\n    #     else:\n    #         res.append(c)\n    # return \"\".join(res)\n    return humps.decamelize(_str)\ndef s2c(_str, lower: bool):\n    \"\"\"\n    Snake case to camel case.\n    \"\"\"\n    # assert not _str.startswith(\"_\")\n    # lst = _str.split(\"_\")\n    # first_letter = lst[0][0]\n    # lst[0] = (first_letter.lower() if lower else first_letter.upper()) + lst[0][1:]\n    # for i in range(1, len(lst)):\n    #     lst[i] = lst[i].title()\n    # return \"\".join(lst)\n    return getattr(humps, \"camelize\" if lower else \"pascalize\")(_str)\ndef s2cl(_str):\n    \"\"\"\n    Snake case to camel case (starting with lower letter).\n    \"\"\"\n    return s2c(_str, True)\ndef s2cu(_str):\n    \"\"\"\n    Snake case to camel case (starting with upper letter).\n    \"\"\"\n    return s2c(_str, False)\nclass NeverUndefined(jinja2.StrictUndefined):\n    def __init__(self, *args, **kwargs):\n        # ARGS: (\"parameter 'myvar2' was not provided\",)\n        # KWAR",
        "type": "code",
        "location": "/jinja_utils.py:43-84"
    },
    "849": {
        "file_id": 105,
        "content": "Code comments:\n1. jinja_utils.py:42-83",
        "type": "comment"
    },
    "850": {
        "file_id": 105,
        "content": "GS: {'name': 'myvar2'}\n        if len(args) == 1:\n            info = args[0]\n        elif \"name\" in kwargs.keys():\n            info = f\"Undefined variable '{kwargs['name']}\"\n        else:\n            infoList = [\"Not allowing any undefined variable.\"]\n            infoList.append(f\"ARGS: {args}\")\n            infoList.append(f\"KWARGS: {kwargs}\")\n            info = \"\\n\".join(infoList)\n        raise Exception(info)\ndef load_render_and_format(\n    template_path: str,\n    output_path: str,\n    render_params: dict,\n    banner: str,\n    needFormat: bool = True,\n):\n    tpl = load_template(template_path)\n    result = tpl.render(**render_params)\n    logger_print()\n    logger_print(\"______________________[{}]\".format(banner))\n    logger_print(result)\n    # import black.Mode\n    output_path_elems = output_path.split(\".\")\n    output_path_elems.insert(-1, \"new\")\n    if os.path.exists(output_path):\n        with open(output_path, \"r\") as f:\n            backup_content = f.read()\n    else:\n        backup_content = \"\"\n    with open(tmp",
        "type": "code",
        "location": "/jinja_utils.py:84-120"
    },
    "851": {
        "file_id": 105,
        "content": "load_render_and_format function takes template path, output path, render params, banner and optional needFormat (default True) as input. It loads the template from the specified path, renders it with render params as arguments and prints the result to the logger with a banner separator. If output_path exists, it reads its content for backup, else sets backup content as an empty string.",
        "type": "comment"
    },
    "852": {
        "file_id": 105,
        "content": "_output_path := \".\".join(output_path_elems), \"w+\") as f:\n        f.write(result)\n    if not needFormat:\n        shutil.move(tmp_output_path, output_path)\n        return\n    try:\n        # TODO: add more test, like checking for undefined variables, before rewriting the source file.\n        # TODO: add rollback mechanism in makefile\n        result = black.format_str(result, mode=black.Mode())\n        logger_print(\"Formatter Ok.\")\n        # with TemporaryDirectory() as TP:\n        with open(output_path, \"w+\") as f:\n            f.write(result)\n        # do further type checking.\n        # typechecker_input_path = os.path.join(\n        #     TP, base_output_path := os.path.basename(output_path)\n        # )\n        # with open(typechecker_input_path, \"w+\") as f:\n        #     f.write(typechecker_input_path)\n        # output = subprocess.run(\n        #     [\"pyright\", typechecker_input_path],\n        #     capture_output=True,\n        #     encoding=\"utf-8\",\n        # )\n        run_result = pyright_utils.run(\n       ",
        "type": "code",
        "location": "/jinja_utils.py:120-146"
    },
    "853": {
        "file_id": 105,
        "content": "Writes formatted code to output file, optionally formats again if not needed format, and performs additional type checking.",
        "type": "comment"
    },
    "854": {
        "file_id": 105,
        "content": "     output_path, capture_output=True, encoding=\"utf-8\"\n        )\n        typeErrors = [\n            e.strip().replace(\n                os.path.basename(output_path), os.path.basename(tmp_output_path)\n            )\n            for e in re.findall(\n                pyright_utils.errorRegex, run_result.stdout, re.MULTILINE\n            )\n        ]\n        # breakpoint()\n        if run_result.stderr:\n            typeErrors.append(\"\")\n            typeErrors.append(f\"Pyright error:\\n{run_result.stderr}\")\n        if typeErrors:\n            typeErrors.insert(0, f\"Type error found in file {repr(output_path)}\")\n            raise Exception(f\"\\n{' '*4}\".join(typeErrors))\n        logger_print(\"Pyright Ok.\")\n        os.remove(tmp_output_path)\n    except:\n        import traceback\n        traceback.print_exc()\n        # os.remove(tmp_output_path)\n        with open(output_path, \"w+\") as f:\n            f.write(backup_content)\n        # ref: https://www.geeksforgeeks.org/python-os-utime-method/\n        # do not set this to 0 or so",
        "type": "code",
        "location": "/jinja_utils.py:146-173"
    },
    "855": {
        "file_id": 105,
        "content": "This code is executing a type check on a Python file and handling any errors produced by the pyright linter. It first creates a temporary output path, captures all standard error messages, converts these messages to a list of strings, appends Pyright error content if applicable, and then raises an exception with the compiled error messages. If there are no errors, it prints \"Pyright Ok.\" Finally, if an error occurs during execution, it catches the error, prints the stack trace, writes the backup content into the output file, and removes the temporary output file.",
        "type": "comment"
    },
    "856": {
        "file_id": 105,
        "content": "mething. will cause error.\n        os.utime(\n            output_path,\n            times=(\n                os.path.getatime(template_path) - 1000000,\n                os.path.getmtime(template_path) - 1000000,\n            ),\n        )  # to make this older than template, must update!\n        raise Exception(\n            f\"Code check failed.\\nTemporary cache saved to: '{tmp_output_path}'\"\n        )\n    logger_print(\"=\" * 40)\ndef lstrip(string: str):\n    lines = string.split(\"\\n\")\n    result_lines = []\n    for line in lines:\n        result_lines.append(line.lstrip())\n        # if stripped_line := line.lstrip():\n        # result_lines.append(stripped_line)\n    result = \"\\n\".join(result_lines).strip(\"\\n\")\n    return result\ndef code_and_template_path(base_name):\n    code_path = f\"{base_name}.py\"\n    template_path = f\"{code_path}.j2\"\n    return code_path, template_path\ndef load_template(template_path, extra_func_dict={}):\n    try:\n        assert template_path.endswith(\".j2\")\n    except:\n        Exception(f\"jinja template ",
        "type": "code",
        "location": "/jinja_utils.py:173-209"
    },
    "857": {
        "file_id": 105,
        "content": "The code is checking if the output file is older than the template, and if not, it raises an exception. It also includes functions for string lstrip operation, handling code and template paths, and loading a Jinja2 template.",
        "type": "comment"
    },
    "858": {
        "file_id": 105,
        "content": "path '{template_path}' is malformed.\")\n    env = jinja2.Environment(\n        loader=jinja2.FileSystemLoader(searchpath=[\"./\", \"../\"]),\n        extensions=[\n            \"jinja2_error.ErrorExtension\",\n            \"jinja2.ext.do\",\n            \"jinja2.ext.loopcontrols\",\n        ],\n        trim_blocks=True,\n        lstrip_blocks=True,\n        # undefined=jinja2.StrictUndefined,\n        undefined=NeverUndefined,\n    )\n    tpl = env.get_template(template_path)\n    # def myJoin(mstr, mlist):\n    #     logger_print(\"STR:\", repr(mstr))\n    #     logger_print(\"LIST:\", repr(mlist))\n    #     return mstr.join(mlist)\n    func_dict = dict(\n        list=list,\n        str=str,\n        _dict=dict,\n        _set=set,  # avoid name collision\n        tuple=tuple,\n        ord=ord,\n        len=len,\n        repr=repr,\n        c2s=c2s,\n        # s2c=s2c,\n        s2cl=s2cl,\n        s2cu=s2cu,\n        zip=zip,\n        cws=camelize_with_space,\n        lstrip=lstrip,\n        remove_typehint=remove_typehint,\n        kebabize=humps.kebabize,\n        pa",
        "type": "code",
        "location": "/jinja_utils.py:209-245"
    },
    "859": {
        "file_id": 105,
        "content": "Creates a Jinja2 environment with specified settings, loads template from given path.",
        "type": "comment"
    },
    "860": {
        "file_id": 105,
        "content": "scalize=humps.pascalize,\n        # enumerate=enumerate,\n        # eval=eval,\n        # join=myJoin\n        ** extra_func_dict,\n    )\n    tpl.globals.update(func_dict)\n    return tpl\ndef test(cmd: list, exec=\"python3\" if os.name != \"nt\" else \"python\"):\n    cmd = [exec] + cmd\n    p = subprocess.run(cmd)\n    p.check_returncode()",
        "type": "code",
        "location": "/jinja_utils.py:245-258"
    },
    "861": {
        "file_id": 105,
        "content": "This code is defining a function that converts Jinja template variables into executable Python code. It also imports and updates the template's globals with specified functions and executes it using subprocess.",
        "type": "comment"
    },
    "862": {
        "file_id": 106,
        "content": "/keyboard_and_mouse.py",
        "type": "filepath"
    },
    "863": {
        "file_id": 106,
        "content": "The code uses pynput library to set up listeners for keyboard and mouse events, storing them in a list called HIDEvents. It records the event details based on timestep configuration from a config file and writes them to a JSON lines file, but Windows' zooming factor may affect accuracy.",
        "type": "summary"
    },
    "864": {
        "file_id": 106,
        "content": "from datetime import datetime\nfrom pynput import keyboard\nHIDEvents = []\nfrom config import timestep  # this will be sufficient?\n# problem is the windows zooming factor.\n# is it really the problem?\ndef on_press(key):\n    if type(key) != str:\n        key = str(key)\n    HIDEvents.append(('key_press', key))\ndef on_release(key):\n    if type(key) != str:\n        key = str(key)\n    HIDEvents.append(('key_release', key))\nkeyboard_listener = keyboard.Listener(on_press=on_press, on_release=on_release)\nkeyboard_listener.start()\nfrom pynput import mouse\ndef on_move(x: int, y: int):\n    HIDEvents.append((\"mouse_move\", [x, y]))\ndef on_click(x: int, y: int, button: mouse.Button, pressed: bool):\n    HIDEvents.append((\"mouse_click\", [x, y, str(button), pressed]))\ndef on_scroll(x: int, y: int, dx: int, dy: int):\n    HIDEvents.append((\"mouse_scroll\", [x, y, dx, dy]))\n# # ...or, in a non-blocking fashion:\nlistener = mouse.Listener(on_move=on_move, on_click=on_click, on_scroll=on_scroll)\nlistener.start()\n# you may start that non-b",
        "type": "code",
        "location": "/keyboard_and_mouse.py:1-44"
    },
    "865": {
        "file_id": 106,
        "content": "This code sets up listeners for both keyboard and mouse events, storing the event details in a list called HIDEvents. It uses the pynput library to handle input from the keyboard and mouse. The timestep configuration is loaded from the config file to determine how frequently events are recorded. However, there seems to be a problem related to Windows' zooming factor which might affect the accuracy of the recorded events.",
        "type": "comment"
    },
    "866": {
        "file_id": 106,
        "content": "locking. start some looping-forever thread for writing states to file.\nimport time\n# import pyautogui\n# import datetime\nloopCount = 500\nimport jsonlines\nprint(\"RECORDING START\")\nfrom config import filePath\nimport datetime\nworld_start = datetime.datetime.now()\nwith jsonlines.open(filePath, 'w') as w:\n    for _ in range(loopCount):\n        time.sleep(timestep)\n        # as for screenshot, use mss instead of screenshot.\n        #     screenshot = pyautogui.screenshot()\n        # shall you mark the time here.\n        state = dict(HIDEvents=HIDEvents)  # also the image!\n        print(\"STATE?\", state)\n        w.write(state)\n        HIDEvents = []\n        mouseloc = []",
        "type": "code",
        "location": "/keyboard_and_mouse.py:44-68"
    },
    "867": {
        "file_id": 106,
        "content": "Starts a looping-forever thread for writing states to file. Imports required modules, sets the loop count, and opens a JSON lines file for writing. Within the loop, it waits for a certain period (timestep), captures the current state (HIDEvents dictionary), writes it to the file, and resets the HIDEvents and mouseloc variables.",
        "type": "comment"
    },
    "868": {
        "file_id": 107,
        "content": "/launch_docker_devicemapper_limit_storage.sh",
        "type": "filepath"
    },
    "869": {
        "file_id": 107,
        "content": "This code is discussing various storage options for Docker, specifically focusing on the `--storage-opt` flag and how it interacts with different file systems. It mentions that `--storage-opt` is supported only for overlay over xfs with 'pquota' mount option, and provides examples of using different sizes and file systems like devmapper, LVM, ZFS, and vfs.",
        "type": "summary"
    },
    "870": {
        "file_id": 107,
        "content": "# --storage-opt is supported only for overlay over xfs with 'pquota' mount option.\n# change \"data-root\" to somewhere else in /etc/docker/daemon.json.\n# edit /etc/fstab and add our xfs block on new line (find uuid using blkid)\ndocker run  --storage-opt size=10M --rm -it alpine\n# when using devmapper, make sure size is greater than 10G (default)\n# https://docs.docker.com/storage/storagedriver/device-mapper-driver/#configure-direct-lvm-mode-for-production\n# docker run --storage-opt size=11G --rm -it alpine\n# zfs, vfs (not a unionfs, but for testing) supports disk quota.",
        "type": "code",
        "location": "/launch_docker_devicemapper_limit_storage.sh:1-10"
    },
    "871": {
        "file_id": 107,
        "content": "This code is discussing various storage options for Docker, specifically focusing on the `--storage-opt` flag and how it interacts with different file systems. It mentions that `--storage-opt` is supported only for overlay over xfs with 'pquota' mount option, and provides examples of using different sizes and file systems like devmapper, LVM, ZFS, and vfs.",
        "type": "comment"
    },
    "872": {
        "file_id": 108,
        "content": "/launch_streaming_utils.sh",
        "type": "filepath"
    },
    "873": {
        "file_id": 108,
        "content": "Starting script to launch streaming utilities in new tmux sessions.",
        "type": "summary"
    },
    "874": {
        "file_id": 108,
        "content": "bash off_streaming_utils.sh\n# tmux kill-session -t streaming_utils\ngnome-terminal -- bash ubuntu_qemu_utm_arm_record/kali_prepare_dirs_loop.sh\ngnome-terminal -- tmuxp load streaming_utils.yaml",
        "type": "code",
        "location": "/launch_streaming_utils.sh:2-6"
    },
    "875": {
        "file_id": 108,
        "content": "Starting script to launch streaming utilities in new tmux sessions.",
        "type": "comment"
    },
    "876": {
        "file_id": 109,
        "content": "/lego_mindstorm_physical_mouse_keyboard_control/README.md",
        "type": "filepath"
    },
    "877": {
        "file_id": 109,
        "content": "Exploring an undetectable, cage-based method to control the bot without battery power using keyboard and mouse input.",
        "type": "summary"
    },
    "878": {
        "file_id": 109,
        "content": "And this thing is proposed by our fellows, which is absolutely undetectable by any anti-cheating software.\nIsolated in the cage, so our dataset is names as such.\nWe will try to explore something inside the cage and get interesting results, like using the keyboard and the mouse while looking at the computer screen.\nMost importantly, [how](https://www.eurobricks.com/forum/index.php?/forums/topic/195337-ev3-ac-power-adapter/) do we make it work [without battery power](https://bricksafe.com/pages/Heppu/wip-/ac-adapter), and how to send commands to the bot?\nIs there ssh access to the bot?\nWe can [control](https://github.com/ChristophGaukel/ev3-python3) the bot without ev3dev operate system",
        "type": "code",
        "location": "/lego_mindstorm_physical_mouse_keyboard_control/README.md:1-11"
    },
    "879": {
        "file_id": 109,
        "content": "Exploring an undetectable, cage-based method to control the bot without battery power using keyboard and mouse input.",
        "type": "comment"
    },
    "880": {
        "file_id": 110,
        "content": "/lego_mindstorm_physical_mouse_keyboard_control/test.py",
        "type": "filepath"
    },
    "881": {
        "file_id": 110,
        "content": "This code is initializing an EV3 motor and sending a direct command to play a sound with a frequency of 440Hz, duration of 1000ms, and volume at level 1. It also defines a motor object for port D on the EV3 brick and starts moving the motor by 100 units at speed 100.",
        "type": "summary"
    },
    "882": {
        "file_id": 110,
        "content": "from usb_ev3 import *\nops = b\"\".join(\n    (\n        ev3.opSound,\n        ev3.TONE,\n        ev3.LCX(1),  # VOLUME\n        ev3.LCX(440),  # FREQUENCY\n        ev3.LCX(1000),  # DURATION\n    )\n)\nmy_ev3.send_direct_cmd(ops)\n# voice = ev3.Voice(ev3_obj=my_ev3, volume=100)\n# voice.speak(\"hello world\").start(thread=False) # gtts failed to start.\nmt1 = ev3.Motor(port=ev3.PORT_D, ev3_obj = my_ev3)\nprint(\"motor_type:\", mt1.motor_type ) # 7 -> large motor\n# mt1.start_move_by(10,speed = 100)\n# mt1.start_move_by(10,speed = 1)\nmt1.start_move_by(100,speed = 100)\n# you know it could have problems with the environment\n# when it will stop on bad things?",
        "type": "code",
        "location": "/lego_mindstorm_physical_mouse_keyboard_control/test.py:1-27"
    },
    "883": {
        "file_id": 110,
        "content": "This code is initializing an EV3 motor and sending a direct command to play a sound with a frequency of 440Hz, duration of 1000ms, and volume at level 1. It also defines a motor object for port D on the EV3 brick and starts moving the motor by 100 units at speed 100.",
        "type": "comment"
    },
    "884": {
        "file_id": 111,
        "content": "/lego_mindstorm_physical_mouse_keyboard_control/usb_ev3.py",
        "type": "filepath"
    },
    "885": {
        "file_id": 111,
        "content": "Importing EV3 library and initializing an EV3 object with USB protocol.",
        "type": "summary"
    },
    "886": {
        "file_id": 111,
        "content": "import ev3_dc as ev3\nprotocol_param = dict(protocol=ev3.USB)\nmy_ev3 = ev3.EV3(**protocol_param) # working!\nmy_ev3.verbosity = 1",
        "type": "code",
        "location": "/lego_mindstorm_physical_mouse_keyboard_control/usb_ev3.py:1-5"
    },
    "887": {
        "file_id": 111,
        "content": "Importing EV3 library and initializing an EV3 object with USB protocol.",
        "type": "comment"
    },
    "888": {
        "file_id": 112,
        "content": "/lunar_lander_test/test.py",
        "type": "filepath"
    },
    "889": {
        "file_id": 112,
        "content": "This code imports the gymnasium library and creates a LunarLander environment. It then resets the environment, takes 1000 random actions, steps through each action, checks for termination or truncation, and resets if necessary. The environment can be visualized using Pygame but the image saving is commented out in this code snippet.",
        "type": "summary"
    },
    "890": {
        "file_id": 112,
        "content": "import gymnasium as gym\n# import pygame\nenv = gym.make(\"LunarLander-v2\", render_mode=\"human\")\nobservation, info = env.reset(seed=42)\nfor _ in range(1000):\n    action = env.action_space.sample()  # this is where you would insert your policy\n    observation, reward, terminated, truncated, info = env.step(action)\n    # let's check.\n    # pygame.image.save(env.screen, \"image.png\")  # type:ignore\n    # exit()\n    # observation: (8,)\n    # reward: float value\n    # no image?\n    if terminated or truncated:\n        observation, info = env.reset()\nenv.close()",
        "type": "code",
        "location": "/lunar_lander_test/test.py:1-21"
    },
    "891": {
        "file_id": 112,
        "content": "This code imports the gymnasium library and creates a LunarLander environment. It then resets the environment, takes 1000 random actions, steps through each action, checks for termination or truncation, and resets if necessary. The environment can be visualized using Pygame but the image saving is commented out in this code snippet.",
        "type": "comment"
    },
    "892": {
        "file_id": 113,
        "content": "/metalearning_random_shuffle/README.md",
        "type": "filepath"
    },
    "893": {
        "file_id": 113,
        "content": "This code describes the goal of performing operations like copy, cut, and shuffle without relying on annotations while potentially reducing entropy.",
        "type": "summary"
    },
    "894": {
        "file_id": 113,
        "content": "we want to learn the unspeakable. we want to be annotation free.\nso basically we can do following operations:\ncopy, cut, shuffle\nin which the entropy might be reduced.",
        "type": "code",
        "location": "/metalearning_random_shuffle/README.md:1-7"
    },
    "895": {
        "file_id": 113,
        "content": "This code describes the goal of performing operations like copy, cut, and shuffle without relying on annotations while potentially reducing entropy.",
        "type": "comment"
    },
    "896": {
        "file_id": 114,
        "content": "/metalearning_random_shuffle/main.py",
        "type": "filepath"
    },
    "897": {
        "file_id": 114,
        "content": "Generating and printing all possible combinations of letters and digits, copying the dataset twice, cutting the dataset to create a new one, shuffling the dataset.",
        "type": "summary"
    },
    "898": {
        "file_id": 114,
        "content": "import string\ndataset = list(string.ascii_letters + string.digits)\nprint(dataset)\n# copy\nprint(dataset * 2)\n# cut\nprint(dataset[0:5] + dataset[10:])\n# shuffle\nimport random\nrandom.shuffle(dataset)\nprint(dataset)\n# and this is what you must learn",
        "type": "code",
        "location": "/metalearning_random_shuffle/main.py:1-18"
    },
    "899": {
        "file_id": 114,
        "content": "Generating and printing all possible combinations of letters and digits, copying the dataset twice, cutting the dataset to create a new one, shuffling the dataset.",
        "type": "comment"
    }
}