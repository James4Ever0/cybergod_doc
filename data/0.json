{
    "0": {
        "file_id": 0,
        "content": "/Dockerfile",
        "type": "filepath"
    },
    "1": {
        "file_id": 0,
        "content": "This Dockerfile uses x11docker/xserver as the base image and sets up a development server. It may be used with docker-compose.",
        "type": "summary"
    },
    "2": {
        "file_id": 0,
        "content": "# FROM ubuntu:22.04\n# ref: https://gitlab.com/mviereck/x11docker#docker-desktop-or-docker-engine\nFROM x11docker/xserver:latest\n####### LAZERO DEVELOPMENT SERVER #######\n# docker compose?",
        "type": "code",
        "location": "/Dockerfile:1-5"
    },
    "3": {
        "file_id": 0,
        "content": "This Dockerfile uses x11docker/xserver as the base image and sets up a development server. It may be used with docker-compose.",
        "type": "comment"
    },
    "4": {
        "file_id": 1,
        "content": "/Makefile",
        "type": "filepath"
    },
    "5": {
        "file_id": 1,
        "content": "The code snippet adjusts environment variables according to the OS and prepares necessary files/directories for testing a project. The Makefile builds, executes the Python test project, syncs utilities, handles dependencies, and creates JSON files using tools like pytest, renderer, bash script, and Pip installer.",
        "type": "summary"
    },
    "6": {
        "file_id": 1,
        "content": ".PHONY: test\n# may borrow system check code from ies.\nPLATFORM := $(shell python -c \"import os; print(os.name)\")\nifeq (${PLATFORM}, )\nPLATFORM := $(shell python3 -c \"import os; print(os.name)\") # executed on macos\nendif\nifeq (${PLATFORM}, nt)\nOS_TYPE = windows\nelse\nOS_TYPE = macos\nendif\nPYTHON_ENV = -X utf8=1\nifeq (${OS_TYPE}, macos)\nCONDA_ENV = rosetta\nPYTHON = /usr/bin/python3\nPIP = ${PYTHON} -m pip\nelse\nCONDA_ENV = cplex\nPYTHON = python ${PYTHON_ENV}\nPIP = gsudo ${PYTHON} -m pip\nendif\n#### ALWAYS REMEMBER TO EXPORT USEFUL VARIABLES ####\nexport OS_TYPE PLATFORM PYTHON PYTHON_ENV CONDA_ENV\n#### ALWAYS REMEMBER TO EXPORT USEFUL VARIABLES ####\nRENDERED_CODE = conscious_struct.py hid_utils.py\nRENDER_UTILS = jinja_utils.py pyright_utils.py\nUTILS = log_utils.py ${RENDER_UTILS}\nUTILS_SYNC_DIR = ../jubilant-adventure2/microgrid_base/\n# shall you dump log to file, not to display it here\nexport RENDERED_CODE\ntest: ${UTILS} ${RENDERED_CODE} test/test_project.py\n\tcd test && ${PYTHON} -m pytest --lf --lfnf=all --capture=tee-sy",
        "type": "code",
        "location": "/Makefile:1-42"
    },
    "7": {
        "file_id": 1,
        "content": "Code snippet sets environment variables based on the operating system and defines necessary files and directories for testing a project.",
        "type": "comment"
    },
    "8": {
        "file_id": 1,
        "content": "s test_project.py\n\t# cd test && ${PYTHON} -m pytest --lf --lfnf=all --capture=tee-sys --log-level=DEBUG test_project.py\n${RENDERED_CODE}: $(addsuffix .j2, ${RENDERED_CODE}) ${RENDER_UTILS}\n\t${PYTHON} render_python_code.py $@\n${UTILS}: $(addprefix  ${UTILS_SYNC_DIR}, ${UTILS})\n\tbash sync_utils.sh $@ ${UTILS_SYNC_DIR}\nsetup:\n\t${PIP} install -r requirements.txt\nKL2XKS.json: hid_utils.py\n\t${PYTHON} hid_utils.py\nsoftware_interface: ${RENDERED_CODE}\n\t${MAKE} -e -C software_capture_hid_control\nhardware_interface: ${RENDERED_CODE}\n\t${MAKE} -e -C hardware_capture_hid_power_control",
        "type": "code",
        "location": "/Makefile:42-61"
    },
    "9": {
        "file_id": 1,
        "content": "This Makefile contains rules for building and executing a Python test project, rendering Python code, synchronizing utils, setting up dependencies, and creating JSON files. It involves various tools like pytest, Python renderer, bash script, and Pip installer.",
        "type": "comment"
    },
    "10": {
        "file_id": 2,
        "content": "/README.md",
        "type": "filepath"
    },
    "11": {
        "file_id": 2,
        "content": "Cybergod is a project utilizing GPT4 MoE architecture, targeting specific audiences with entertainment and utility features. It involves devcontainers, AI training, multiple services/agents, mouse calibration, learning approach, pre-trained data via random keystrokes, and explores AI limitations, visual grids, prompt engineering, different environments (Chromium/Firefox), Docker for isolated execution, and JPEG streaming services for visualization.",
        "type": "summary"
    },
    "12": {
        "file_id": 2,
        "content": "![Cybergod logo](propaganda/logos/cybergod_2.png)\nhttps://github.com/Significant-Gravitas/Auto-GPT/assets/103997068/8e1cd6fe-c49d-4d2b-835d-0ffc9a5a458e\n# Cybergod\n[join discord group](https://discord.gg/eM5vezJvEQ)\n[bilibili live streaming](http://live.bilibili.com/22228498)\n## Intro\nTrained on [The Frozen Forest](https://huggingface.co/datasets/James4Ever0/the_frozen_forest), a [dataset](https://modelscope.cn/datasets/james4ever0/the_frozen_forest/summary) containing random keystrokes, mouse clicks and screen recordings.\nthe openai [universe](https://github.com/openai/universe) is using VNC, almost doing the same thing.\nyou can find some demo models from [there](https://github.com/openai/universe-starter-agent).\ncheck out [SerpentAI](https://github.com/SerpentAI/SerpentAI)\nbut why bother? we can build these things in the same way.\nhuman demonstrations are limited, but random keystrokes are infinite.\ntry to obtain infinite data as pretrained data, then fine-tune on human demonstrations.\n---\n键鼠真神是一种",
        "type": "code",
        "location": "/README.md:1-29"
    },
    "13": {
        "file_id": 2,
        "content": "The code is displaying the Cybergod logo and providing links to various resources such as a discord group, live streaming site, and related datasets. The intro section explains the concept of using random keystrokes for pre-trained data instead of human demonstrations, mentioning similar projects like OpenAI's Universe and SerpentAI.",
        "type": "comment"
    },
    "14": {
        "file_id": 2,
        "content": "意识形态\ncybergod is an ideology.\n键鼠真神 又名cybergod 赛博真神\n训练数据集为the frozen forest 随机敲键盘点鼠标 录屏\n奖励函数 如果屏幕发生变化 奖励上一次行为\n避免把系统关机 被锁在屏幕外面\n避免机器卡死： 监测机器是否卡死 如果卡死那么自动外部重启 （重置状态，重新跑脚本）\n连着WEBDAV一起刷新 有filelock\n(直接取消lock权限)\n---\nlooking for using docker for automation, or using some tty-like things for automation.\ndisable ubuntu system authentication?\n---\nmake some server for vm to access to restart the webdav server when you have error.\n---\nagi_workspace happen to be in recycle bin. make sure we have the init files.\nmake sure we can restore our environments in every restart.\n---\nspice-protocol\nfound on utm.app, launch qemu and create spice unix socket.\nhttps://github.com/Shells-com/spice\nhttps://github.com/gnif/PureSpice\nhttps://github.com/citrix-openstack-build/spice-html5\nhttps://github.com/oetcxiaoliu/spice\nhttps://github.com/TotallWAR/spice_protocol\nremmina\n---\n掉盘问题： `cd .`\n(建议直接换个盘 或者换C口的数据线 A口不稳定 或者把硬盘取出来更新固件？)\nc口数据线观测中\n---\nto resolve the display resolution/mouse coordinate range matching issue, use pyautogui to get the resolutio",
        "type": "code",
        "location": "/README.md:29-91"
    },
    "15": {
        "file_id": 2,
        "content": "Ideology and system requirements for cybergod automation.",
        "type": "comment"
    },
    "16": {
        "file_id": 2,
        "content": "n then capture display using that resolution (resize to it)\n---\nGPT4 is using MoE as its architecture.\n---\nthe main objective of AGI is to create another version of itself.\n---\nways of connection:\nvnc, ssh, tty, tmux, hdmi capture & hid emulator, window capture and directed inputs (os specific)\n---\nthe point is not making this exhaustive. it is about making some standard i/o and adapt to every situation.\n---\n改变开发思路：将功能和娱乐相结合\n受众：游戏娱乐向 实用向\n发布程序到steam平台\n为此需要宣传、绘画设计等等\n---\n用elo进行打分 分高的可以在官网有较高的模型权重排名\n---\ntechnically this would not be a normal game. it is a metagame, which is the game of all games. it can play other games, play itself, even create itself.\n---\ndevcontainer is useful for creating reproducible environments locally (if of the same architecture, like x86) or remotely (different architecture, like Apple M1).\n---\nbecause setting this up properly during development is a pain in the ass (in most time), let's pack it up into a docker container, for your safety.\nif you want to release this and use it in prod",
        "type": "code",
        "location": "/README.md:91-137"
    },
    "17": {
        "file_id": 2,
        "content": "The code is providing information about the project's features and objectives. It mentions GPT4 using MoE architecture, different connection ways, adapting to every situation, combining entertainment and utility, target audience, elo scoring, being a metagame that can play other games, and the use of a devcontainer for development environments.",
        "type": "comment"
    },
    "18": {
        "file_id": 2,
        "content": "uction, you can refactor the code, configure platform specific dependencies and send it to devops.\n---\ndevcontainer won't work as expected on windows 11 as we put our repo on external disk\n---\nyour aim is too damn big! shall you begin to train some primitive neural network with functionality of only emitting and receiving ascii words, even just a single character like 'C'. get your hands dirty!\n---\nthe basic docker service is just like havoc. it does not contain anything 'intelligent'. only 'life support'.\nwe plan to containerize chatdev/open-interpreter/autogpt. after that, we will combine the two, and create some 'capitalism' among multiple containers.\nfinally we will create some ever-evolving agent and use that as the building block for the megasystem.\n---\nthe mouse calibration issue can be of major concern. we don't find it anywhere. \nuse active inference or reinforcement learning?\n---\nthanks to our pioneers that guided us some 'aimless' learning, i think it does not matter how we learn specifi",
        "type": "code",
        "location": "/README.md:137-164"
    },
    "19": {
        "file_id": 2,
        "content": "This code appears to contain various notes and comments related to development, containerization, and AI training. The author seems to be working on a project involving containers, AI, and potentially multiple services or agents interacting with each other. Some issues like mouse calibration and the approach for learning are also mentioned.",
        "type": "comment"
    },
    "20": {
        "file_id": 2,
        "content": "c things. when we learn things relevant to our personal goals, we are inevitably going to optimize the algorithm towards our desired values.\nif qstar is just about long term thinking, it could be useful since that is something currently missing in ai systems. when it comes to issues like calibration errors, fixing bugs, handling uncertainties, worse than human. they often get stuck into repetition, never seek for improvements and will not get bored in the loop, which is quite strange and unusual.\n---\ni think you are getting jealous over openai, since they are consisted of the world's smartest asses and come over new ideas every fucking day. but that does not matter. i think i had the idea before. i think everyone around the world had the same damn idea before. we do not need its mercy to teach us the dream we had via abstract symbols and formulas. we do our own. worst of all, they do not trust their ai systems, severely limited the ability of ai, left it overthinking and powerless.\n---\nthe ",
        "type": "code",
        "location": "/README.md:164-175"
    },
    "21": {
        "file_id": 2,
        "content": "This code discusses the limitations of current AI systems and their inability to adapt or optimize towards personal goals. It also expresses frustration with other organizations, such as OpenAI, believing that everyone has had similar ideas before and that they do not trust or fully utilize their AI systems.",
        "type": "comment"
    },
    "22": {
        "file_id": 2,
        "content": "`self-operating-computer` is using visual grid (just putting grid and text over screenshot, kinda like this hackish approach) for calibration. are you sure it is a good idea? do you need some extra channel over this to avoid information loss?\ndoes this work for games as well?\n---\nprompt engineering is a tweak around prior, in order to change posterior. they want to know better prior to get better posterior. kind like searching for the reason behind the decision, backtracking. so why not just use bidirectional or arbitrary directional language models instead of causal models?\n---\ni don't understand active inference. however there is a debate over whether to change the environment to fit prediction, or to change prediction to fit the environment. sounds like quantum entanglement.\n---\nthe reward function is part of the observation, usually not something life critical so it will not be so direct. it is the internal state that will be affected by the observation.\n---\nplay fps at: https://krunker.io/",
        "type": "code",
        "location": "/README.md:175-193"
    },
    "23": {
        "file_id": 2,
        "content": "The code seems to contain a mix of thoughts and questions related to various topics such as visual grids, calibration methods, prompt engineering, active inference, reward functions, and gaming. The author appears to be seeking insights into these areas and is open to suggestions for improvement or alternative approaches.",
        "type": "comment"
    },
    "24": {
        "file_id": 2,
        "content": " (in chromium, not firefox)\n---\nif want to run the program isolated, without interference, you use docker. if want to visualize, use jpeg streaming service and open in browser.\n## Star History\n<img src=\"https://api.star-history.com/svg?repos=james4ever0/agi_computer_control&Timeline\" style=\"filter: invert(100%);\"></img>",
        "type": "code",
        "location": "/README.md:193-201"
    },
    "25": {
        "file_id": 2,
        "content": "This code snippet describes how to run a program in different environments: within Chromium or Firefox, using Docker for isolated execution without interference, and utilizing JPEG streaming services for visualization by opening it in the browser. Additionally, it shows an image of star history from the \"james4ever0/agi_computer_control\" repository on the Star-History website.",
        "type": "comment"
    },
    "26": {
        "file_id": 3,
        "content": "/action_state_machine/example.txt",
        "type": "filepath"
    },
    "27": {
        "file_id": 3,
        "content": "The code is showing a terminal session where a user is inputting and receiving responses. It displays commands, system prompts, and cursor movements.",
        "type": "summary"
    },
    "28": {
        "file_id": 3,
        "content": "<human>are you doing just fine?<self>i am fine.<terminal_read>100</terminal_read>root@localhost ~/<type>hello world/n<reply>i am doing just fine. are you ok?<terminal_cursor_back>100</terminal_cursor_back><type>hello world</type><terminal_read>100</terminal_read>root@localhost ~/hello world\\nno such command\\nhello world\\nno such command\\nroot@localhost ~/</terminal_read><read_around_cursor>root@localhost ~/<cursor><move_cursor_forward>10</move_cursor_forward><read_around_cursor>root@localhost ~/<cursor><move_cursor_back>10</move_cursor_back>10<read_around_cursor>root@localhost ~/<cursor><type>hello world<read_around_cursor>root@localhost ~/hello world<cursor>",
        "type": "code",
        "location": "/action_state_machine/example.txt:1-1"
    },
    "29": {
        "file_id": 3,
        "content": "The code is showing a terminal session where a user is inputting and receiving responses. It displays commands, system prompts, and cursor movements.",
        "type": "comment"
    },
    "30": {
        "file_id": 4,
        "content": "/array_check_ast_parsing.py",
        "type": "filepath"
    },
    "31": {
        "file_id": 4,
        "content": "Reading code and storing its content into a string variable. Parsing the code using ast and iterating through the body elements, printing their attributes and checking for annotations.",
        "type": "summary"
    },
    "32": {
        "file_id": 4,
        "content": "code_path = \"array_static_typecheck.py\"\nimport ast\nimport rich\nwith open(code_path, \"r\") as f:\n    content = f.read()\n    tree = ast.parse(content)\n    for el in tree.body:\n        rich.print(el.__dict__)\n        # rich.print(dir(el))\n        print(ann:=getattr(el, \"annotation\", None))\n        if ann:\n            print(ast.unparse(el), el) # ast.AnnAssign",
        "type": "code",
        "location": "/array_check_ast_parsing.py:1-14"
    },
    "33": {
        "file_id": 4,
        "content": "Reading code and storing its content into a string variable. Parsing the code using ast and iterating through the body elements, printing their attributes and checking for annotations.",
        "type": "comment"
    },
    "34": {
        "file_id": 5,
        "content": "/array_shape_typecheck.py",
        "type": "filepath"
    },
    "35": {
        "file_id": 5,
        "content": "Code creates 2D arrays 'arr' and 'arr2', defines class 'Array' with addition and absolute value methods, and uses numpy and Literal casting. It retrieves annotations from 'myArr' and suggests using Jinja2 macros for type checking/annotation work to prevent errors.",
        "type": "summary"
    },
    "36": {
        "file_id": 5,
        "content": "from typing_extensions import reveal_type\nimport numpy as np\n# from typing import Tuple\n# from numpy.typing import NDArray, DTypeLike\nfrom nptyping import NDArray, Shape, Float  # type: ignore\nfrom typing import Any\nM = 5\nN = 10\narr: NDArray[Shape[\"5, 10\"], Any] = np.zeros((M, N))\narr2: NDArray[Shape[\"10, 5\"], Any] = np.zeros((N, M))\n# no annotation!\nimport beartype  # type:ignore\n@beartype.beartype  # check before run?\ndef add_arrays(\n    arr1: NDArray[Shape[\"5, 10\"], Any], arr2: NDArray[Shape[\"5, 10\"], Any]\n) -> NDArray[Shape[\"5, 10\"], Any]:\n    result = arr1 + arr2\n    return result\nmyarr = add_arrays(arr, arr)  # no issue?\n# myarr = add_arrays(arr, arr2)  # only beartype shows issue.\nreveal_type(myarr)\n# from jaxtyping import Array\n# not typechecking. import from jax.\n# from jax import Array  # type: ignore\n# import jaxtyping  # type: ignore\n# from typing_extensions import TypeAlias\nfrom typing import cast\n# mTypeAlias: TypeAlias = jaxtyping.Float[Array, \"dim1 dim2\"]\n# arr3 = cast(mTypeAlias, np.array([[1, 2,",
        "type": "code",
        "location": "/array_shape_typecheck.py:1-38"
    },
    "37": {
        "file_id": 5,
        "content": "Code is defining variables `arr` and `arr2` as numpy arrays with shapes 5x10 and 10x5 respectively.\nFunction `add_arrays` takes two numpy arrays of shape 5x10 as input and returns an output numpy array also of shape 5x10.\nVariable `myarr` is assigned the result of calling function `add_arrays` with arrays `arr` and `arr`.\nFunction `reveal_type(myarr)` reveals the actual type of variable `myarr`.",
        "type": "comment"
    },
    "38": {
        "file_id": 5,
        "content": " 3]]))\n# # arr3: mTypeAlias = np.array([[1, 2, 3]])\n# arr4: jaxtyping.Float[Array, \"dim1 dim3\"] = np.array([[1, 2, 3, 5]])\n# @beartype.beartype\n# def add2(a: mTypeAlias, b: mTypeAlias) -> mTypeAlias:\n#     return a + b\n# # arr5 = add2(arr3, arr4)\n# arr5 = add2(arr3, arr3)  # still not working.\n# from typing import TypeVar, Generic\n# from typing_extensions import TypeVarTuple, Unpack\n# DType = TypeVar(\"DType\")\n# Shape = TypeVarTuple(\"Shape\")\n# class Array(Generic[DType, Unpack[Shape]]):\n#     def __abs__(self) -> Array[DType, Unpack[Shape]]:\n#         ...\n#     def __add__(\n#         self, other: Array[DType, Unpack[Shape]]\n#     ) -> Array[DType, Unpack[Shape]]:\n#         ...\n# from typing import Literal\n# arr9 = cast(Array[int, Literal[1], Literal[3]], np.array([[1, 2, 3]]))\n# arr10 = cast(Array[int, Literal[1], Literal[4]], np.array([[1, 2, 3, 4]]))\n# arr11 = arr9 + arr10  # checked!\n# arr11 = arr9+arr9\nfrom typing_extensions import Annotated\nmyType = Annotated[np.ndarray, 20, 30]\nmyArr: myType = np.zeros((20",
        "type": "code",
        "location": "/array_shape_typecheck.py:38-80"
    },
    "39": {
        "file_id": 5,
        "content": "37-46: Define 2D array 'arr3' with type 'mTypeAlias'.\n47-59: Define 2D array 'arr4' with type 'jaxtyping.Float[Array, \"dim1 dim3\"]'.\n60-68: Define a function 'add2' that takes two 'mTypeAlias' arguments and returns 'mTypeAlias'.\n69-72: Add arrays 'arr3' and 'arr4' using the 'add2' function, but the result is not working as expected.\n75-80: Define generic class 'Array' with type variables for data type and shape tuple.\n81-85: Define '__abs__' method in 'Array' class to return an array of the same data type and shape.\n86-90: Define '__add__' method in 'Array' class to perform addition of two arrays with matching data type and shape.\n92-100: Define 'arr9' as a casted 2D array using numpy and 'Literal' from typing for specific dimensions.\n101-111: Define 'arr10' as a casted 2D array using numpy and 'Literal' from typing for specific dimensions.\n112-114: Add 'arr9' and 'arr10', and store the result in 'arr11'.\n115-117: Add 'arr9' to itself, and store the result in 'arr11'.\n118-123: Define a new type 'myType' using Annotated from typing_extensions for np.ndarray with specific dimensions.\n124-126: Create an instance of 'myType', initialize it with zeros, and store the result in 'myArr'.",
        "type": "comment"
    },
    "40": {
        "file_id": 5,
        "content": ", 30))\n# how to get that annotated value?\n# print('ANNOTATION?',myArr.__annotations__)\nprint(__annotations__)\n# {'arr': NDArray[Shape['5, 10'], Any], 'arr2': NDArray[Shape['10, 5'], Any], 'myArr': typing_extensions.Annotated[numpy.ndarray, 20, 30]}\n# one such way to prevent errors is to delegate some type checking/annotation work to jinja2. use macro to generate annotations.",
        "type": "code",
        "location": "/array_shape_typecheck.py:80-86"
    },
    "41": {
        "file_id": 5,
        "content": "The code is attempting to retrieve annotations from a variable 'myArr'. It first prints the current annotations using `__annotations__` and then mentions the idea of preventing errors by delegating type checking/annotation work to Jinja2 using macros for generating annotations.",
        "type": "comment"
    },
    "42": {
        "file_id": 6,
        "content": "/array_static_typecheck.py",
        "type": "filepath"
    },
    "43": {
        "file_id": 6,
        "content": "The code defines a generic class for arrays, performs operations like absolute value and addition, uses NewType to define specific types, and employs annotations for operations and shape constraints. It also includes a variable 'val4' that can be simplified using SymPy.",
        "type": "summary"
    },
    "44": {
        "file_id": 6,
        "content": "# link: https://taoa.io/posts/Shape-typing-numpy-with-pyright-and-variadic-generics\n# PEP 646: https://peps.python.org/pep-0646/\n# mypy --enable-incomplete-feature=Unpack --enable-incomplete-feature=TypeVarTuple  array_static_typecheck.py\nfrom typing import TypeVar, Generic, NewType, Literal\nfrom typing_extensions import TypeVarTuple, Unpack, Self, Annotated\nDType = TypeVar(\"DType\")\nShape = TypeVarTuple(\"Shape\")\nclass Array(Generic[DType, Unpack[Shape]]):\n    def __abs__(self) -> Self:\n        ...\n    def special_ops(self, a: Annotated[int, 2, 3]) -> Annotated[int, 1, 2]:\n        ...\n    def __add__(self, other: Self) -> Self:\n        ...\nHeight = NewType(\"Height\", int)\nWidth = NewType(\"Width\", int)\nx: Array[float, Height, Width] = Array()\ny: Array[float, Literal[1], Literal[1]] = Array()\nz = abs(y)\nh = x + y\na0: Annotated[float, 1, 2] = 1\nx.special_ops(a0)  # annotated will not be checked here.\nval: int\nval2: \"annotated_info\"  # <ast.Constant object at 0x101306290>\n# T = TypeVar(\"T\")\n# T2 = TypeVar(\"T2\")\nval3:",
        "type": "code",
        "location": "/array_static_typecheck.py:1-39"
    },
    "45": {
        "file_id": 6,
        "content": "This code is defining a generic class for arrays, implementing type checking using type variables, and performing array operations such as absolute value and addition. It also utilizes NewType to define specific types like Height and Width. The code includes annotations for specific operations and shape constraints.",
        "type": "comment"
    },
    "46": {
        "file_id": 6,
        "content": " Annotated[\n    int, T * T2\n]  # which can only be understood by some type checker. passing this to sympy will be much better.\nval4: Annotated[int, \"T*T2\"]\nval4: Annotated[int, \"T*T3\"] # this is valid, for now.",
        "type": "code",
        "location": "/array_static_typecheck.py:39-43"
    },
    "47": {
        "file_id": 6,
        "content": "The code defines a variable 'val4' annotated with types \"T*T2\" and later changes it to \"T*T3\". This variable is understood by some type checker and could be simplified using SymPy.",
        "type": "comment"
    },
    "48": {
        "file_id": 7,
        "content": "/autogui.py",
        "type": "filepath"
    },
    "49": {
        "file_id": 7,
        "content": "Both comments discuss Python scripts that utilize modules such as \"autogui\" or \"win32gui\" to capture and record GUI input, simulate keystrokes with a delay, and playback recorded events while allowing screenshot capturing.",
        "type": "summary"
    },
    "50": {
        "file_id": 7,
        "content": "import pyautogui, time, sys, os, win32api, win32gui, win32con, datetime, pyHook, pythoncom\nfrom optparse import OptionParser\n'''\nPython Automated Actions Script by Ian Mckay\nVersion 0.1 - 20151217\n'''\npyautogui.PAUSE = 0\npyautogui.FAILSAFE = True\nmain_thread_id = win32api.GetCurrentThreadId()\nevents = []\nrecording = False\ndef OnMouseEvent(event):\n\tglobal events\n\tglobal recording\n\tif (event.Message!=512): # 512 is mouse move\n\t\t'''\n\t\tprint('MessageName:',event.MessageName)\n\t\tprint('Message:',event.Message)\n\t\tprint('Time:',event.Time)\n\t\tprint('Window:',event.Window)\n\t\tprint('WindowName:',event.WindowName)\n\t\tprint('Position:',event.Position)\n\t\tprint('Wheel:',event.Wheel)\n\t\tprint('Injected:',event.Injected)\n\t\tprint('---')\n\t\t'''\n\t\tif (recording==True):\n\t\t\tevents.append([event.Position[1],event.Position[0],event.Message,event.Time,\"2\"])\n\treturn True\ndef OnKeyboardEvent(event):\n\tglobal hm\n\tglobal events\n\tglobal recording\n\tglobal starttime\n\tglobal main_thread_id\n\t'''\n\tprint('MessageName:',event.MessageName)\n\tprint('Message:',event",
        "type": "code",
        "location": "/autogui.py:1-45"
    },
    "51": {
        "file_id": 7,
        "content": "This code imports various libraries and defines several functions for automating user actions, such as capturing mouse and keyboard events. It appears to be part of an automated action script with the capability to record and playback user input.",
        "type": "comment"
    },
    "52": {
        "file_id": 7,
        "content": ".Message)\n\tprint('Time:',event.Time)\n\tprint('Window:',event.Window)\n\tprint('WindowName:',event.WindowName)\n\tprint('Ascii:', event.Ascii, chr(event.Ascii))\n\tprint('Key:', event.Key)\n\tprint('KeyID:', event.KeyID)\n\tprint('ScanCode:', event.ScanCode)\n\tprint('Extended:', event.Extended)\n\tprint('Injected:', event.Injected)\n\tprint('Alt', event.Alt)\n\tprint('Transition', event.Transition)\n\tprint('---')\n\t'''\n\tif (recording==True):\n\t\tif (event.Key==\"End\"):\n\t\t\thm.UnhookKeyboard()\n\t\t\thm.UnhookMouse()\n\t\t\twin32api.PostThreadMessage(main_thread_id, win32con.WM_QUIT, 0, 0);\n\t\t\tevents.append([\"0\",\"0\",\"1\",event.Time,\"0\"])\n\t\t\tprint(\"Ended recording\")\n\t\t\tprint('\\a')\n\t\t\treturn False\n\t\telse:\n\t\t\tevents.append([event.Extended,event.KeyID,event.Message,event.Time,\"1\"])\n\tif (recording==False):\n\t\tif (event.Key==\"Home\" and event.Message==257):\n\t\t\tstarttime = datetime.datetime.now().time()\n\t\t\trecording = True\n\t\t\tprint(\"Started recording\")\n\t\t\tprint('\\a')\n\t\t\tevents.append([\"0\",\"0\",\"0\",event.Time,\"0\"])\n\t\t\treturn False\n\treturn True\ndef record():\n\tglobal",
        "type": "code",
        "location": "/autogui.py:45-84"
    },
    "53": {
        "file_id": 7,
        "content": "This code is handling keyboard and mouse events. If the \"End\" key is pressed while recording, it will stop recording and end the program. If the \"Home\" key is pressed, it starts recording. The events are being appended to a list for future use.",
        "type": "comment"
    },
    "54": {
        "file_id": 7,
        "content": " hm\n\tprint(\"Hooking now...\")\n\thm = pyHook.HookManager()\n\thm.MouseAll = OnMouseEvent\n\thm.KeyAll = OnKeyboardEvent\n\thm.HookMouse()\n\thm.HookKeyboard()\n\tprint(\"Hooked\")\n\tpythoncom.PumpMessages()\n\tprint(\"Exporting...\")\n\tf = open('recording.txt', 'w+')\n\tfor event in events:\n\t\tf.write(str(event.pop()) + ',' + str(event.pop()) + ',' + str(event.pop()) + ',' + str(event.pop()) + ',' + str(event.pop()) + '\\n')\n\tf.close()\n\tprint(\"Ending...\")\ndef play():\n\tprint(\"Starting in 2 secs...\")\n\ttime.sleep(2)\n\tlasttime=False\n\twith open('recording.txt') as fp:\n\t\tfor line in fp:\n\t\t\telements = line.split(',')\n\t\t\teventdata2 = int(elements.pop().replace('\\n',''))\n\t\t\teventdata1 = int(elements.pop())\n\t\t\teventsubtype = int(elements.pop())\n\t\t\teventtime = int(elements.pop())\n\t\t\teventtype = int(elements.pop())\n\t\t\tif (lasttime==False):\n\t\t\t\tif (eventtype==0 and eventsubtype==0):\n\t\t\t\t\tlasttime=eventtime\n\t\t\t\telse:\n\t\t\t\t\tprint(\"Source data error! (eventtype=\" + str(eventtype) + \", eventsubtype=\" + str(eventsubtype) + \")\")\n\t\t\t\t\tsys.exit(1)\n\t\t\telif (eventty",
        "type": "code",
        "location": "/autogui.py:84-122"
    },
    "55": {
        "file_id": 7,
        "content": "Hooking the mouse and keyboard events, recording them in a file named 'recording.txt', and then playing back the recorded events.",
        "type": "comment"
    },
    "56": {
        "file_id": 7,
        "content": "pe==1):\n\t\t\t\ttime.sleep(max((eventtime-lasttime)/1000,0.02)) # At least 20ms between everything\n\t\t\t\tif (eventdata1>32 and eventdata1<127 and eventdata2==0):\n\t\t\t\t\tkey = chr(eventdata1).lower()\n\t\t\t\telif (eventdata1==91 and eventdata2==1):\n\t\t\t\t\tkey = \"winleft\"\n\t\t\t\telif (eventdata1==9 and eventdata2==0):\n\t\t\t\t\tkey = \"tab\"\n\t\t\t\telif (eventdata1==20 and eventdata2==0):\n\t\t\t\t\tkey = \"capslock\"\n\t\t\t\telif (eventdata1==160 and eventdata2==0):\n\t\t\t\t\tkey = \"shiftleft\"\n\t\t\t\telif (eventdata1==162 and eventdata2==0):\n\t\t\t\t\tkey = \"ctrlleft\"\n\t\t\t\telif (eventdata1==164 and eventdata2==0):\n\t\t\t\t\tkey = \"altleft\"\n\t\t\t\telif (eventdata1==32 and eventdata2==0):\n\t\t\t\t\tkey = \"space\"\n\t\t\t\telif (eventdata1==165 and eventdata2==1):\n\t\t\t\t\tkey = \"altright\"\n\t\t\t\telif (eventdata1==163 and eventdata2==1):\n\t\t\t\t\tkey = \"ctrlright\"\n\t\t\t\telif (eventdata1==37 and eventdata2==1):\n\t\t\t\t\tkey = \"left\"\n\t\t\t\telif (eventdata1==40 and eventdata2==1):\n\t\t\t\t\tkey = \"down\"\n\t\t\t\telif (eventdata1==39 and eventdata2==1):\n\t\t\t\t\tkey = \"right\"\n\t\t\t\telif (eventdata1==161 and eventdata2==1):\n\t\t\t",
        "type": "code",
        "location": "/autogui.py:122-152"
    },
    "57": {
        "file_id": 7,
        "content": "This code handles USB HID events for keyboard inputs. It ensures at least 20ms between events and maps specific event data to corresponding keys or key combinations, such as \"winleft\" for the Windows key, \"capslock\", and various arrow/directional keys.",
        "type": "comment"
    },
    "58": {
        "file_id": 7,
        "content": "\t\tkey = \"shiftright\"\n\t\t\t\telif (eventdata1==38 and eventdata2==1):\n\t\t\t\t\tkey = \"up\"\n\t\t\t\telif (eventdata1==34 and eventdata2==1):\n\t\t\t\t\tkey = \"pgdn\"\n\t\t\t\telif (eventdata1==33 and eventdata2==1):\n\t\t\t\t\tkey = \"pgup\"\n\t\t\t\telif (eventdata1==8 and eventdata2==0):\n\t\t\t\t\tkey = \"backspace\"\n\t\t\t\telif (eventdata1==44 and eventdata2==1):\n\t\t\t\t\tkey = \"printscreen\"\n\t\t\t\telif (eventdata1==46 and eventdata2==1):\n\t\t\t\t\tkey = \"delete\"\n\t\t\t\telif (eventdata1==27 and eventdata2==0):\n\t\t\t\t\tkey = \"esc\"\n\t\t\t\telif (eventdata1==13 and eventdata2==0):\n\t\t\t\t\tkey = \"enter\"\n\t\t\t\telif (eventdata1==112 and eventdata2==0):\n\t\t\t\t\tkey = \"f1\"\n\t\t\t\telif (eventdata1==113 and eventdata2==0):\n\t\t\t\t\tkey = \"f2\"\n\t\t\t\telif (eventdata1==114 and eventdata2==0):\n\t\t\t\t\tkey = \"f3\"\n\t\t\t\telif (eventdata1==115 and eventdata2==0):\n\t\t\t\t\tkey = \"f4\"\n\t\t\t\telif (eventdata1==116 and eventdata2==0):\n\t\t\t\t\tkey = \"f5\"\n\t\t\t\telif (eventdata1==117 and eventdata2==0):\n\t\t\t\t\tkey = \"f6\"\n\t\t\t\telif (eventdata1==118 and eventdata2==0):\n\t\t\t\t\tkey = \"f7\"\n\t\t\t\telif (eventdata1==119 and eventdata2==0):\n\t\t\t\t\tkey = \"f8\"\n\t",
        "type": "code",
        "location": "/autogui.py:152-185"
    },
    "59": {
        "file_id": 7,
        "content": "This code is mapping different keyboard event combinations to their corresponding keys.",
        "type": "comment"
    },
    "60": {
        "file_id": 7,
        "content": "\t\t\telif (eventdata1==120 and eventdata2==0):\n\t\t\t\t\tkey = \"f9\"\n\t\t\t\telif (eventdata1==121 and eventdata2==0):\n\t\t\t\t\tkey = \"f10\"\n\t\t\t\telif (eventdata1==122 and eventdata2==0):\n\t\t\t\t\tkey = \"f11\"\n\t\t\t\telif (eventdata1==123 and eventdata2==0):\n\t\t\t\t\tkey = \"f12\"\n\t\t\t\telse:\n\t\t\t\t\tprint(\"Skipping unknown keycode: \" + str(eventdata1))\n\t\t\t\t\tkey = False\n\t\t\t\tif (eventsubtype==256 or eventsubtype==260): # I think 260 is a \"virtual keystroke\"\n\t\t\t\t\tif (key!=False):\n\t\t\t\t\t\tpyautogui.keyDown(key)\n\t\t\t\telif (eventsubtype==257):\n\t\t\t\t\tif (key!=False):\n\t\t\t\t\t\tpyautogui.keyUp(key)\n\t\t\t\telse:\n\t\t\t\t\tprint(\"Bad keyboard subtype!\")\n\t\t\t\t\tsys.exit(1)\n\t\t\t\tlasttime=eventtime\n\t\t\telif (eventtype==2):\n\t\t\t\ttime.sleep(max((eventtime-lasttime)/1000,0.02)) # At least 20ms between everything\n\t\t\t\tif (eventsubtype==513):\n\t\t\t\t\tpyautogui.mouseDown(x=eventdata1, y=eventdata2, button='left')\n\t\t\t\telif (eventsubtype==514):\n\t\t\t\t\tpyautogui.mouseUp(x=eventdata1, y=eventdata2, button='left')\n\t\t\t\telse:\n\t\t\t\t\tprint(\"Bad mouse subtype!\")\n\t\t\t\t\tsys.exit(1)\n\t\t\t\tlasttime=eventtime\n\t\t\tel",
        "type": "code",
        "location": "/autogui.py:185-220"
    },
    "61": {
        "file_id": 7,
        "content": "This code is part of an autogui module and appears to be processing keyboard and mouse events from a device. If the eventdata matches specific keycodes, it assigns corresponding keys (\"f9\"-\"f12\") to the variable \"key\". The code then checks if it's a virtual keystroke (eventsubtype 256 or 260) and triggers either pyautogui.keyDown() or pyautogui.keyUp() function accordingly. If the event is related to mouse movement, it uses pyautogui.mouseDown() or pyautogui.mouseUp() depending on the eventsubtype. It ensures there's at least a 20ms delay between events and handles unknown subtypes by exiting the program.",
        "type": "comment"
    },
    "62": {
        "file_id": 7,
        "content": "if (eventtype==0 and eventsubtype==1):\n\t\t\t\tprint(\"Done.\")\n\t\t\t\tsys.exit(0)\n\t\t\telse:\n\t\t\t\tprint(\"Bad source major type!\")\n\t\t\t\tsys.exit(1)\n\tprint(\"Done playing\")\n\tprint('\\a')\ndef main():\n\tusage = \"usage: %prog [options]\"\n\tparser = OptionParser(usage=usage)\n\tparser.add_option(\"-r\", \"--record\", action=\"store_true\", dest=\"do_record\", default=False, help=\"record a session of input\")\n\tparser.add_option(\"-p\", \"--play\", action=\"store_true\", dest=\"do_play\", default=False, help=\"play a session of input\")\n\t(options, args) = parser.parse_args()\n\tif (options.do_record==False and options.do_play==False):\n\t\tparser.print_help()\n\t\tsys.exit(0)\n\tif (options.do_record==True):\n\t\trecord()\n\tif (options.do_play==True):\n\t\tplay()\nif __name__ == \"__main__\":\n\tmain()\n'''\nPLAY AREA\nw=win32gui\ntitle=w.GetWindowText(w.GetForegroundWindow())\nim = None\ndef capture():\n\tglobal im\n\t#pyautogui.click(1200, 500)\n\t#pyautogui.typewrite('About to close window!')\n\t#time.sleep(2)\n\t#pyautogui.hotkey('alt', 'f4')\n\t#pyautogui.screenshot()\n\tposx, posy = pyautogui.positio",
        "type": "code",
        "location": "/autogui.py:220-259"
    },
    "63": {
        "file_id": 7,
        "content": "This code is part of a Python script for an auto-GUI (graphical user interface) tool. It allows the user to record input and playback sessions of input. The script uses the \"win32gui\" module, which provides GUI window handling functions.\n\nThe first part of the code checks if the command line arguments are correct and then proceeds with either recording or playing input sessions. If no action is specified, it displays help information and exits.\n\nIn the PLAY AREA section, there is a function called \"capture\" which captures a screenshot when a window with a specific title is active. However, the code seems incomplete as it does not include the necessary imports for the functions used within the code.",
        "type": "comment"
    },
    "64": {
        "file_id": 7,
        "content": "n()\n\tprint(str(posx) + \",\" + str(posy))\n\tim = pyautogui.screenshot('img.png',region=(posx-20,posy-20,40,40))\ndef replay():\n\tglobal im\n\tloc = pyautogui.locateOnScreen(im)\n\tlocx, locy = pyautogui.center(loc)\n\tpyautogui.click(locx, locy)\n#capture()\n#replay()\ndef post_keys(hwnd, i):\n\twin32api.SendMessage(hwnd, win32con.WM_KEYDOWN, i, 0)\n\twin32api.SendMessage(hwnd, win32con.WM_KEYUP, i, 0)\n'''",
        "type": "code",
        "location": "/autogui.py:259-272"
    },
    "65": {
        "file_id": 7,
        "content": "The code captures a screenshot of the current window and searches for the image within it. If found, it clicks on the location. The `post_keys()` function simulates key down and key up events.",
        "type": "comment"
    },
    "66": {
        "file_id": 8,
        "content": "/basic_interactive_program_emulation_and_image_with_docker_support/Dockerfile",
        "type": "filepath"
    },
    "67": {
        "file_id": 8,
        "content": "Installs Docker.io from Alpine Linux package manager (APT).",
        "type": "summary"
    },
    "68": {
        "file_id": 8,
        "content": "# just install 'docker.io' from apt\n# remember to use sudo.\n# no official support on i386 now!\nFROM alpine:3.7",
        "type": "code",
        "location": "/basic_interactive_program_emulation_and_image_with_docker_support/Dockerfile:1-4"
    },
    "69": {
        "file_id": 8,
        "content": "Installs Docker.io from Alpine Linux package manager (APT).",
        "type": "comment"
    },
    "70": {
        "file_id": 9,
        "content": "/basic_interactive_program_emulation_and_image_with_docker_support/README.md",
        "type": "filepath"
    },
    "71": {
        "file_id": 9,
        "content": "This code provides instructions on how to train and use a bot for various tasks. It emphasizes the importance of allowing the bot to explore and learn, as meaning will arise from groups and communications.",
        "type": "summary"
    },
    "72": {
        "file_id": 9,
        "content": "as long as you know how to train the bot, you are fine.\nfirst, the coordination training. you may want thee bot to track and click specific location. \nnext, the typing training. you create a dataset of typing against your random typing program.\nyou may also illustrate the action of browsing website, downloading software, playing games, coding and more.\nnevermind. performing actions is critical to the bot, since that is the only way to resolve repetition, do reproduction and become autonomous.\nyou can always let the bot to do (relatively) meaningless things like random clicking. and it always works. meaning will arise from groups and communications.\nlet the bot to explore and learn.",
        "type": "code",
        "location": "/basic_interactive_program_emulation_and_image_with_docker_support/README.md:1-13"
    },
    "73": {
        "file_id": 9,
        "content": "This code provides instructions on how to train and use a bot for various tasks. It emphasizes the importance of allowing the bot to explore and learn, as meaning will arise from groups and communications.",
        "type": "comment"
    },
    "74": {
        "file_id": 10,
        "content": "/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py",
        "type": "filepath"
    },
    "75": {
        "file_id": 10,
        "content": "The code is a Python script for Docker emulation, providing functions to manage containers and an interactive program. It also includes exception handling with predefined safe types and logging functionality.",
        "type": "summary"
    },
    "76": {
        "file_id": 10,
        "content": "# this will freeze the terminal. what the heck is going wrong?\n# maybe we need to profile this program.\n# you should wait longer while doing init check.\n# maybe you can do some system responsiveness check.\n# check if the system is performing as quick as it should.\nimport gc\n# import getpass\n# TODO: container & process profiler\nimport os\nimport sys\nimport traceback\nimport shutil\nimport easyprocess\nimport elevate\n# timeout this function.\n# from functools import partial\nimport func_timeout\n# import docker  # pip3 install docker\nimport progressbar\nfrom naive_actor import NaiveActor\nfrom vocabulary import AsciiVocab\nREQUIRED_BINARIES = [\"docker\"]\nfor name in REQUIRED_BINARIES:\n    assert shutil.which(\n        name\n    ), f\"{name} is not available in PATH.\"  # you can specify absolute path here\nLEGACY_DOCKER = False\nif sys.maxsize < 2**32:\n    print(\"Your system is 32bit or lower.\")\n    print(\"Assume using legacy docker.\")\n    LEGACY_DOCKER = True\n    if os.name == \"posix\":\n        # check if is sudo\n        print(\"*nix sys",
        "type": "code",
        "location": "/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py:1-46"
    },
    "77": {
        "file_id": 10,
        "content": "This code appears to be a Python script for emulating an interactive program and working with Docker containers. It imports several modules, performs system checks, and asserts that required binary files like \"docker\" are available in the PATH. The script also checks if the system is running 32-bit or lower and assumes legacy docker support in such cases. It mentions a TODO for profiling the program and includes comments suggesting potential improvements.",
        "type": "comment"
    },
    "78": {
        "file_id": 10,
        "content": "tem detected.\")\n        # you don't need to do root checking\n        # username = os.environ.get(\"USER\", os.environ.get(\"USERNAME\", \"unknown\"))\n        # username = getpass.getuser()\n        # # ref: https://www.geeksforgeeks.org/how-to-get-the-current-username-in-python/\n        # is_sudo = username == \"root\"\n        # if not is_sudo:\n        #     msg = f\"You ({username}) are not sudo. Docker may malfunction.\"\n        #     # raise Exception(msg)\n        #     print(msg)\n        #     print(\"Elevating now.\")\n        elevate.elevate(graphical=False)\nclass _AutoSeparatedString(str):\n    __slots__ = [\"sep\"]\n    # def __init__(self, *args, **kwargs):\n    #     self.sep = kwargs.pop('sep')\n    def __add__(self, other):\n        s_self, s_other = str(self), str(other)\n        val = s_self.__add__(self.sep + s_other)\n        return self.__class__(val)\n    def __radd__(self, other):\n        s_self, s_other = str(self), str(other)\n        val = s_other.__add__(self.sep + s_self)\n        return self.__class__(val)\ncla",
        "type": "code",
        "location": "/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py:46-76"
    },
    "79": {
        "file_id": 10,
        "content": "Code checks if the current user is root and prints a message if not. If not root, it elevates privileges using the \"elevate\" function. It also defines an auto-separated string class for adding strings separated by a specific delimiter.",
        "type": "comment"
    },
    "80": {
        "file_id": 10,
        "content": "ss AutoSpacedString(_AutoSeparatedString):\n    sep = \" \"\n    # def __init__(self, *args, **kwargs):\n    #     kwargs['sep'] = ' '\n    #     super().__init__(*args, **kwargs)\n# a = AutoSpacedString('a')\n# # a = AutoSeparatedString('a')\n# print(a)\n# print(a+a)\n# print(a+a+a)\n# you had better adopt async/await syntax.\n# import time\nfrom log_common import *\ndef docker_cmd(*args):\n    return \" \".join([\"docker\", *args])\ndef docker_container_cmd(*args):\n    return docker_cmd(\"container\", *args)\nif LEGACY_DOCKER:\n    LIST_CONTAINER = docker_cmd(\"ps -a\")\n    KILL_CONTAINER = docker_cmd(\"rm -f\")\n    # KILL_CONTAINER = docker_cmd(\"kill\")\nelse:\n    LIST_CONTAINER = docker_container_cmd(\"ls\")\n    KILL_CONTAINER = docker_container_cmd(\"kill\")\n# this error has been recorded.\n# we cannot just leave it like this.\n# we need some watchdog thread.\n# DOCKER CLI ON MACOS IS NOT RESPONSIVE!\n# WHAT TO DO WITH THIS?\n# DO NOT FOOL ME INTO BUYING E5-2650V2 OR REGECC RAMS!\n# suggestion: use ssh-based interaction with containers.\n# suggestion: ",
        "type": "code",
        "location": "/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py:76-116"
    },
    "81": {
        "file_id": 10,
        "content": "This code seems to define a class called AutoSpacedString that separates strings by space. It also defines functions for interacting with Docker, such as listing and killing containers. However, there are warnings about potential issues with the Docker CLI on MacOS and suggestions to use SSH-based interaction with containers instead.",
        "type": "comment"
    },
    "82": {
        "file_id": 10,
        "content": "restart docker service on macos.\n# TODO: make unittests for failsafe protocols and watchdogs\n# TODO: check docker binary if it is in PATH\n# TODO: count failures of microtasks like this method and create remedy routines which trying to repair and continue execution\nfrom rerun_docker_daemon import restart_and_verify\ndef killAndPruneAllContainers(trial_count=2):\n    fail_counter = 0\n    for i in range(trial_count):\n        print(f\"try to kill docker containers ({i+1} time(s))\")\n        try:\n            success = _killAndPruneAllContainers()\n            assert success, \"Failed to execute docker kill and prune\"\n            print(\"successfully killed all containers\")\n            return success\n        except:\n            fail_counter += 1\n    if fail_counter >= trial_count:  # in fact, it can only equal to the count.\n        print(\"relaunching docker\")\n        restart_and_verify()\n        return killAndPruneAllContainers(trial_count)\n@func_timeout.func_set_timeout(timeout=10)\ndef _killAndPruneAllContainers():  #",
        "type": "code",
        "location": "/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py:116-142"
    },
    "83": {
        "file_id": 10,
        "content": "This code attempts to kill and prune all Docker containers on macOS. If it fails, it retries twice before relaunching the Docker service.",
        "type": "comment"
    },
    "84": {
        "file_id": 10,
        "content": " not working for legacy docker.\n    success = False\n    proc = easyprocess.EasyProcess(LIST_CONTAINER).call(timeout=4)\n    if proc.return_code == 0:\n        success = True  # usually this is the challange.\n    # proc = easyprocess.EasyProcess(\"docker container ls -a\").call()\n    if proc.stdout:\n        lines = proc.stdout.split(\"\\n\")[1:]\n        container_ids = [line.split(\" \")[0] for line in lines]\n        for cid in progressbar.progressbar(container_ids):\n            cmd = f\"{KILL_CONTAINER} {cid}\"\n            try:\n                func_timeout.func_timeout(3, os.system, args=(cmd,))\n            except func_timeout.FunctionTimedOut:\n                print(\n                    f'timeout while killing container \"{cid}\".\\nmaybe the container is not running.'\n                )\n            # os.system(f\"docker container kill -s SIGKILL {cid}\")\n        if not LEGACY_DOCKER:\n            os.system(\"docker container prune -f\")\n    return success\n# BUG: deprecated! may not connect to docker socket on windows.\n# @part",
        "type": "code",
        "location": "/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py:142-166"
    },
    "85": {
        "file_id": 10,
        "content": "This code is used to clean up stopped Docker containers. It checks for running containers and attempts to stop them using either `os.system` or `docker container kill -s SIGKILL`. If a container takes too long to shut down, it will print a warning message indicating that the container might not be running. Additionally, if the LEGACY_DOCKER flag is False (non-legacy Docker), it will forcefully remove all stopped containers using `docker container prune -f`. However, this code is deprecated and may have compatibility issues with Windows systems as it doesn't connect to the Docker socket properly.",
        "type": "comment"
    },
    "86": {
        "file_id": 10,
        "content": "ial(func_timeout.func_timeout, 10)\n# def killAndPruneAllContainers():\n#     # def stopAndPruneAllContainers():\n#     all_containers = client.containers.list(all=True)\n#     print(\"killing running containers...\")\n#     for container in progressbar.progressbar(all_containers):\n#         try:\n#             container.kill()\n#         except:\n#             log_and_print_unknown_exception()\n#             # container not running. can be pruned.\n#             # usually.\n#         # container.stop()\n#     print(\"pruning stopped containers...\")\n#     client.containers.prune()\nclass AlpineActor(NaiveActor):\n    def __init__(self):\n        killAndPruneAllContainers()\n        super().__init__(\"docker run --rm -it alpine:3.7\")\n        # TODO: detect if the container is down by heartbeat-like mechanism\n        # TODO: retrieve created container id\n        # TODO: detect if we have the real container instead of fake container (do we have a real container session? or just dummy session with no docker behind), using pexpect",
        "type": "code",
        "location": "/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py:166-190"
    },
    "87": {
        "file_id": 10,
        "content": "The code defines a class `AlpineActor` that extends `NaiveActor`. It initializes the actor by calling `killAndPruneAllContainers()`, which stops and prunes all Docker containers, and then sets up an Alpine container using the command `\"docker run --rm -it alpine:3.7\"`. The class also contains TODOs for detecting if the container is down, retrieving the container ID, and checking if a real container session exists.",
        "type": "comment"
    },
    "88": {
        "file_id": 10,
        "content": "'s default capability.\n    def __del__(self):\n        killAndPruneAllContainers()\n        super().__del__()\n    def _init_check(self):\n        print(\"checking container\")\n        steps = [\n            lambda: self.process.expect(\"/ # \"),\n            lambda: self.process.write(f\"whoami{os.linesep}\"),\n            lambda: self.process.expect(\"root\"),\n        ]\n        for step in progressbar.progressbar(steps):\n            step()\n    @NaiveActor.timeit\n    def loop(self):\n        _ = self.read()\n        write_content = AsciiVocab.generate()\n        write_content = write_content.encode()\n        self.write(write_content)\n        return True\nSAFE_EXCEPTION_TYPES = [OSError]  # are you sure? this can be many. not just io errors\n# SAFE_EXCEPTION_TYPES = []\nif os.name == \"nt\":\n    import wexpect\n    SAFE_EXCEPTION_TYPES.append(wexpect.wexpect_util.EOF)  # you can try to ignore this.\n# from typing import Generator\ndef run_actor_forever(actor_class):\n    # killAndPruneAllContainers()\n    if hasattr(actor_class, \"__next__\")",
        "type": "code",
        "location": "/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py:190-226"
    },
    "89": {
        "file_id": 10,
        "content": "This code defines a class representing an actor in an interactive program. It includes methods to check the container state, loop over reading and writing content, and safely handle certain exceptions. The function run_actor_forever can be used to run the actor's loop forever.\n\nThe class has a destructor (__del__) that kills and prunes all containers when the object is deleted. It also has an _init_check method that checks the container's state, expecting a prompt, and ensuring that the user running inside the container is root. The loop method repeatedly reads content from the actor and writes new content.\n\nThe SAFE_EXCEPTION_TYPES variable lists specific types of exceptions that should be considered safe and not interrupt the program's execution. There are comments suggesting that OSError might not be the only type to include, and that for Windows systems, weexpect.wexpect_util.EOF should also be included in SAFE_EXCEPTION_TYPES.\n\nThe run_actor_forever function can be used to run the actor's loop forever, continuously interacting with the container. However, there is a comment suggesting that this function might not be used or needed anymore.",
        "type": "comment"
    },
    "90": {
        "file_id": 10,
        "content": ":\n        # if isinstance(actor_class, Generator):\n        make_actor = lambda: next(actor_class)\n    else:\n        make_actor = lambda: actor_class()\n    # breakpoint()\n    # we just cannot use such long timeout limit.\n    # need watchdog alternative.\n    @func_timeout.func_set_timeout(timeout=131)\n    def internal_loop():\n        ret = None\n        # actor = actor_class()\n        actor = make_actor()\n        @func_timeout.func_set_timeout(timeout=100)\n        def run_actor():\n            try:\n                actor.run()\n            except KeyboardInterrupt:\n                print(\"exit on user demand\")\n                return \"INTERRUPTED\"\n            except Exception as e:\n                safe = check_if_is_safe_exception(e)\n        ret = run_actor()\n        del actor\n        if ret is None:\n            print()\n            print(\"restarting actor\")\n        gc.collect()\n        return ret\n    while True:\n        ret = None\n        try:\n            ret = internal_loop()\n            if ret == \"INTERRUPTED\":\n             ",
        "type": "code",
        "location": "/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py:226-264"
    },
    "91": {
        "file_id": 10,
        "content": "This code defines a function `internal_loop` that runs an actor. It creates an instance of the given `actor_class`, sets timeouts for the inner functions, and executes it within a while loop. If interrupted or if an exception occurs during execution, it will return \"INTERRUPTED\" or print \"restarting actor\", respectively.",
        "type": "comment"
    },
    "92": {
        "file_id": 10,
        "content": "   break\n        except Exception as e:\n            safe = check_if_is_safe_exception(e)\ndef check_if_is_safe_exception(e):\n    safe = False\n    # for exc_type in SAFE_EXCEPTION_TYPES:\n    #     if isinstance(e, exc_type):\n    if type(e) in SAFE_EXCEPTION_TYPES:\n        safe = True\n    if safe:\n        traceback.print_exc()\n        print(\"safe exception:\", e)\n    else:\n        log_and_print_unknown_exception()\n    return safe\nif __name__ == \"__main__\":\n    run_actor_forever(AlpineActor)\n#     import cProfile\n#     fpath = \"alpine_actor.profile\"\n#     # # print(\"running\")\n#     prof = cProfile.run(\"AlpineActor()\", filename=fpath)\n#     # print(\"hello world\")",
        "type": "code",
        "location": "/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py:264-289"
    },
    "93": {
        "file_id": 10,
        "content": "The code is part of a larger function that handles exceptions during program execution. It checks if the exception thrown belongs to a predefined list of safe exception types, and if so, it prints the traceback and message before continuing. If the exception is not on the list, it calls log_and_print_unknown_exception().",
        "type": "comment"
    },
    "94": {
        "file_id": 11,
        "content": "/basic_interactive_program_emulation_and_image_with_docker_support/alpine_bytes_actor.py",
        "type": "filepath"
    },
    "95": {
        "file_id": 11,
        "content": "This code defines an AlpineBytesActor class that inherits from BytesActor and AlpineActor. It has a loop method that reads, generates new content using BytesVocab, and writes it. The main function runs the actor forever.",
        "type": "summary"
    },
    "96": {
        "file_id": 11,
        "content": "from alpine_actor import AlpineActor, run_actor_forever\nfrom bytes_actor import BytesActor\nfrom vocabulary import BytesVocab\nclass AlpineBytesActor(BytesActor, AlpineActor):\n    @AlpineActor.timeit\n    def loop(self):\n        _ = self.read()\n        write_content = BytesVocab.generate()\n        self.write(write_content)\n        return True\nif __name__ == \"__main__\":\n    run_actor_forever(AlpineBytesActor)",
        "type": "code",
        "location": "/basic_interactive_program_emulation_and_image_with_docker_support/alpine_bytes_actor.py:1-16"
    },
    "97": {
        "file_id": 11,
        "content": "This code defines an AlpineBytesActor class that inherits from BytesActor and AlpineActor. It has a loop method that reads, generates new content using BytesVocab, and writes it. The main function runs the actor forever.",
        "type": "comment"
    },
    "98": {
        "file_id": 12,
        "content": "/basic_interactive_program_emulation_and_image_with_docker_support/beat_common.py",
        "type": "filepath"
    },
    "99": {
        "file_id": 12,
        "content": "The code defines a decorator function for caching with expiration time, includes functions for caching, querying server info, and handling GET requests with timeout management and exception handling. In case of fatal errors or unknown exceptions, it attempts to kill the process.",
        "type": "summary"
    }
}