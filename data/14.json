{
    "1400": {
        "file_id": 182,
        "content": "/sync_utils.sh",
        "type": "filepath"
    },
    "1401": {
        "file_id": 182,
        "content": "Copying necessary files and updating file names.",
        "type": "summary"
    },
    "1402": {
        "file_id": 182,
        "content": "# cp ../jubilant-adventure2/microgrid_base/log_utils.py .\n# cp ../jubilant-adventure2/microgrid_base/jinja_utils.py .\n# sed -i \"s/microgrid/agi_computer_control/g\" log_utils.py\ncp $2$1 .\n# echo $1\nif [[ \"$1\" == \"log_utils.py\" ]]; then\n    sed -i \"s/microgrid/agi_computer_control/g\" $1\nfi",
        "type": "code",
        "location": "/sync_utils.sh:1-9"
    },
    "1403": {
        "file_id": 182,
        "content": "Copying necessary files and updating file names.",
        "type": "comment"
    },
    "1404": {
        "file_id": 183,
        "content": "/terminal_test_tk.py",
        "type": "filepath"
    },
    "1405": {
        "file_id": 183,
        "content": "Creating a Tkinter window with a terminal widget using tkterminal package.",
        "type": "summary"
    },
    "1406": {
        "file_id": 183,
        "content": "import tkinter as tk\nfrom tkterminal import Terminal\nroot = tk.Tk()\nterminal = Terminal(pady=5, padx=5)\nterminal.shell = True\nterminal.pack(expand=True, fill=\"both\")\nroot.mainloop()",
        "type": "code",
        "location": "/terminal_test_tk.py:1-8"
    },
    "1407": {
        "file_id": 183,
        "content": "Creating a Tkinter window with a terminal widget using tkterminal package.",
        "type": "comment"
    },
    "1408": {
        "file_id": 184,
        "content": "/test/run_test.sh",
        "type": "filepath"
    },
    "1409": {
        "file_id": 184,
        "content": "Change directory to parent folder and run pytest with various options to execute test_project.py.",
        "type": "summary"
    },
    "1410": {
        "file_id": 184,
        "content": "# cd ..\n# pytest --lf --lfnf=all --capture=tee-sys test_project.py\npytest --lf --lfnf=all --capture=tee-sys --log-level=DEBUG test_project.py\n# no much difference.\n# env BETTER_EXCEPTIONS=1 pytest --lf --lfnf=all --capture=tee-sys --log-level=DEBUG test_project.py\n# pytest --lf --lfnf=all test_project.py\n# pytest --lf --lfnf=all --capture=tee-sys test_project.py",
        "type": "code",
        "location": "/test/run_test.sh:1-10"
    },
    "1411": {
        "file_id": 184,
        "content": "Change directory to parent folder and run pytest with various options to execute test_project.py.",
        "type": "comment"
    },
    "1412": {
        "file_id": 185,
        "content": "/test/test_abstract_impl.py",
        "type": "filepath"
    },
    "1413": {
        "file_id": 185,
        "content": "This code defines an abstract base class (ABC) with a method and an implementation class that overrides the method. It also shows how to get an error when trying to instantiate an abstract class or non-implementing class.",
        "type": "summary"
    },
    "1414": {
        "file_id": 185,
        "content": "from abc import ABC, abstractmethod\nclass abs_class(ABC):\n    def method(self):\n        \"doc here\"\n        return self._method_impl()\n    @abstractmethod\n    def _method_impl(self):\n        ...\nclass impl_class(abs_class):\n    def _method_impl(self):\n        return 1\nclass impl_class2(abs_class):\n    def non_relevant(self):\n        ...\nprint(impl_class().method())\n# print(impl_class2()) # error\n# print(abs_class()) # error",
        "type": "code",
        "location": "/test/test_abstract_impl.py:1-26"
    },
    "1415": {
        "file_id": 185,
        "content": "This code defines an abstract base class (ABC) with a method and an implementation class that overrides the method. It also shows how to get an error when trying to instantiate an abstract class or non-implementing class.",
        "type": "comment"
    },
    "1416": {
        "file_id": 186,
        "content": "/test/test_project.py",
        "type": "filepath"
    },
    "1417": {
        "file_id": 186,
        "content": "The code imports necessary modules, sets up logging and functions for model training and data processing. It includes strategies from hypothesis library, tests data fetching and loading models, evaluates CustomModel using Adam optimizer and SequentialTrainingQueue, and converts tensor to ConsciousFlow object for real-world application.",
        "type": "summary"
    },
    "1418": {
        "file_id": 186,
        "content": "# use \"--log-level\" in pytest.\n# with this limited model structure, you may not find it \"evolving\".\n# you must let the AI design itself, evolve on its own.\n# shall you use pydantic v1 (>=1.10) or be incompatible with hypothesis.\n# ref: https://github.com/explosion/spaCy/issues/12659\n# lower the version of typing_extensions\nimport sys\nimport numpy as np\nsys.path.append(\"../\")\nfrom log_utils import logger_print\nimport torch\nfrom conscious_struct import (\n    trainModelWithDataBasePath,\n    Trainer,\n    SequentialTrainingQueue,\n    CustomModel,\n    ConsciousFlow,  # consists of `ConsciousBlock`\n    ConsciousBlock,\n    ConsciousStream,  # newly created wrapper!\n    HIDAction,\n    ConsciousBase,\n    KeyPress, KeyRelease, MouseMove, MouseScroll, MouseClick\n)\nfrom recording_train_parse import getTrainingData\nimport datetime\nimport pytest\nimport os\nfrom pathlib import Path\nfrom torchvision.models import VisionTransformer\nfrom hypothesis import given, settings\nfrom hypothesis.strategies import integers\nimport stopit\nimport ei",
        "type": "code",
        "location": "/test/test_project.py:1-37"
    },
    "1419": {
        "file_id": 186,
        "content": "The code is importing various modules and classes from different files. It uses \"--log-level\" in pytest, references a link for potential compatibility issues, imports necessary libraries like torch and numpy, appends the path of a specific file to the system path, and imports functions and classes for model training and data processing. Finally, it imports strategies and settings from hypothesis library and stops the execution if needed using stopit.",
        "type": "comment"
    },
    "1420": {
        "file_id": 186,
        "content": "nops\n# import logging\n# import log_utils\n# it is been commented out.\n# from typing import Generator, Union, AsyncGenerator\n# try:\n#     from typing import AwaitableGenerator\n# except:\n#     from typing_extensions import AwaitableGenerator\n# may log to other places.\n# infinite append.\n# from logging import StreamHandler\n# stdout_handler = StreamHandler(sys.stdout)\n# logging.basicConfig(\n#     # filename=filename,\n#     level=logging.getLogger().getEffectiveLevel(),\n#     # stream=sys.stderr,\n#     force=True,\n#     handlers=[myHandler, stdout_handler],\n# )\n# logging.basicConfig(level=logging.DEBUG, stream=sys.stdout, force=True)\n# logging.critical(\"\")\ncurrent_time = datetime.datetime.now().isoformat()\nlogger_print(f\"logging starts: {current_time}\".center(100, \"=\"))\n# logging.critical(\"\")\n# TODO: modify function at source code level, not here!\n# def auto_teardown(func):\n#     def inner_func(*args, **kwargs):\n#         val = func(*args, **kwargs)\n#         if not isinstance(val, Union[Generator, AsyncGenerator, Await",
        "type": "code",
        "location": "/test/test_project.py:37-78"
    },
    "1421": {
        "file_id": 186,
        "content": "This code appears to be a Python module that sets up logging for the test project. It imports necessary modules, configures the logging level and handlers, and starts logging with a timestamp and header. There is also a placeholder for a function called \"auto_teardown,\" but it does not appear to be implemented or used in this code snippet.",
        "type": "comment"
    },
    "1422": {
        "file_id": 186,
        "content": "ableGenerator]):\n#             yield val\n#             del val\n#         return val\n#     return inner_func\n@pytest.fixture(scope=\"session\")\ndef basePath():\n    return \"../recordings/2023-06-02T07_59_45.711256/\"\ndef test_get_training_data(basePath: str):\n    for trainingDataFrame in getTrainingData(basePath):\n        logger_print(\"training data frame:\", trainingDataFrame)\n# test fetching training data.\ndef test_fetching_training_data(basePath: str):\n    from conscious_struct import trainModelWithDataBasePath, TestEnqueue\n    myQueue = TestEnqueue()\n    # fake sequentialqueue.\n    trainModelWithDataBasePath(basePath, myQueue)\n@pytest.fixture(scope=\"session\")\ndef vit_model_path():\n    path = Path(\n        os.path.abspath(\n            relpath := \"../../../model_cache/vit_b_16-c867db91.pth\")\n    )\n    if not path.exists():\n        raise Exception(\n            f\"Current directory: {os.curdir}\\nModel weight does not exist: {path}\"\n        )\n    # return \"/Volumes/Toshiba XG3/model_cache/vit_b_16-c867db91.pth\"\n    retur",
        "type": "code",
        "location": "/test/test_project.py:78-117"
    },
    "1423": {
        "file_id": 186,
        "content": "Code tests fetching training data and loading model path.\n\nThis code contains two test functions, `test_get_training_data` and `test_fetching_training_data`, which are used to verify the functionality of fetching training data and loading the model path, respectively. \n\nThe `test_get_training_data` function iterates over each training DataFrame obtained from the `getTrainingData` function and prints out a log message for each one. This is intended to test the correctness and completeness of the training DataFrames returned by `getTrainingData`.\n\nThe `test_fetching_training_data` function imports two other functions, `trainModelWithDataBasePath` and `TestEnqueue`, from the `conscious_struct` module. It then creates an instance of a fake sequential queue called `myQueue` using the `TestEnqueue` class. \n\nThe function calls the `trainModelWithDataBasePath` function, passing in the `basePath` and the `myQueue` object as arguments. This is to test the functionality of training a model with data from a specific base path and a fake queue. If the model weight file does not exist at the specified path, an exception will be raised.\n\nThe code also defines a fixture called `basePath` that returns a string representing the base path for tests to use. It also has another fixture called `vit_model_path` which returns the path to the pre-trained model weight file (`vit_b_16-c867db91.pth`). If the file does not exist, an exception will be raised.",
        "type": "comment"
    },
    "1424": {
        "file_id": 186,
        "content": "n path\n@pytest.fixture(scope=\"session\")\ndef vit_model(vit_model_path: str):\n    import torchvision\n    # code from OA bot\n    # return torchvision.models.vit_b_16(pretrained=True)\n    vmodel = torchvision.models.vit_b_16()\n    # breakpoint()\n    mStateDict = torch.load(vit_model_path)\n    vmodel.load_state_dict(mStateDict)\n    yield vmodel\n    del vmodel\n@pytest.fixture(scope=\"session\")\ndef model(vit_model: VisionTransformer):\n    model = CustomModel(vit_model)\n    yield model\n    del model\n# def pretrained_model_path():\n#     path = ...\n#     return path\n# @pytest.fixture(scope='session')\n# def model_pretrained(model:CustomModel,pretrained_model_path:str):\n#     model.load_state_dict(torch.load(pretrained_model_path))\n#     yield model\n#     del model\n# you don't need the model to be trained at all to act.\n@pytest.fixture(scope=\"session\")\ndef loss_fn():\n    from torch.nn import CrossEntropyLoss\n    loss = CrossEntropyLoss(reduction=\"mean\")\n    yield loss\n    del loss\n@pytest.fixture(scope=\"session\")\ndef optimizer(mod",
        "type": "code",
        "location": "/test/test_project.py:117-164"
    },
    "1425": {
        "file_id": 186,
        "content": "Code snippet is defining several fixtures for use in tests.\n\n1. `vit_model` fixture loads a pre-trained VisionTransformer model and yields it for testing.\n2. `model` fixture instantiates a custom model based on the preloaded VisionTransformer model and yields it.\n3. `loss_fn` fixture sets up a CrossEntropyLoss object and yields it.\n\nThese fixtures can be used to test various aspects of the model, loss function, and other components in tests.",
        "type": "comment"
    },
    "1426": {
        "file_id": 186,
        "content": "el: CustomModel):\n    from torch.optim import Adam\n    lr = 0.00001\n    opt = Adam(model.parameters(), lr=lr)\n    yield opt\n    del opt\n# from hypothesis import HealthCheck\n@given(random_seed=integers())\n# @settings(suppress_health_check=(HealthCheck.function_scoped_fixture,),max_examples = 10, deadline=None)\n@settings(deadline=None, max_examples=2)\ndef test_train_model_with_training_data(\n    model: CustomModel, loss_fn, optimizer, basePath: str, random_seed: int\n):\n    # TODO: annotate our code with \"nptyping\" & \"torchtyping\" | \"jaxtyping\"\n    # TODO: haskell? functional python?\n    # (variadic types) ref: https://peps.python.org/pep-0646/\n    # use sympy for symbolic checks?\n    context_length = 2\n    batch_size = 1\n    myTrainer = Trainer(model=model, loss_fn=loss_fn, optimizer=optimizer)\n    myQueue = SequentialTrainingQueue(\n        context_length=context_length, batch_size=batch_size, trainer=myTrainer\n    )\n    # TODO: allow timeout exception to be raised, disallow any other exceptions.\n    # you migh",
        "type": "code",
        "location": "/test/test_project.py:164-195"
    },
    "1427": {
        "file_id": 186,
        "content": "Code is defining a test function that trains a CustomModel with training data and uses an Adam optimizer. The test function takes in a model, loss function, optimizer, base path, and random seed as parameters. It creates a Trainer object with the given model, loss function, and optimizer. Then it creates a SequentialTrainingQueue object that passes data to the trainer for training. The timeout exception handling is not implemented yet.",
        "type": "comment"
    },
    "1428": {
        "file_id": 186,
        "content": "t want to shuffle its order, for testing.\n    with stopit.ThreadingTimeout(5):  # timeout exception suppressed!\n        trainModelWithDataBasePath(\n            basePath, myQueue, shuffle_for_test=True, random_seed=random_seed\n        )\n    logger_print(\"SESSION TIMEOUT NOW\".center(60, \"_\"))\n@pytest.mark.parametrize(\n    \"HIDActionObj\",\n    [\n        MouseClick(x=993, y=659, button=\"Button.left\", pressed=True),\n        MouseMove(x=10, y=20),\n        MouseScroll(x=10, y=10, dx=10, dy=-10),\n        KeyPress(key=\"\"\"'9'\"\"\"),\n        KeyRelease(key=\"\"\"'8'\"\"\"),\n    ],\n)\ndef test_eval_with_model(model: CustomModel, HIDActionObj):\n    model.eval()\n    # it is been observed by video recording script.\n    max_x, max_y = 1280, 768\n    HIDActionJson = HIDActionObj.to_list()\n    # HIDActionJsonList = [HIDActionObj.to_list() for HIDActionObj in HIDActionObjList]\n    actionData = HIDAction.from_action_json(\n        HIDActionJson, max_x=max_x, max_y=max_y\n    ).to_ndarray()\n    # actionDataList = [HIDAction.from_action_json(\n  ",
        "type": "code",
        "location": "/test/test_project.py:195-224"
    },
    "1429": {
        "file_id": 186,
        "content": "The code snippet is testing the evaluation of a model by performing various HID (Human Input Device) actions, such as mouse clicks, mouse moves, and key presses/releases. It also includes threading timeout to shuffle the order of actions for testing purposes.",
        "type": "comment"
    },
    "1430": {
        "file_id": 186,
        "content": "  #     HIDActionJson, max_x=max_x, max_y=max_y\n    # ).to_ndarray() for HIDActionJson in HIDActionJsonList]\n    randomImageData = np.random.random(\n        (ConsciousBase.image_channels, ConsciousBase.image_dim, ConsciousBase.image_dim)\n    )\n    # imageData = einops.pack(randomImageData, \"*\")  # just what shape shall this be?\n    imageData = einops.rearrange(randomImageData, \"c h w -> (c h w)\")\n    # actionConsciousBlocks = [ConsciousBlock(\n    #     data_type=\"HIDAction\", special_token=None, action_data=actionData\n    # ) for actionData in actionDataList]\n    actionConsciousBlock = ConsciousBlock(\n        data_type=\"HIDAction\", special_token=None, action_data=actionData\n    )\n    imageConsciousBlock = ConsciousBlock(\n        data_type=\"image\", special_token=None, image_data=imageData\n    )\n    # cs = ConsciousFlow(consciousBlocks=[*actionConsciousBlocks, imageConsciousBlock])\n    # cf = ConsciousFlow(consciousBlocks=[ # not here but inside.\n    #     actionConsciousBlock,\n    #     # imageConsciousBlo",
        "type": "code",
        "location": "/test/test_project.py:224-243"
    },
    "1431": {
        "file_id": 186,
        "content": "Creating random image data and ConsciousBlocks for a ConsciousFlow.",
        "type": "comment"
    },
    "1432": {
        "file_id": 186,
        "content": "ck,\n    #     ]\n    # )\n    cf = ConsciousFlow(\n        consciousBlocks=[actionConsciousBlock, imageConsciousBlock])\n    # must be 3d, not 2d.\n    # print(actionConsciousBlock.to_tensor().shape) # torch.Size([154639]) ~ d\n    # print(imageConsciousBlock.to_tensor().shape) # torch.Size([154639]) ~ d\n    # print(cf.to_tensor().shape) # torch.Size([2, 154639]) ~ s d\n    # breakpoint()\n    # result = model.forward(conscious_stream = cf.to_tensor()) # instead of this.\n    # we do this:\n    cs = ConsciousStream(consciousFlows=[cf])\n    result = model.forward(conscious_stream=cs.to_tensor())\n    # result = model.forward(conscious_stream=einops.pack([cf.to_tensor()], \"* s d\")) # b s d\n    # do not load any weight yet. just use its random state.\n    # do not execute anything in this test! just get the predicted things out.\n    logger_print(\"printing result\")\n    # with gradient! shall be shape of (b (batch size), d (data length))\n    logger_print(result)\n    logger_print('result shape:', result.shape)  # torch.Siz",
        "type": "code",
        "location": "/test/test_project.py:243-265"
    },
    "1433": {
        "file_id": 186,
        "content": "Creating ConsciousFlow objects for action and image, then creating a ConsciousStream with both conscious flows. Finally, forward pass of the model using the new conscious stream. Printing the result and its shape.",
        "type": "comment"
    },
    "1434": {
        "file_id": 186,
        "content": "e([1, 154639])\n    # now decode!\n    cf_result = ConsciousFlow.from_tensor(result.detach())\n    logger_print(\"decoded result:\", cf_result)\n    # consider running this stuff in real world.",
        "type": "code",
        "location": "/test/test_project.py:265-271"
    },
    "1435": {
        "file_id": 186,
        "content": "Converting tensor to ConsciousFlow object, storing in cf_result, and logging the result for potential real-world application.",
        "type": "comment"
    },
    "1436": {
        "file_id": 187,
        "content": "/test_calculated_type.py",
        "type": "filepath"
    },
    "1437": {
        "file_id": 187,
        "content": "Code explains the problem of determining types in libraries like PyTorch and NumPy, where different parameters create different types. The author proposes using Erg to solve this issue by allowing static type checking before execution. Help can be found through `help(torch.nn.Conv2d)`.",
        "type": "summary"
    },
    "1438": {
        "file_id": 187,
        "content": "# i wouldn't know if there is anything called \"calculated type\" in python \"typing\" module or erglang, but i do know some \"type\" details about numpy matrix multiplication and torch convolutional neural networks.\n# Calculated types or custom type hint and type checkers\n# There's been a long history of attempts on typechecking libraries like `pytorch` and `numpy`. One major issue is that passing different parameters to these constructors create different types (tensors with traits (matrix multiplication) and tensor functions). There's some relationship between definition of a convolutional network and what type of value (usually not a fixed type, but rather a set of types (infinite)) it can accept and return.\n# So I propose or want to know how we can let Erg to solve this long-standing problem, by letting the static typechecker to know the type of `torch.nn.Conv2d` and emit errors before execution? Help can be found by:\n# ```python\n# import torch\n# help(torch.nn.Conv2d)\n# ```",
        "type": "code",
        "location": "/test_calculated_type.py:1-12"
    },
    "1439": {
        "file_id": 187,
        "content": "Code explains the problem of determining types in libraries like PyTorch and NumPy, where different parameters create different types. The author proposes using Erg to solve this issue by allowing static type checking before execution. Help can be found through `help(torch.nn.Conv2d)`.",
        "type": "comment"
    },
    "1440": {
        "file_id": 188,
        "content": "/the_cage_dataset/README.md",
        "type": "filepath"
    },
    "1441": {
        "file_id": 188,
        "content": "The code describes a method to control a bot by confining it within a virtual or physical \"cage\", allowing only controlled input from the keyboard and mouse. It ensures synchronization of timestamps for video, audio, and actions across multiple machines using either NTP (Network Time Protocol) if online or Chrony if offline.",
        "type": "summary"
    },
    "1442": {
        "file_id": 188,
        "content": "To minimize side effects and increase controllability, we will put our fellow bot inside the cage (or pinned it down) and let it uses the keyboard and mouse inside, while looking at the screen.\nwe need to synchronize timestamps for video, audio and actions across different machines, using ntp against the same server if online, or using chrony if offline",
        "type": "code",
        "location": "/the_cage_dataset/README.md:1-3"
    },
    "1443": {
        "file_id": 188,
        "content": "The code describes a method to control a bot by confining it within a virtual or physical \"cage\", allowing only controlled input from the keyboard and mouse. It ensures synchronization of timestamps for video, audio, and actions across multiple machines using either NTP (Network Time Protocol) if online or Chrony if offline.",
        "type": "comment"
    },
    "1444": {
        "file_id": 189,
        "content": "/the_frozen_forest_intro/README.md",
        "type": "filepath"
    },
    "1445": {
        "file_id": 189,
        "content": "This code is an introduction to the \"The Frozen Forest\" dataset, which includes time-aligned keystrokes, mouse, and screen recordings. The author plans to expand the dataset with more modalities like text and audio for training their multimodal model, called \"cybergod\".",
        "type": "summary"
    },
    "1446": {
        "file_id": 189,
        "content": "![icon of the frozen forest](../propaganda/logos/frozen_forest_1.png)\n*\"Can you hear it slowing? You're slowing it. You are in control. Calm. At peace.\"*\n<div style='text-align: right;'>— Corvus</div>\n# The Frozen Forest\nA dataset of time-aligned keystrokes, mouse and screen recordings.\n## Roadmap\nCurrently I only record these contents by running autostart scripts within our tiny little virtual machine, copy and rinse it before feeding into our model.\nTo train our mighty multimodal `cybergod`, I plan to add more modalities into this dataset, namely text, audio and more.",
        "type": "code",
        "location": "/the_frozen_forest_intro/README.md:1-15"
    },
    "1447": {
        "file_id": 189,
        "content": "This code is an introduction to the \"The Frozen Forest\" dataset, which includes time-aligned keystrokes, mouse, and screen recordings. The author plans to expand the dataset with more modalities like text and audio for training their multimodal model, called \"cybergod\".",
        "type": "comment"
    },
    "1448": {
        "file_id": 190,
        "content": "/the_frozen_forest_intro/drissionpage_common.py",
        "type": "filepath"
    },
    "1449": {
        "file_id": 190,
        "content": "The code configures a Chromium-based browser with specific extensions and automation settings, importing a Greasy Fork script for ad management, and sets a page object timeout to 10 seconds.",
        "type": "summary"
    },
    "1450": {
        "file_id": 190,
        "content": "# this thing has compatibility issue. the data is not always loaded when ported to a different device.\n# maybe you need docker. we can talk about that later.\nfrom DrissionPage.easy_set import set_paths\n# this thing is not chromium-compatible\n# CHROMIUM_PATH = r\"C:\\Users\\Administrator\\AppData\\Local\\ms-playwright\\chromium-1084\\chrome-win\\chrome.exe\"\nBROWSER_PATH = r\"C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe\"\n# DOWNLOAD_PATH = r\"\"\nUSER_DATA_PATH = r\"F:\\MicrosoftEdgeUserData\"\nCACHE_PATH = r\"F:\\MicrosoftEdgeCache\"\n# you may have to install extensions yourself.\nUSE_CHROME = False\n# USE_CHROME = True\nset_paths(\n    browser_path=BROWSER_PATH,\n    # browser_path=(CHROMIUM_PATH if USE_CHROME else BROWSER_PATH),\n    # download_path=DOWNLOAD_PATH,\n    # **(dict() if USE_CHROME else dict(\n    user_data_path=USER_DATA_PATH,\n    cache_path=CACHE_PATH #)),\n)\n# no sound!\n# 关闭静音开播\nfrom DrissionPage import ChromiumPage # , ChromiumOptions\n# that way we may have the extensions\n# co = ChromiumOptions()\nimport os\n",
        "type": "code",
        "location": "/the_frozen_forest_intro/drissionpage_common.py:2-35"
    },
    "1451": {
        "file_id": 190,
        "content": "The code defines the path for the browser executable (Microsoft Edge), user data, and cache. It also sets the flag to use Chromium or not. The code imports necessary modules and may require installing extensions manually.",
        "type": "comment"
    },
    "1452": {
        "file_id": 190,
        "content": "ext_path = \"keylogger_extension/virtual-keylogger\"\npathToExtension = os.path.abspath(ext_path)\npathToCORSExtension = os.path.abspath(\"ForceCORS\")\nextension_path = \",\".join([pathToExtension, pathToCORSExtension])\n# not very nice.\n# co.set_argument('load-extension', extension_path)\n# co.set_argument(\"disable-extensions-except\", extension_path)\n# co.set_argument(\"enable-automation\")\n# co.set_mute(True)\n# co.set_mute(False)\n# userscripts to fix bilibili ads, for babysitting\n# https://greasyfork.org/zh-CN/scripts/467511-bilibili-%E5%9C%A8%E6%9C%AA%E7%99%BB%E5%BD%95%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%87%AA%E5%8A%A8%E5%B9%B6%E6%97%A0%E9%99%90%E8%AF%95%E7%94%A8%E6%9C%80%E9%AB%98%E7%94%BB%E8%B4%A8\n# https://greasyfork.org/zh-CN/scripts/467474-bilibili-%E9%98%B2%E6%AD%A2%E8%A7%86%E9%A2%91%E8%A2%AB%E8%87%AA%E5%8A%A8%E6%9A%82%E5%81%9C%E5%8F%8A%E5%BC%B9%E5%87%BA%E7%99%BB%E5%BD%95%E7%AA%97%E5%8F%A3\n# https://greasyfork.org/zh-CN/scripts/470714-bilibili-b%E7%AB%99-%E6%9C%AA%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7",
        "type": "code",
        "location": "/the_frozen_forest_intro/drissionpage_common.py:35-50"
    },
    "1453": {
        "file_id": 190,
        "content": "This code sets up a Chromium-based browser with extensions for the frozen forest intro. It loads the \"keylogger_extension/virtual-keylogger\" and \"ForceCORS\" extensions, disables all other extensions except these two, enables automation, mutes the browser, and adds user scripts to fix Bilibili ads.",
        "type": "comment"
    },
    "1454": {
        "file_id": 190,
        "content": "%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E6%9C%80%E9%AB%98%E7%94%BB%E8%B4%A8\n# https://greasyfork.org/zh-CN/scripts/473498-bilibili-%E5%9C%A8%E6%9C%AA%E7%99%BB%E5%BD%95%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E7%85%A7%E5%B8%B8%E5%8A%A0%E8%BD%BD%E8%AF%84%E8%AE%BA\n# 用 d 模式创建页面对象（默认模式）\n# page = ChromiumPage(co if USE_CHROME else None)\npage = ChromiumPage()\nDEFAULT_TIMEOUT = 10\npage.timeout = DEFAULT_TIMEOUT",
        "type": "code",
        "location": "/the_frozen_forest_intro/drissionpage_common.py:50-57"
    },
    "1455": {
        "file_id": 190,
        "content": "This code imports a Greasy Fork script and sets the default timeout for a page object to 10 seconds.",
        "type": "comment"
    },
    "1456": {
        "file_id": 191,
        "content": "/the_frozen_forest_intro/keylogger_extension/init.cmd",
        "type": "filepath"
    },
    "1457": {
        "file_id": 191,
        "content": "Downloading virtual-keylogger repository.",
        "type": "summary"
    },
    "1458": {
        "file_id": 191,
        "content": "git clone https://github.com/AyamDobhal/virtual-keylogger",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_extension/init.cmd:1-1"
    },
    "1459": {
        "file_id": 191,
        "content": "Downloading virtual-keylogger repository.",
        "type": "comment"
    },
    "1460": {
        "file_id": 192,
        "content": "/the_frozen_forest_intro/keylogger_extension/virtual-keylogger/README.md",
        "type": "filepath"
    },
    "1461": {
        "file_id": 192,
        "content": "This is a simple keylogger for virtual keyboards on HDFC Bank's netbanking site, logging keys and sending data to a backend server.",
        "type": "summary"
    },
    "1462": {
        "file_id": 192,
        "content": "# Virtual Keylogger\nThis is a simple keylogger that logs all the keys pressed on the vitual keyboard on https://netbanking.hdfcbank.com and sends them to a backend server ([code available here](https://github.com/ayamdobhal/virtual-keylogger-backend)).\n## How to run\n- Build the index.js file\n```\nnpm run build\n```\n- Open Chrome and go to `chrome://extensions`\n- Enable developer mode\n- Click on `Load unpacked` and select the folder you cloned the repository in",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_extension/virtual-keylogger/README.md:1-12"
    },
    "1463": {
        "file_id": 192,
        "content": "This is a simple keylogger for virtual keyboards on HDFC Bank's netbanking site, logging keys and sending data to a backend server.",
        "type": "comment"
    },
    "1464": {
        "file_id": 193,
        "content": "/the_frozen_forest_intro/keylogger_extension/virtual-keylogger/src/index.js",
        "type": "filepath"
    },
    "1465": {
        "file_id": 193,
        "content": "The code initializes server settings, handles errors, and provides functions for screenshots, UUID generation, keylogger extension. It manages HID events, sets event listeners for mouse movements, and sends events to the backend using POST requests.",
        "type": "summary"
    },
    "1466": {
        "file_id": 193,
        "content": "console.log('Starting keylogger for browser');\nconst serverPort = 4471\nconst baseUrl = `http://localhost:${serverPort}`\nconst backendUrl = `${baseUrl}/browserInputEvent`;\nconst screenshotSubmitUrl = `${baseUrl}/submitScreenshot`;\n// const identifierUrl = `${baseUrl}/getIdentifier`;\nfunction getPythonStyleTimestamp() {\n  return new Date().getTime() / 1000\n}\nfunction getScreenshotDataUrl() {\n  const canvas = document.createElement('canvas');\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n  const ctx = canvas.getContext('2d');\n  // Draw the screenshot of the viewport onto the canvas\n  ctx.drawImage(window, 0, 0, window.innerWidth, window.innerHeight);\n  // Convert the canvas content to a data URL representing the screenshot\n  const screenshotDataUrl = canvas.toDataURL('image/png');\n  // canvas.remove()\n  return screenshotDataUrl\n}\nfunction submitScreenshot(pageIdentifier) {\n  try {\n    let dataUrl = getScreenshotDataUrl()\n    fetch(screenshotSubmitUrl, { method: 'POST', data: JSON.stri",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_extension/virtual-keylogger/src/index.js:1-29"
    },
    "1467": {
        "file_id": 193,
        "content": "This code initializes the server port, base URL, and backend URL for a keylogger browser extension. It also includes functions to get the current timestamp in Python style, take a screenshot of the viewport, convert it to a data URL, and submit the screenshot to a server.",
        "type": "comment"
    },
    "1468": {
        "file_id": 193,
        "content": "ngify({ client_id: pageIdentifier, timestamp: getPythonStyleTimestamp(), screenshot_data: dataUrl }) }).catch(e => {\n      console.log('error posting screenshot:', e.message);\n    })\n  } catch (e) {\n    console.log('error while submitting screenshot:', e.message)\n  }\n}\n// function generateUUIDFallback() {\n//   var d = new Date().getTime();\n//   if (window.performance && typeof window.performance.now === \"function\") {\n//     d += performance.now(); // use high-precision timer if available\n//   }\n//   var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n//     var r = (d + Math.random() * 16) % 16 | 0;\n//     d = Math.floor(d / 16);\n//     return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);\n//   });\n//   return uuid;\n// }\n// function generateUUID() {\n//   const crypto = window.crypto || window.msCrypto;\n//   if (crypto) {\n//     const array = new Uint32Array(4);\n//     crypto.getRandomValues(array);\n//     return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c)",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_extension/virtual-keylogger/src/index.js:29-54"
    },
    "1469": {
        "file_id": 193,
        "content": "This code is trying to post a screenshot and generate a unique identifier. If there's an error while posting the screenshot or generating the UUID, it logs the error message in the console. It checks if a high-precision timer is available before generating the UUID using either the random number generator from window.crypto or window.msCrypto (for Windows).",
        "type": "comment"
    },
    "1470": {
        "file_id": 193,
        "content": " {\n//       const r = (array[0] & 0x0f) / 0x0f;\n//       const v = c === 'x' ? r : (r & 0x3 | 0x8);\n//       array = array.slice(1);\n//       return v.toString(16);\n//     });\n//   } else {\n//     console.error('crypto API not available');\n//     return generateUUIDFallback();\n//   }\n// }\n// const pageIdentifier = generateUUID();\n// fetch(identifierUrl, {\n//   method: \"GET\"\n// }).then(response => { const pageIdentifier = response.json()['client_id'] })\n// https://developer.mozilla.org/en-US/docs/Web/Events\n// noe we have click/dblclick, keypress events\n// how to handle them?\nconst eventTypes = ['keydown', 'keyup', 'mousedown', 'mouseup', 'mousemove'];\n// const eventTypes = ['keydown', 'keyup', 'mousedown', 'mouseup', 'mousemove', 'resize'];\nvar keylogger_timestamp_private = null; // you can check if this thing still works.\n// var pageIdentifier = null;\nfunction sendHIDEvent(event, e) {\n  let event_keys = Object.keys(e.__proto__);\n  let event_data = {}\n  for (let k of event_keys) {\n    event_data[k] = e[k];\n  }\n  ",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_extension/virtual-keylogger/src/index.js:54-84"
    },
    "1471": {
        "file_id": 193,
        "content": "This code is initializing variables and defining the function `sendHIDEvent` which takes an event type and an event object as parameters. It extracts event data from the event object and may be used to handle keydown, keyup, mousedown, mouseup, and mousemove events. The `pageIdentifier` variable is assigned based on a generated UUID, and the `eventTypes` array can contain various event types to handle.",
        "type": "comment"
    },
    "1472": {
        "file_id": 193,
        "content": "// debugger\n  keylogger_timestamp_private = getPythonStyleTimestamp();\n  const inputEvent = {\n    // eventType: event,\n    // timestamp: keylogger_timestamp_private,\n    // data: JSON.stringify(event_data),\n    // \"eventType\": event,\n    \"timestamp\": keylogger_timestamp_private,\n    \"client_id\": pageIdentifier,\n    \"payload\": { 'eventType': event, 'data': event_data },\n    // \"data\": JSON.stringify(event_data),\n    // data: JSON.stringify(e),\n    // data: e,\n  };\n  // console.log(inputEvent);\n  // debugger;\n  // console.log('payload:', JSON.stringify(inputEvent))\n  fetch(backendUrl, {\n    method: \"POST\",\n    // or you could remove the 'mode' parameter\n    mode: \"cors\", // you must use cors or the content will be unprocessable.\n    // mode: \"no-cors\",\n    headers: { \"Content-Type\": \"application/json\" },\n    // json: {browserEvent: inputEvent}\n    // body: inputEvent,\n    // body: \"hello world\",\n    // body: { body: JSON.stringify(inputEvent) },\n    body: JSON.stringify(inputEvent),\n  }).then((res) => {\n    // conso",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_extension/virtual-keylogger/src/index.js:84-115"
    },
    "1473": {
        "file_id": 193,
        "content": "Creating event object with timestamp and payload, then sending it to the backend using a POST request with JSON headers.",
        "type": "comment"
    },
    "1474": {
        "file_id": 193,
        "content": "le.log(`posted ${event} event`, res);\n    // console.log(`posted ${event} event`, res.json());\n  }).catch((err) => {\n    console.log(`error posting ${event} event`, err);\n  });\n}\nconst pageIdentifierPrefix = \"pageIdentifier_\";\nfunction getPageIdentifierFromExposedFunctionName() {\n  let wk = Object.keys(window)\n  let candidate_keys = [];\n  for (let k of wk) {\n    if (k.startsWith(pageIdentifierPrefix)) {\n      let myIdentifier = k.replace(pageIdentifierPrefix, \"\").replace(/\\_/g, \"-\");\n      candidate_keys.push(myIdentifier);\n    }\n  }\n  if (candidate_keys.length == 1) {\n    return candidate_keys[0];\n  } else {\n    console.error('Invalid page identifier candidates:', candidate_keys)\n  }\n  return 'unknown'\n}\nconst pageIdentifier = getPageIdentifierFromExposedFunctionName();\nconsole.log(`pageIdentifier: ${pageIdentifier}`)\nconst screenshotInterval = 2 * 1000;\n// usually we take screenshot on demand, not like this.\n// setInterval(() => submitScreenshot(pageIdentifier), screenshotInterval)\n// console.log(`taking screen",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_extension/virtual-keylogger/src/index.js:115-144"
    },
    "1475": {
        "file_id": 193,
        "content": "Sending event and handling errors\nExtracting page identifier from exposed function names\nSetting screenshot interval",
        "type": "comment"
    },
    "1476": {
        "file_id": 193,
        "content": "shot every ${screenshotInterval} ms`)\nfunction addSpecificEventListener(event) {\n  document.addEventListener(event, (e) => {\n    // console.log('event', event, e);\n    // debugger\n    // if (isVariableEmpty(pageIdentifier)) {\n    //   pageIdentifier = getPageIdentifierFromExposedFunctionName()\n    // not working for content script\n    // fetch(identifierUrl, {\n    //   method: \"GET\"\n    // }).then(response => {\n    //   pageIdentifier = response.json()['client_id'];\n    //   sendHIDEvent(event, e);\n    // })\n    // window.generateUUID(JSON.stringify({})).then(r => {\n    //   pageIdentifier = r;\n    //   sendHIDEvent(event, e);\n    // });\n    // } \n    // else {\n    sendHIDEvent(event, e);\n    // }\n  });\n}\n// window.generateUUID().then(pageIdentifier => {\nfor (const event of eventTypes) {\n  addSpecificEventListener(event, pageIdentifier);\n}\n// }); // this can be expected from playwright.\nfunction setElementAttributeAsCursorReady(element, elementId) {\n  element.style.position = \"absolute\";\n  element.style.pointerEvent",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_extension/virtual-keylogger/src/index.js:144-180"
    },
    "1477": {
        "file_id": 193,
        "content": "Sets up event listeners for specified events to send HID (Hardware Input Device) events. The page identifier is retrieved based on the conditions specified in the function, and the listeners are added for each event type.",
        "type": "comment"
    },
    "1478": {
        "file_id": 193,
        "content": "s = \"none\";\n  element.id = elementId;\n}\nfunction createOmniscentPointerElement(elementId) {\n  // var divElement = document.createElement(\"div\");\n  // divElement.style.width = \"10px\";\n  // divElement.style.height = \"10px\";\n  // divElement.style.backgroundColor = \"red\";\n  // divElement.style.borderRadius = \"50%\";\n  // setElementAttributeAsCursorReady(divElement, elementId)\n  // Create the img element\n  var imgElement = document.createElement(\"img\");\n  imgElement.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAAUCAQAAAD8O3+kAAAA+ElEQVR4nHXOsSsEcBjG8S/nkOIGk+EyXHGuDIazyMRikbKgLC4ZZGAysPEnmC9lvOnKZjJcWQyUOqWQYpS7zrnjvpa7Y/jdO71Pn3qfFw7oOD/sd5C407IXpEmfnWmwE6CkNd9M/7AVoLL64lSdjSDpk5M11oOkD6aqrARJ7x2rsBwkvTNRZjFIeuPoBwtB0qLj78xBz19riSM+gSgjsWKetSZ9cck811ycUKALiABJKzbcdNiS53L27/mUVXclS/bUuskSiTZNuC05oqRnv/VYDtvULXkGgEi0cOurg4/EWpZjqLlllly1t0C8Rf3tAyNckaGvFX8Bxhaqb4UTp4MAAAAASUVORK5CYII=\";\n  setElementAttributeAsCursorReady(imgElement, elementId);\n  // Append the img element to the div element\n  //",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_extension/virtual-keylogger/src/index.js:180-201"
    },
    "1479": {
        "file_id": 193,
        "content": "Creates an omniscent pointer element with a red dot cursor and sets it as ready for the given element ID.",
        "type": "comment"
    },
    "1480": {
        "file_id": 193,
        "content": " divElement.appendChild(imgElement);\n  // Insert the div element into the document body\n  document.body.appendChild(imgElement);\n  // document.body.appendChild(divElement);\n  return imgElement;\n  // return divElement;\n}\nconst pointerElementId = 'omniscent_pointer';\nfunction isVariableEmpty(v) {\n  return v === undefined | v == null\n}\nfunction getOmniscentPointer() {\n  // while (isVariableEmpty(vpointer)) {\n  var pointer = document.getElementById(pointerElementId);\n  if (isVariableEmpty(pointer)) {\n    console.log('pointer is undefined');\n    console.log('creating pointer element');\n    pointer = createOmniscentPointerElement(pointerElementId);\n    // pointer = createOmniscentPointerElement(pointerElementId);\n  }\n  // }\n  return pointer;\n}\n// sometimes this pointer is misaligned.\nfunction addMouseEventTracer(eventName) {\n  document.addEventListener(eventName, function (event) {\n    const x = event.clientX;\n    const y = event.clientY;\n    // const x = event.layerX;\n    // const y = event.layerY;\n    // const x = even",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_extension/virtual-keylogger/src/index.js:201-233"
    },
    "1481": {
        "file_id": 193,
        "content": "The code is responsible for managing the 'omniscent_pointer' element on the webpage. It checks if the pointer element is already present, creates it if not, and returns the pointer element. Additionally, an event listener is added to track mouse movements by capturing the clientX and clientY properties of the event object.",
        "type": "comment"
    },
    "1482": {
        "file_id": 193,
        "content": "t.x;\n    // const y = event.y;\n    // var pointer = getOmniscentPointer();\n    const pointer = getOmniscentPointer();\n    // debugger;\n    // Set the position of the pointer element\n    pointer.style.left = x + 'px';\n    pointer.style.top = y + 'px';\n    // pointer.style.marginLeft = x + 'px';\n    // pointer.style.marginTop = y + 'px';\n  });\n}\n// it is this page creating havoc.\n// https://darkreader.org/help/zh-CN/\n// a little bit of fucked up.\n// let's not do this.\n// instead, render the mouse cursor later. could be more accurate and precise.\n// document.addEventListener('DOMContentLoaded', function () {\n// const mouseEvents = ['mousedown', 'mouseup', 'mousemove'];\n// for (let e of mouseEvents) {\n//   // Event listener for mouse movement\n//   addMouseEventTracer(e)\n// }\n// });",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_extension/virtual-keylogger/src/index.js:233-264"
    },
    "1483": {
        "file_id": 193,
        "content": "This code is setting up event listeners for mouse events (mousedown, mouseup, and mousemove) to track the position of the cursor. It initially attempted to use a getOmniscentPointer function, but has been modified to set the position of the pointer element directly using CSS styles. The code will run after the DOM content is loaded, and it appears that there was some prior attempt to create a separate function for each event listener, which has now been simplified into a single loop over all events.",
        "type": "comment"
    },
    "1484": {
        "file_id": 194,
        "content": "/the_frozen_forest_intro/keylogger_extension/virtual-keylogger/webpack.config.js",
        "type": "filepath"
    },
    "1485": {
        "file_id": 194,
        "content": "Configuring webpack with production mode, entry point at \"./src/index.js\", and output filename as \"main.js\" in the \"dist\" folder.",
        "type": "summary"
    },
    "1486": {
        "file_id": 194,
        "content": "const path = require(\"path\");\nmodule.exports = {\n  mode: \"production\",\n  entry: \"./src/index.js\",\n  output: {\n    path: path.resolve(__dirname, \"dist\"),\n    filename: \"main.js\",\n  },\n};",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_extension/virtual-keylogger/webpack.config.js:1-10"
    },
    "1487": {
        "file_id": 194,
        "content": "Configuring webpack with production mode, entry point at \"./src/index.js\", and output filename as \"main.js\" in the \"dist\" folder.",
        "type": "comment"
    },
    "1488": {
        "file_id": 195,
        "content": "/the_frozen_forest_intro/keylogger_server.py",
        "type": "filepath"
    },
    "1489": {
        "file_id": 195,
        "content": "This code sets up a FastAPI server for event monitoring, handles HTTP events, logs validation errors and stores data in a JSON file upon reaching 5 keys, and runs an Uvicorn server on localhost at a specified port.",
        "type": "summary"
    },
    "1490": {
        "file_id": 195,
        "content": "# you are expected to receive mouse/keyboard events\n#\nserverPort = 4471\nimport fastapi\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom typing import Callable, Any, Dict, Union, Literal\norigins = [\"*\"]\napp = fastapi.FastAPI()\napp.add_middleware(\n    CORSMiddleware, allow_origins=origins, allow_methods=origins, allow_headers=origins\n)\nfrom pydantic import BaseModel\nclass MouseEventData(BaseModel):\n    screenX: int\n    screenY: int\n    clientX: int\n    clientY: int\n    ctrlKey: bool\n    shiftKey: bool\n    altKey: bool\n    metaKey: bool\n    button: int\n    buttons: int\n    relatedTarget: Any\n    pageX: int\n    pageY: int\n    x: int\n    y: int\n    offsetX: int\n    offsetY: int\n    movementX: int\n    movementY: int\n    fromElement: Any\n    toElement: Dict[str, Any]\n    layerX: int\n    layerY: int\nclass KeyboardEventData(BaseModel):\n    key: str\n    code: str\n    location: int\n    ctrlKey: bool\n    shiftKey: bool\n    altKey: bool\n    metaKey: bool\n    repeat: bool\n    isComposing: bool\n    charCode: int\n    keyCode: int\n    DOM_KEY",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_server.py:1-55"
    },
    "1491": {
        "file_id": 195,
        "content": "This code sets up a FastAPI server that listens for mouse and keyboard events. It uses the CORSMiddleware to allow requests from any origin, method, and header. The server also defines two Pydantic models, MouseEventData and KeyboardEventData, for handling event data.",
        "type": "comment"
    },
    "1492": {
        "file_id": 195,
        "content": "_LOCATION_STANDARD: int\n    DOM_KEY_LOCATION_LEFT: int\n    DOM_KEY_LOCATION_RIGHT: int\n    DOM_KEY_LOCATION_NUMPAD: int\nclass EventPayload(BaseModel):\n    eventType: str\n    data: dict\nclass MouseEventPayload(BaseModel):\n    eventType: Literal[\"mousedown\", \"mouseup\", \"mousemove\"]\n    data: MouseEventData\nclass KeyboardEventPayload(BaseModel):\n    eventType: Literal[\"keydown\", \"keyup\"]\n    # eventType: Literal['keydown', 'keyup', 'keypress']\n    data: KeyboardEventData\n# tradeoff when using string types: you need to call update_forward_refs()\n# import uuid\nclass EventModel(BaseModel):\n    # eventType: str\n    timestamp: float\n    # timestamp: str\n    # data: str\n    client_id: str\nclass ScreenshotEvent(EventModel):\n    screenshot_data: str\n    # screenshot_data: str\nclass BrowserEvent(EventModel):\n    # client_id: uuid.UUID\n    # payload: Union[MouseEventPayload, KeyboardEventPayload]\n    payload: Union[MouseEventPayload, KeyboardEventPayload, EventPayload]\n    # payload: EventPayload\n# obviously not right.\n#    \"dat",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_server.py:55-99"
    },
    "1493": {
        "file_id": 195,
        "content": "Code defines various event types and their payload structures for a browser monitoring system.",
        "type": "comment"
    },
    "1494": {
        "file_id": 195,
        "content": "a\": {\n#     \"isTrusted\": true\n# }\nfrom fastapi import Request, Response\nfrom fastapi.routing import APIRoute\n# from log_utils import terminal_column_size\nterminal_column_size = 80\nimport json\nclass ValidationErrorLoggingRoute(APIRoute):\n    def get_route_handler(self) -> Callable:\n        original_route_handler = super().get_route_handler()\n        async def custom_route_handler(request: Request) -> Response:\n            try:\n                return await original_route_handler(request)\n            # except RequestValidationError as exc:\n            except Exception as e:\n                is_json = False\n                try:\n                    body = await request.json()\n                    body = json.dumps(body, indent=4, ensure_ascii=False)\n                    is_json = True\n                except:\n                    body = await request.body()\n                print(\n                    \"request{}\".format(\"_json\" if is_json else \"\")\n                    .upper()\n                    .center(terminal_column_siz",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_server.py:99-130"
    },
    "1495": {
        "file_id": 195,
        "content": "This code defines a class called `ValidationErrorLoggingRoute` which extends the `APIRoute` class from FastAPI. It overrides the default route handler to log any exceptions that occur during the execution of the original route handler. If the request body is in JSON format, it will be formatted and printed along with the exception. The code also sets a variable `terminal_column_size` to 80.",
        "type": "comment"
    },
    "1496": {
        "file_id": 195,
        "content": "e, \"_\"),\n                    body,\n                    sep=\"\\n\",\n                )\n                print(\n                    \"exception\".upper().center(terminal_column_size, \"_\"), e, sep=\"\\n\"\n                )\n                # detail = {\"errors\": exc.errors(), \"body\": body.decode()}\n                # raise HTTPException(status_code=422, detail=detail)\n                raise e\n        return custom_route_handler\napp.router.route_class = ValidationErrorLoggingRoute\n# sample_data_path = 'sample_event_data.json'\n# sample_data = {}\n# @app.get('/getIdentifier')\n# def get_identifier(client_id:str):\n#     return dict(client_id=client_id)\nSTATUS_OK_RESPONSE = {'status': 'ok'}\n@app.post(\"/submitScreenshot\")\ndef receiveScreenshotEvent(request_data: ScreenshotEvent):\n    return STATUS_OK_RESPONSE\n@app.post(\"/browserInputEvent\")\n# def receiveBrowserInputEvent(body:Dict[str, Any]):\n# def receiveBrowserInputEvent(\n#     eventType: str,\n#     timestamp: str,\n#     data: str,\n# ):\ndef receiveBrowserInputEvent(request_data: Brows",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_server.py:130-165"
    },
    "1497": {
        "file_id": 195,
        "content": "This code is for a FastAPI web application. It defines routes and handlers for submitting screenshot events and receiving browser input events. The app uses the ValidationErrorLoggingRoute class to log any validation errors that occur during request processing, and it returns an \"ok\" response for successful requests.",
        "type": "comment"
    },
    "1498": {
        "file_id": 195,
        "content": "erEvent):\n    # print(\"received body:\", eventType, timestamp, data)\n    print(\"received body:\", request_data)\n    # eventType = request_data.payload.eventType\n    # data = request_data.payload.data\n    # sample_data[eventType] = data\n    # if len(sample_data.keys()) == 5:\n    #     with open(sample_data_path, 'w+') as f:\n    #         f.write(json.dumps(sample_data, ensure_ascii=False, indent=4))\n    #     print(\"sample data saved to\", sample_data_path)\n    #     exit(0)\n    return STATUS_OK_RESPONSE\nif __name__ == \"__main__\":\n    import uvicorn\n    print(\"server address: http://localhost:%d\" % serverPort)\n    uvicorn.run(app, host=\"0.0.0.0\", port=serverPort)",
        "type": "code",
        "location": "/the_frozen_forest_intro/keylogger_server.py:165-183"
    },
    "1499": {
        "file_id": 195,
        "content": "This code is handling HTTP events, printing received event data, and storing a sample of the data in a JSON file when the number of keys reaches 5. It also returns an OK response. The code runs an Uvicorn server on localhost at a specified port.",
        "type": "comment"
    }
}