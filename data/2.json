{
    "200": {
        "file_id": 12,
        "content": "ia = auto()\n    Explorer = auto()\n    Calculator = auto()\n    ScreenSave = auto()\n    MyComputer = auto()\n    Minimize = auto()\n    Record = auto()\n    Rewind = auto()\nassert len(MultimediaKey.__members__) == 3 * 8 + 1  # include \"Null\"\nclass ACPIKey(Flag):\n    Null = 0  # for clearing all \"ACPI\" keys.\n    Power = auto()\n    Sleep = auto()\n    Wakeup = auto()\nif __name__ == \"__main__\":\n    # generate that table.\n    import Levenshtein as L\n    import keysymdef\n    unicode_str_to_xk_keysym = {}\n    xk_keysyms = []\n    xk_keysyms_lut = {}\n    for xk_keysym, _, unicode_int in keysymdef.keysymdef:\n        unicode_str = None\n        as_unicode_char = False\n        if unicode_int:\n            try:\n                unicode_str = chr(unicode_int)\n                unicode_str_to_xk_keysym[unicode_str] = xk_keysym\n                as_unicode_char = True\n            except:\n                pass\n        xk_keysym_lower = xk_keysym.lower()\n        xk_keysyms_lut[xk_keysym_lower] = xk_keysym\n        # if not as_unicode_char:\n        xk",
        "type": "code",
        "location": "/hid_utils.py:229-273"
    },
    "201": {
        "file_id": 12,
        "content": "The code is defining classes and variables for handling various input operations. It creates classes like MultimediaKey, ACPIKey, Explorer, Calculator, etc., which are used to handle specific types of key inputs. It also generates a table mapping Unicode strings to xk_keysyms. The purpose seems to be related to handling different keys and their associated functions in an input-processing system.",
        "type": "comment"
    },
    "202": {
        "file_id": 12,
        "content": "_keysyms.append(xk_keysym_lower)  # for space.\n    KL2XKS = {}\n    # import rich\n    # rich.print(xk_keysyms_lut)\n    # breakpoint()\n    keywords_translation_table = dict(\n        cmd=\"super\",\n        ctrl=\"control\",\n        _left=\"_l\",\n        _right=\"_r\",\n        esc=\"escape\",\n        enter=\"return\",\n        # we do not use xf86 (multimedia) keys. or shall we? how to handle the play/pause button then?\n    )\n    def translate(string: str, translation_table: Dict[str, str]):\n        for k, v in translation_table.items():\n            string = string.replace(k, v)\n        return string\n    import re\n    for key_literal in HIDActionBase.keys:  # nearly instant. no need for progressbar.\n        is_special, is_media, stripped_key_literal = strip_key_literal(key_literal)\n        if is_media:\n            continue\n        # media prefix is removed.\n        # if \"eth\" in stripped_key_literal.lower():\n        #     breakpoint()\n        if stripped_key_literal in unicode_str_to_xk_keysym.keys():\n            keysym = unicod",
        "type": "code",
        "location": "/hid_utils.py:273-305"
    },
    "203": {
        "file_id": 12,
        "content": "The code defines a translation table for converting keyboard literals to their respective meanings. It then defines a function called `translate` that replaces the keywords in a string with their corresponding translations using a dictionary. The code also imports the `re` module and loops over each key literal, stripping any special or media prefixes before checking if it exists in the unicode-to-xk_keysym mapping. If it does, it breaks execution.",
        "type": "comment"
    },
    "204": {
        "file_id": 12,
        "content": "e_str_to_xk_keysym[stripped_key_literal]\n        else:\n            # import humps\n            stripped_key_literal = translate(\n                re.sub(\n                    r\"^(alt|control|cmd|shift)$\", r\"\\1_l\", stripped_key_literal.lower()\n                ),\n                keywords_translation_table,\n            )\n            # if \"return\" in stripped_key_literal:\n            #     breakpoint()\n            xk_keysyms.sort(\n                key=lambda keysym: L.distance(keysym.lower(), stripped_key_literal)\n            )\n            keysym = xk_keysyms.pop(0)\n        KL2XKS.update(val := {key_literal: xk_keysyms_lut[keysym]})\n        print(val, key_literal, stripped_key_literal)\n    with open(key_literal_to_xk_keysym_translation_table_path, \"w+\") as f:\n        f.write(json.dumps(KL2XKS, ensure_ascii=False, indent=4))\n    logger_print(\"write to:\", key_literal_to_xk_keysym_translation_table_path)",
        "type": "code",
        "location": "/hid_utils.py:305-324"
    },
    "205": {
        "file_id": 12,
        "content": "This code is translating key literals to XK_KEYSYMs, storing the translation in a dictionary and writing it to a file. It first checks if the key literal starts with \"alt\", \"control\", \"cmd\", or \"shift\" and adds an underscore before the letter if it does. Then it sorts the XK_KEYSYMs based on the distance between their lowercase strings and the stripped_key_literal, selects the closest one and updates a dictionary of key literals to their respective XK_KEYSYMs. Finally, it writes this dictionary to a file.",
        "type": "comment"
    },
    "206": {
        "file_id": 13,
        "content": "/hotkey_listener.py",
        "type": "filepath"
    },
    "207": {
        "file_id": 13,
        "content": "The code imports the keyboard module from pynput library, defines functions for handling key presses and releases, includes a dictionary mapping keyboard keys to ASCII codes or special characters, but the hotkey listener is not currently running.",
        "type": "summary"
    },
    "208": {
        "file_id": 13,
        "content": "from pynput import keyboard\ndef on_press(key):\n    if type(key) != str:\n        key = str(key)\n    print((\"key_press\", key))\ndef on_release(key):\n    if type(key) != str:\n        key = str(key)\n    print((\"key_release\", key))\n# keyboard_listener = keyboard.Listener(on_press=on_press, on_release=on_release)\n# keyboard_listener.run()\nkeycode_ctrl = {\n    \"a\": \"\\x01\",\n    \"b\": \"\\x02\",\n    \"c\": \"\\x03\",\n    \"d\": \"\\x04\",\n    \"e\": \"\\x05\",\n    \"f\": \"\\x06\",\n    \"g\": \"\\x07\",\n    \"h\": \"\\x08\",\n    \"i\": \"\\x09\",\n    \"j\": \"\\x0a\",\n    \"k\": \"\\x0b\",\n    \"l\": \"\\x0c\",\n    \"m\": \"\\x0d\",\n    \"n\": \"\\x0e\",\n    \"o\": \"\\x0f\",\n    \"p\": \"\\x10\",\n    \"q\": \"\\x11\",\n    \"r\": \"\\x12\",\n    \"s\": \"\\x13\",\n    \"t\": \"\\x14\",\n    \"u\": \"\\x15\",\n    \"v\": \"\\x16\",\n    \"w\": \"\\x17\",\n    \"x\": \"\\x18\",\n    \"y\": \"\\x19\",\n    \"z\": \"\\x1a\",\n    \"[\": \"\\x1b\",\n    \"[\": \"<219>\",\n    \"]\": \"\\x1d\",\n    \"]\": \"<221>\",\n    \"-\": \"\\x1f\",\n    \"-\": \"<189>\",\n    \"=\": \"<187>\",\n    \"`\": \"<192>\",\n    \"0\": \"<48>\",\n    \"1\": \"<49>\",\n    \"2\": \"<50>\",\n    \"3\": \"<51>\",\n    \"4\": \"<52>\",\n    \"5\": \"<53>\",\n    \"6\": \"<54>\",\n",
        "type": "code",
        "location": "/hotkey_listener.py:1-61"
    },
    "209": {
        "file_id": 13,
        "content": "This code imports the keyboard module from pynput library and defines two functions for handling key presses and releases. The hotkey listener is not running currently. It also contains a dictionary mapping keyboard keys to their corresponding ASCII codes or special characters.",
        "type": "comment"
    },
    "210": {
        "file_id": 13,
        "content": "    \"7\": \"<55>\",\n    \"8\": \"<56>\",\n    \"9\": \"<57>\",\n    \"\\\\\": \"\\x1c\",\n    \"\\\\\": \"<220>\",\n    \";\": \"<186>\",\n    \"'\": \"<222>\",\n    \"<\": \"<188>\",\n    \">\": \"<190>\",\n    \"?\": \"<191>\",\n}\nprint({v: k for k, v in keycode_ctrl.items()})",
        "type": "code",
        "location": "/hotkey_listener.py:61-72"
    },
    "211": {
        "file_id": 13,
        "content": "Mapping keycode to control dictionary.",
        "type": "comment"
    },
    "212": {
        "file_id": 14,
        "content": "/hotkey_tester.py",
        "type": "filepath"
    },
    "213": {
        "file_id": 14,
        "content": "Code is disabling all hotkeys by pressing the Control key.",
        "type": "summary"
    },
    "214": {
        "file_id": 14,
        "content": "import pyautogui\nimport pynput\n# you simply deprecate all hotkeys.\nkeyboard_controller = pynput.keyboard.Controller()\nkeyboard_controller.press(pynput.keyboard.Key.ctrl)\npyautogui.typewrite('1')\nkeyboard_controller.release(pynput.keyboard.Key.ctrl)",
        "type": "code",
        "location": "/hotkey_tester.py:1-10"
    },
    "215": {
        "file_id": 14,
        "content": "Code is disabling all hotkeys by pressing the Control key.",
        "type": "comment"
    },
    "216": {
        "file_id": 15,
        "content": "/install_nvidia_container_toolkit.sh",
        "type": "filepath"
    },
    "217": {
        "file_id": 15,
        "content": "This code determines the Debian version for Kali 2022.2, checks for the kernel version (5.16), and sets the distribution to \"debian11\". It then installs the NVIDIA container toolkit by adding a GPG key, updating a source list, and installing the necessary packages from the specified repository.",
        "type": "summary"
    },
    "218": {
        "file_id": 15,
        "content": "# figure out what version of debian is for kali 2022.2\n# `uname -a` to get debian kernel version (5.16) -> bullseye (debian 11)\n# supported versions:\n# ref: https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html\n# distribution=$(. /etc/os-release;echo $ID$VERSION_ID) \\\ndistribution=\"debian11\" \\\n      && curl -fsSL -k https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \\\n      && curl -s -L -k https://nvidia.github.io/libnvidia-container/experimental/$distribution/libnvidia-container.list | \\\n         sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \\\n         sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list",
        "type": "code",
        "location": "/install_nvidia_container_toolkit.sh:1-12"
    },
    "219": {
        "file_id": 15,
        "content": "This code determines the Debian version for Kali 2022.2, checks for the kernel version (5.16), and sets the distribution to \"debian11\". It then installs the NVIDIA container toolkit by adding a GPG key, updating a source list, and installing the necessary packages from the specified repository.",
        "type": "comment"
    },
    "220": {
        "file_id": 16,
        "content": "/jinja_utils.py",
        "type": "filepath"
    },
    "221": {
        "file_id": 16,
        "content": "This code imports modules, defines functions to manipulate Python code, performs type checks using pyright linter, handles file updates and outputs formatted code, uses Jinja2 templates for execution, and converts variables into Python.",
        "type": "summary"
    },
    "222": {
        "file_id": 16,
        "content": "from log_utils import logger_print\nimport subprocess\nfrom tempfile import TemporaryDirectory\nimport black\n# from humps import kebabize\nimport jinja2\nimport shutil\nimport os\nimport pyright_utils  # for checking if really installed.\nimport re\n# live share's triple quote issue isn't fixed.\nimport humps  # default to snake case!\nimport ast\ndef remove_typehint(paramDef: str) -> str:\n    tree_def = ast.parse(\"def func({}): ...\".format(paramDef)).body[0]\n    args = []\n    for elem in ast.walk(tree_def):\n        if isinstance(elem, ast.arg):\n            argName = elem.arg  # str\n            args.append(argName)\n    return \",\".join([f\"{argName}={argName}\" for argName in args])\ndef camelize_with_space(string):\n    return humps.camelize(string.replace(\" \", \"-\"))\n# ref: https://www.geeksforgeeks.org/python-program-to-convert-camel-case-string-to-snake-case/\ndef c2s(_str):\n    \"\"\"\n    Camel case to snake case.\n    \"\"\"\n    # return humps.kebabize(_str).replace(\"-\", \"_\")\n    # res = [_str[0].lower()]\n    # for c in _str[1:]:\n    #",
        "type": "code",
        "location": "/jinja_utils.py:1-43"
    },
    "223": {
        "file_id": 16,
        "content": "This code imports various modules and defines functions to manipulate Python code, such as removing type hints and converting variable names between different cases. It also includes a function to convert camel case to snake case.",
        "type": "comment"
    },
    "224": {
        "file_id": 16,
        "content": "     if c in (\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"):\n    #         res.append(\"_\")\n    #         res.append(c.lower())\n    #     else:\n    #         res.append(c)\n    # return \"\".join(res)\n    return humps.decamelize(_str)\ndef s2c(_str, lower: bool):\n    \"\"\"\n    Snake case to camel case.\n    \"\"\"\n    # assert not _str.startswith(\"_\")\n    # lst = _str.split(\"_\")\n    # first_letter = lst[0][0]\n    # lst[0] = (first_letter.lower() if lower else first_letter.upper()) + lst[0][1:]\n    # for i in range(1, len(lst)):\n    #     lst[i] = lst[i].title()\n    # return \"\".join(lst)\n    return getattr(humps, \"camelize\" if lower else \"pascalize\")(_str)\ndef s2cl(_str):\n    \"\"\"\n    Snake case to camel case (starting with lower letter).\n    \"\"\"\n    return s2c(_str, True)\ndef s2cu(_str):\n    \"\"\"\n    Snake case to camel case (starting with upper letter).\n    \"\"\"\n    return s2c(_str, False)\nclass NeverUndefined(jinja2.StrictUndefined):\n    def __init__(self, *args, **kwargs):\n        # ARGS: (\"parameter 'myvar2' was not provided\",)\n        # KWAR",
        "type": "code",
        "location": "/jinja_utils.py:43-84"
    },
    "225": {
        "file_id": 16,
        "content": "Code comments:\n1. jinja_utils.py:42-83",
        "type": "comment"
    },
    "226": {
        "file_id": 16,
        "content": "GS: {'name': 'myvar2'}\n        if len(args) == 1:\n            info = args[0]\n        elif \"name\" in kwargs.keys():\n            info = f\"Undefined variable '{kwargs['name']}\"\n        else:\n            infoList = [\"Not allowing any undefined variable.\"]\n            infoList.append(f\"ARGS: {args}\")\n            infoList.append(f\"KWARGS: {kwargs}\")\n            info = \"\\n\".join(infoList)\n        raise Exception(info)\ndef load_render_and_format(\n    template_path: str,\n    output_path: str,\n    render_params: dict,\n    banner: str,\n    needFormat: bool = True,\n):\n    tpl = load_template(template_path)\n    result = tpl.render(**render_params)\n    logger_print()\n    logger_print(\"______________________[{}]\".format(banner))\n    logger_print(result)\n    # import black.Mode\n    output_path_elems = output_path.split(\".\")\n    output_path_elems.insert(-1, \"new\")\n    if os.path.exists(output_path):\n        with open(output_path, \"r\") as f:\n            backup_content = f.read()\n    else:\n        backup_content = \"\"\n    with open(tmp",
        "type": "code",
        "location": "/jinja_utils.py:84-120"
    },
    "227": {
        "file_id": 16,
        "content": "load_render_and_format function takes template path, output path, render params, banner and optional needFormat (default True) as input. It loads the template from the specified path, renders it with render params as arguments and prints the result to the logger with a banner separator. If output_path exists, it reads its content for backup, else sets backup content as an empty string.",
        "type": "comment"
    },
    "228": {
        "file_id": 16,
        "content": "_output_path := \".\".join(output_path_elems), \"w+\") as f:\n        f.write(result)\n    if not needFormat:\n        shutil.move(tmp_output_path, output_path)\n        return\n    try:\n        # TODO: add more test, like checking for undefined variables, before rewriting the source file.\n        # TODO: add rollback mechanism in makefile\n        result = black.format_str(result, mode=black.Mode())\n        logger_print(\"Formatter Ok.\")\n        # with TemporaryDirectory() as TP:\n        with open(output_path, \"w+\") as f:\n            f.write(result)\n        # do further type checking.\n        # typechecker_input_path = os.path.join(\n        #     TP, base_output_path := os.path.basename(output_path)\n        # )\n        # with open(typechecker_input_path, \"w+\") as f:\n        #     f.write(typechecker_input_path)\n        # output = subprocess.run(\n        #     [\"pyright\", typechecker_input_path],\n        #     capture_output=True,\n        #     encoding=\"utf-8\",\n        # )\n        run_result = pyright_utils.run(\n       ",
        "type": "code",
        "location": "/jinja_utils.py:120-146"
    },
    "229": {
        "file_id": 16,
        "content": "Writes formatted code to output file, optionally formats again if not needed format, and performs additional type checking.",
        "type": "comment"
    },
    "230": {
        "file_id": 16,
        "content": "     output_path, capture_output=True, encoding=\"utf-8\"\n        )\n        typeErrors = [\n            e.strip().replace(\n                os.path.basename(output_path), os.path.basename(tmp_output_path)\n            )\n            for e in re.findall(\n                pyright_utils.errorRegex, run_result.stdout, re.MULTILINE\n            )\n        ]\n        # breakpoint()\n        if run_result.stderr:\n            typeErrors.append(\"\")\n            typeErrors.append(f\"Pyright error:\\n{run_result.stderr}\")\n        if typeErrors:\n            typeErrors.insert(0, f\"Type error found in file {repr(output_path)}\")\n            raise Exception(f\"\\n{' '*4}\".join(typeErrors))\n        logger_print(\"Pyright Ok.\")\n        os.remove(tmp_output_path)\n    except:\n        import traceback\n        traceback.print_exc()\n        # os.remove(tmp_output_path)\n        with open(output_path, \"w+\") as f:\n            f.write(backup_content)\n        # ref: https://www.geeksforgeeks.org/python-os-utime-method/\n        # do not set this to 0 or so",
        "type": "code",
        "location": "/jinja_utils.py:146-173"
    },
    "231": {
        "file_id": 16,
        "content": "This code is executing a type check on a Python file and handling any errors produced by the pyright linter. It first creates a temporary output path, captures all standard error messages, converts these messages to a list of strings, appends Pyright error content if applicable, and then raises an exception with the compiled error messages. If there are no errors, it prints \"Pyright Ok.\" Finally, if an error occurs during execution, it catches the error, prints the stack trace, writes the backup content into the output file, and removes the temporary output file.",
        "type": "comment"
    },
    "232": {
        "file_id": 16,
        "content": "mething. will cause error.\n        os.utime(\n            output_path,\n            times=(\n                os.path.getatime(template_path) - 1000000,\n                os.path.getmtime(template_path) - 1000000,\n            ),\n        )  # to make this older than template, must update!\n        raise Exception(\n            f\"Code check failed.\\nTemporary cache saved to: '{tmp_output_path}'\"\n        )\n    logger_print(\"=\" * 40)\ndef lstrip(string: str):\n    lines = string.split(\"\\n\")\n    result_lines = []\n    for line in lines:\n        result_lines.append(line.lstrip())\n        # if stripped_line := line.lstrip():\n        # result_lines.append(stripped_line)\n    result = \"\\n\".join(result_lines).strip(\"\\n\")\n    return result\ndef code_and_template_path(base_name):\n    code_path = f\"{base_name}.py\"\n    template_path = f\"{code_path}.j2\"\n    return code_path, template_path\ndef load_template(template_path, extra_func_dict={}):\n    try:\n        assert template_path.endswith(\".j2\")\n    except:\n        Exception(f\"jinja template ",
        "type": "code",
        "location": "/jinja_utils.py:173-209"
    },
    "233": {
        "file_id": 16,
        "content": "The code is checking if the output file is older than the template, and if not, it raises an exception. It also includes functions for string lstrip operation, handling code and template paths, and loading a Jinja2 template.",
        "type": "comment"
    },
    "234": {
        "file_id": 16,
        "content": "path '{template_path}' is malformed.\")\n    env = jinja2.Environment(\n        loader=jinja2.FileSystemLoader(searchpath=[\"./\", \"../\"]),\n        extensions=[\n            \"jinja2_error.ErrorExtension\",\n            \"jinja2.ext.do\",\n            \"jinja2.ext.loopcontrols\",\n        ],\n        trim_blocks=True,\n        lstrip_blocks=True,\n        # undefined=jinja2.StrictUndefined,\n        undefined=NeverUndefined,\n    )\n    tpl = env.get_template(template_path)\n    # def myJoin(mstr, mlist):\n    #     logger_print(\"STR:\", repr(mstr))\n    #     logger_print(\"LIST:\", repr(mlist))\n    #     return mstr.join(mlist)\n    func_dict = dict(\n        list=list,\n        str=str,\n        _dict=dict,\n        _set=set,  # avoid name collision\n        tuple=tuple,\n        ord=ord,\n        len=len,\n        repr=repr,\n        c2s=c2s,\n        # s2c=s2c,\n        s2cl=s2cl,\n        s2cu=s2cu,\n        zip=zip,\n        cws=camelize_with_space,\n        lstrip=lstrip,\n        remove_typehint=remove_typehint,\n        kebabize=humps.kebabize,\n        pa",
        "type": "code",
        "location": "/jinja_utils.py:209-245"
    },
    "235": {
        "file_id": 16,
        "content": "Creates a Jinja2 environment with specified settings, loads template from given path.",
        "type": "comment"
    },
    "236": {
        "file_id": 16,
        "content": "scalize=humps.pascalize,\n        # enumerate=enumerate,\n        # eval=eval,\n        # join=myJoin\n        ** extra_func_dict,\n    )\n    tpl.globals.update(func_dict)\n    return tpl\ndef test(cmd: list, exec=\"python3\" if os.name != \"nt\" else \"python\"):\n    cmd = [exec] + cmd\n    p = subprocess.run(cmd)\n    p.check_returncode()",
        "type": "code",
        "location": "/jinja_utils.py:245-258"
    },
    "237": {
        "file_id": 16,
        "content": "This code is defining a function that converts Jinja template variables into executable Python code. It also imports and updates the template's globals with specified functions and executes it using subprocess.",
        "type": "comment"
    },
    "238": {
        "file_id": 17,
        "content": "/keyboard_and_mouse.py",
        "type": "filepath"
    },
    "239": {
        "file_id": 17,
        "content": "The code uses pynput library to set up listeners for keyboard and mouse events, storing them in a list called HIDEvents. It records the event details based on timestep configuration from a config file and writes them to a JSON lines file, but Windows' zooming factor may affect accuracy.",
        "type": "summary"
    },
    "240": {
        "file_id": 17,
        "content": "from datetime import datetime\nfrom pynput import keyboard\nHIDEvents = []\nfrom config import timestep  # this will be sufficient?\n# problem is the windows zooming factor.\n# is it really the problem?\ndef on_press(key):\n    if type(key) != str:\n        key = str(key)\n    HIDEvents.append(('key_press', key))\ndef on_release(key):\n    if type(key) != str:\n        key = str(key)\n    HIDEvents.append(('key_release', key))\nkeyboard_listener = keyboard.Listener(on_press=on_press, on_release=on_release)\nkeyboard_listener.start()\nfrom pynput import mouse\ndef on_move(x: int, y: int):\n    HIDEvents.append((\"mouse_move\", [x, y]))\ndef on_click(x: int, y: int, button: mouse.Button, pressed: bool):\n    HIDEvents.append((\"mouse_click\", [x, y, str(button), pressed]))\ndef on_scroll(x: int, y: int, dx: int, dy: int):\n    HIDEvents.append((\"mouse_scroll\", [x, y, dx, dy]))\n# # ...or, in a non-blocking fashion:\nlistener = mouse.Listener(on_move=on_move, on_click=on_click, on_scroll=on_scroll)\nlistener.start()\n# you may start that non-b",
        "type": "code",
        "location": "/keyboard_and_mouse.py:1-44"
    },
    "241": {
        "file_id": 17,
        "content": "This code sets up listeners for both keyboard and mouse events, storing the event details in a list called HIDEvents. It uses the pynput library to handle input from the keyboard and mouse. The timestep configuration is loaded from the config file to determine how frequently events are recorded. However, there seems to be a problem related to Windows' zooming factor which might affect the accuracy of the recorded events.",
        "type": "comment"
    },
    "242": {
        "file_id": 17,
        "content": "locking. start some looping-forever thread for writing states to file.\nimport time\n# import pyautogui\n# import datetime\nloopCount = 500\nimport jsonlines\nprint(\"RECORDING START\")\nfrom config import filePath\nimport datetime\nworld_start = datetime.datetime.now()\nwith jsonlines.open(filePath, 'w') as w:\n    for _ in range(loopCount):\n        time.sleep(timestep)\n        # as for screenshot, use mss instead of screenshot.\n        #     screenshot = pyautogui.screenshot()\n        # shall you mark the time here.\n        state = dict(HIDEvents=HIDEvents)  # also the image!\n        print(\"STATE?\", state)\n        w.write(state)\n        HIDEvents = []\n        mouseloc = []",
        "type": "code",
        "location": "/keyboard_and_mouse.py:44-68"
    },
    "243": {
        "file_id": 17,
        "content": "Starts a looping-forever thread for writing states to file. Imports required modules, sets the loop count, and opens a JSON lines file for writing. Within the loop, it waits for a certain period (timestep), captures the current state (HIDEvents dictionary), writes it to the file, and resets the HIDEvents and mouseloc variables.",
        "type": "comment"
    },
    "244": {
        "file_id": 18,
        "content": "/launch_docker_devicemapper_limit_storage.sh",
        "type": "filepath"
    },
    "245": {
        "file_id": 18,
        "content": "This code is discussing various storage options for Docker, specifically focusing on the `--storage-opt` flag and how it interacts with different file systems. It mentions that `--storage-opt` is supported only for overlay over xfs with 'pquota' mount option, and provides examples of using different sizes and file systems like devmapper, LVM, ZFS, and vfs.",
        "type": "summary"
    },
    "246": {
        "file_id": 18,
        "content": "# --storage-opt is supported only for overlay over xfs with 'pquota' mount option.\n# change \"data-root\" to somewhere else in /etc/docker/daemon.json.\n# edit /etc/fstab and add our xfs block on new line (find uuid using blkid)\ndocker run  --storage-opt size=10M --rm -it alpine\n# when using devmapper, make sure size is greater than 10G (default)\n# https://docs.docker.com/storage/storagedriver/device-mapper-driver/#configure-direct-lvm-mode-for-production\n# docker run --storage-opt size=11G --rm -it alpine\n# zfs, vfs (not a unionfs, but for testing) supports disk quota.",
        "type": "code",
        "location": "/launch_docker_devicemapper_limit_storage.sh:1-10"
    },
    "247": {
        "file_id": 18,
        "content": "This code is discussing various storage options for Docker, specifically focusing on the `--storage-opt` flag and how it interacts with different file systems. It mentions that `--storage-opt` is supported only for overlay over xfs with 'pquota' mount option, and provides examples of using different sizes and file systems like devmapper, LVM, ZFS, and vfs.",
        "type": "comment"
    },
    "248": {
        "file_id": 19,
        "content": "/launch_streaming_utils.sh",
        "type": "filepath"
    },
    "249": {
        "file_id": 19,
        "content": "Starting script to launch streaming utilities in new tmux sessions.",
        "type": "summary"
    },
    "250": {
        "file_id": 19,
        "content": "bash off_streaming_utils.sh\n# tmux kill-session -t streaming_utils\ngnome-terminal -- bash ubuntu_qemu_utm_arm_record/kali_prepare_dirs_loop.sh\ngnome-terminal -- tmuxp load streaming_utils.yaml",
        "type": "code",
        "location": "/launch_streaming_utils.sh:2-6"
    },
    "251": {
        "file_id": 19,
        "content": "Starting script to launch streaming utilities in new tmux sessions.",
        "type": "comment"
    },
    "252": {
        "file_id": 20,
        "content": "/mouse-and-keyboard-encoding-fft.py",
        "type": "filepath"
    },
    "253": {
        "file_id": 20,
        "content": "The code uses Fast Fourier Transform (FFT) for mouse position encoding, discusses LSTM/GRU neural networks for complex inputs and Fourier transforms, and considers vector space sharing in non-standard ways. It also explores embeddings with token embedding and task type decoding, low-rank adaptation over linear layers for efficiency, and use cases like identifying words/images/actions and positional encodings.",
        "type": "summary"
    },
    "254": {
        "file_id": 20,
        "content": "#!/usr/bin/env python\n# coding: utf-8\n# In[1]:\nimport torch\n# mouse -> sparse encoding -> fft -> ifft -> unified decoder\ndim_0_range = 1000\ndim_1_range = 100\nmouse_coords = [(20,20,None,None), (200,200,30,30)]\n# In[2]:\n# what about sparse encoding?\n# single value -> bunch of binary values\n# elementwise product random vector -> select non-zero ones\nimport random\nrandom.seed(42)\nwindow_size = 200 \nmrange = list(range(window_size+dim_0_range-1))\nrandom.shuffle(mrange)\n# mlist = [mrange[i:i+window_size] for i in range(dim_0_range)]\n# keep it sparse?\nunified_encoding = torch.randn((1,window_size+dim_0_range-1), requires_grad=True)\n# that's how you initialize your \"semantic\" or \"continual\" mouse embeddings.\nmlist = []\nnext_comb = mrange[:window_size]\n# random.shuffle(next_comb)\nmlist.append(next_comb.copy())\nfor i in range(dim_0_range-1):\n#     last_item = mrange[i+window_size-1]\n    alt_item = mrange[i+window_size]\n    last_item_index = random.choice(range(window_size))\n    next_comb[last_item_index] = alt_item\n#     pr",
        "type": "code",
        "location": "/mouse-and-keyboard-encoding-fft.py:1-55"
    },
    "255": {
        "file_id": 20,
        "content": "This code is setting up the mouse coordinates, window size, and creating a sparse encoding for the mouse positions using Fast Fourier Transform (FFT) operations. The code also initializes the unified encoding tensor and starts populating it with random values. It shuffles the range of indices within the window size and appends them to the list 'mlist'.",
        "type": "comment"
    },
    "256": {
        "file_id": 20,
        "content": "int(torch.Tensor([next_comb]))\n#     print(\"SUM?\", sum(next_comb))\n    mlist.append(next_comb.copy())\n# import rich\nprint(\"LENGTH?\", len(mlist))\n# rich.print(\"MLIST?\", mlist)\n# for e in mlist:\n#     print(sum(e))\nmLongTensorList = torch.LongTensor(mlist) # that looks like the thing.\nmLongTensorList.shape\n# In[3]:\ntorch.index_select(unified_encoding, 1, mLongTensorList[0,:])\n# In[4]:\n# how to represent keyboard keydown signals?\n# telephone?\n# embedding plus one trainable sin keydown signal? or using fft?\n# how to represent special tokens? by sin? all by sin?\n# what will happen if you try to share vector space in non-standard way?\n# such as split and concat?\n# you may do split and concat in fft though.\n# such as: value repr by concat -> ifft -> LSTM -> fft -> argmax things\n# ifft let the model \"feel\" the bits, though fft \"extract\" freq and handle bits.\n# there are multiple ways to do this.\n# but fft brings \"imaginary\" part to numbers.\n# you can feed both parts separetely into the network, then combine different",
        "type": "code",
        "location": "/mouse-and-keyboard-encoding-fft.py:55-98"
    },
    "257": {
        "file_id": 20,
        "content": "This code seems to be part of a larger program that involves encoding mouse and keyboard events using Fourier Transform (FFT). It appears to store the encoded events in a list, then create a LongTensorList from it. The author is considering different methods for representing special tokens and discussing the impact of sharing vector spaces in non-standard ways, like split and concat. The code also mentions the use of Fourier Transform for extracting frequency information and handling bits.",
        "type": "comment"
    },
    "258": {
        "file_id": 20,
        "content": " parts.\n# the you may calculate the grad? by adding different part of the loss?\n# or you use \"native\" complex neural networks, to handle the fft transforms.\n# or you simply ignore complex input. only taking real parts?\n# lstm contains hidden state and cell state\n# while GRU only contains hidden state.\n# adding real and imag? or passing through different NN? or same NN?\n# telling you, do it first. we will handle the comparison.\n# so are you going to tell me that my model is just complete\n# that i need not to do too much to collect data and start training?\n# yes. i am going to tell you to start training.\n# you have reached the utopia of fourier transform (rfft/hfft).\n# now let's roll!\n# In[ ]:\n# for ubuntu arm: pyautogui -> python script writing timestamp\n# write to stdout -> pipe to ffmpeg -> write to video\n# find the location of the shared directory of utm\n# how do i know if my model is spitting words instead of images/actions?\n# do we need to take over few \"positional encodings\"?\n# you can add task spec",
        "type": "code",
        "location": "/mouse-and-keyboard-encoding-fft.py:98-129"
    },
    "259": {
        "file_id": 20,
        "content": "The code discusses the use of Fourier transforms in a model, potentially using LSTM or GRU neural networks to handle the complex input. It suggests that the model may not need additional modifications and can start training immediately since it has reached the \"utopia\" of Fourier transform (rfft/hfft). The code also mentions potential use cases for the trained model, like identifying if it's producing words or images/actions, and considering positional encodings.",
        "type": "comment"
    },
    "260": {
        "file_id": 20,
        "content": "ific embeddings with token embedding\n# then decode the task type in the end, classify the token.\n# fft may not be needed, since that will be too much computation.\n# you may just want low rank adaption over some linear layers.\n# fft may be useful for your visual convolution.",
        "type": "code",
        "location": "/mouse-and-keyboard-encoding-fft.py:129-135"
    },
    "261": {
        "file_id": 20,
        "content": "This code snippet is discussing the use of embeddings with token embedding, task type decoding, and possible use of FFT (Fast Fourier Transform) for visual convolution. It also mentions the potential need for low-rank adaptation over linear layers instead of relying on FFT for computation efficiency.",
        "type": "comment"
    },
    "262": {
        "file_id": 21,
        "content": "/mydatamodel.py",
        "type": "filepath"
    },
    "263": {
        "file_id": 21,
        "content": "This code generates a Python class based on the MyDataModel.yaml file, using Pydantic's BaseModel to define the data model classes Data and MyModel.",
        "type": "summary"
    },
    "264": {
        "file_id": 21,
        "content": "# generated by datamodel-codegen:\n#   filename:  mydatamodel.yaml\n#   timestamp: 2023-07-08T05:40:44+00:00\nfrom __future__ import annotations\nfrom pydantic import BaseModel\nclass Data(BaseModel):\n    a: int\n    b: int\nclass MyModel(BaseModel):\n    data: Data",
        "type": "code",
        "location": "/mydatamodel.py:1-16"
    },
    "265": {
        "file_id": 21,
        "content": "This code generates a Python class based on the MyDataModel.yaml file, using Pydantic's BaseModel to define the data model classes Data and MyModel.",
        "type": "comment"
    },
    "266": {
        "file_id": 22,
        "content": "/mydatamodel.yaml",
        "type": "filepath"
    },
    "267": {
        "file_id": 22,
        "content": "This code contains YAML formatted data with two sets of variables: \"data\" and \"data2\". Each set has key-value pairs where the keys are letters (a, b) and values are numbers (1, 2).",
        "type": "summary"
    },
    "268": {
        "file_id": 22,
        "content": "data:\n  a: 1\n  b: 2\n# ---\n# data2:\n#   a: 2\n#   b: 3\n#   d: 4",
        "type": "code",
        "location": "/mydatamodel.yaml:1-10"
    },
    "269": {
        "file_id": 22,
        "content": "This code contains YAML formatted data with two sets of variables: \"data\" and \"data2\". Each set has key-value pairs where the keys are letters (a, b) and values are numbers (1, 2).",
        "type": "comment"
    },
    "270": {
        "file_id": 23,
        "content": "/mypy_check.py",
        "type": "filepath"
    },
    "271": {
        "file_id": 23,
        "content": "The code uses mock testing, lru_cached, and API functions for verification. It defines a class \"MyClass\" with properties age, factors (commented), my_list, and creates a sample tensor function.",
        "type": "summary"
    },
    "272": {
        "file_id": 23,
        "content": "import mypy.api as api\n# you may use mock testing, similar to symbolic execution.\n# you may ensure compatibility between non-mock based operation, or ensure all functions are mock calls.\n# mock functions shall be lru_cached, to speedup overheads.\nresult = api.run(...)  # commandline args.\nimport tensorflow as tf\nfrom tensor_annotations import axes # by deepmind.\nimport tensor_annotations.tensorflow as ttf\nfrom typing import NewType, List\nfrom typing_extensions import Annotated\nuint8 = ttf.uint8\nBatch, Time = Annotated[axes.Batch, 3], Annotated[axes.Time, 5] # problem is, how to share this along with function calls?\nMyAxis = NewType(\"MyAxis\", axes.Axis)\n# from pycontract import contract\n# @contract\n# def my_function(a, b):\n#     \"\"\" Function description.\n#         :type a: int,>0\n#         :type b: list[N],N>0\n#         :rtype: list[N]\n#     \"\"\"\n#     ...\n# def sample_batch() -> ttf.Tensor2[uint8, Time, Batch]:\n#     return tf.zeros((3, 5))\nfrom typing_extensions import Annotated\nfrom annotated_types import Gt,",
        "type": "code",
        "location": "/mypy_check.py:1-39"
    },
    "273": {
        "file_id": 23,
        "content": "Importing the mypy.api as api.\nMock testing can be used for verification and compatibility checking between mock-based and non-mock operations. \nUsing lru_cached to speed up overheads for mock functions.\nCalling the api.run function with command line arguments. \nImporting TensorFlow and tensor_annotations.axes from DeepMind.\nUsing Annotated type from typing_extensions to define Batch and Time axes.\nDefining a new type, MyAxis, using NewType from typing_extensions.\nImporting pycontract for code contract implementation.\nDefining the my_function with its parameters and return types.\nCreating sample_batch function that returns a tensor of type ttf.Tensor2[uint8, Time, Batch]. \nUsing Annotated type from typing_extensions to define Gt type.",
        "type": "comment"
    },
    "274": {
        "file_id": 23,
        "content": " Len, Predicate\nclass MyClass:\n    age: Annotated[int, Gt(18)]                         # Valid: 19, 20, ...\n                                                        # Invalid: 17, 18, \"19\", 19.0, ...\n    # factors: List[Annotated[int, Predicate(is_prime)]]  # Valid: 2, 3, 5, 7, 11, ...\n    #                                                     # Invalid: 4, 8, -2, 5.0, \"prime\", ...\n    my_list: Annotated[List[int], Len(0, 10)]           # Valid: [], [10, 20, 30, 40, 50]\n                                                        # Invalid: (1, 2), [\"abc\"], [0] * 20",
        "type": "code",
        "location": "/mypy_check.py:39-48"
    },
    "275": {
        "file_id": 23,
        "content": "The code defines a class \"MyClass\" with properties age, factors (commented out), and my_list. Age is valid if greater than 18, factors is supposed to be a list of prime numbers but commented out, and my_list is a list of integers between 0 and 10 length.",
        "type": "comment"
    },
    "276": {
        "file_id": 24,
        "content": "/off_streaming_utils.sh",
        "type": "filepath"
    },
    "277": {
        "file_id": 24,
        "content": "Killing streaming_utils session and related processes.\n\nQuestion (0-1): Can you provide a brief explanation of what the code does?",
        "type": "summary"
    },
    "278": {
        "file_id": 24,
        "content": "tmux kill-session -t streaming_utils\nps aux | grep bash | grep -v grep | grep kali_prepare_dirs_loop.sh | awk '{print $2}' | xargs -iabc kill -s TERM abc\ntmux kill-session -t kali_prepare_two_webdav_dirs\n# location of ubuntu vm: 10.0.2.15",
        "type": "code",
        "location": "/off_streaming_utils.sh:1-5"
    },
    "279": {
        "file_id": 24,
        "content": "Killing streaming_utils session and related processes.\n\nQuestion (0-1): Can you provide a brief explanation of what the code does?",
        "type": "comment"
    },
    "280": {
        "file_id": 25,
        "content": "/packup.cmd",
        "type": "filepath"
    },
    "281": {
        "file_id": 25,
        "content": "This code is archiving the \"agi_computer_control\" directory, removing the original 7z file, and moving a backup copy into the directory.",
        "type": "summary"
    },
    "282": {
        "file_id": 25,
        "content": "rm agi_computer_control.7z\ncd ..\n7z a -snl agi_computer_control.7z agi_computer_control\ncd agi_computer_control\nmv ../agi_computer_control.7z .",
        "type": "code",
        "location": "/packup.cmd:1-5"
    },
    "283": {
        "file_id": 25,
        "content": "This code is archiving the \"agi_computer_control\" directory, removing the original 7z file, and moving a backup copy into the directory.",
        "type": "comment"
    },
    "284": {
        "file_id": 26,
        "content": "/packup.sh",
        "type": "filepath"
    },
    "285": {
        "file_id": 26,
        "content": "Removing file, changing directory, archiving files with 7-Zip, and moving file into place.",
        "type": "summary"
    },
    "286": {
        "file_id": 26,
        "content": "rm agi_computer_control.7z\ncd ..\n7z a -snl agi_computer_control.7z agi_computer_control\ncd agi_computer_control\nmv ../agi_computer_control.7z .",
        "type": "code",
        "location": "/packup.sh:1-5"
    },
    "287": {
        "file_id": 26,
        "content": "Removing file, changing directory, archiving files with 7-Zip, and moving file into place.",
        "type": "comment"
    },
    "288": {
        "file_id": 27,
        "content": "/player.py",
        "type": "filepath"
    },
    "289": {
        "file_id": 27,
        "content": "The code uses Pynput to control keyboard/mouse, handles DPI-awareness on Windows and initializes via hotkeys. It maintains event order but lacks \"ctrl + /\" handling, supporting various actions for both keyboard and mouse input.",
        "type": "summary"
    },
    "290": {
        "file_id": 27,
        "content": "# just to play the recorded events out.\n# not doing anything beyond that.\n# special keys are not recorded. what a shame.\nimport ast\nimport os\n# what about \"ctrl + /\" ?\ndef unshift(key):\n    lower_keycodes = {\n        \"A\": \"a\",\n        \"B\": \"b\",\n        \"C\": \"c\",\n        \"D\": \"d\",\n        \"E\": \"e\",\n        \"F\": \"f\",\n        \"G\": \"g\",\n        \"H\": \"h\",\n        \"I\": \"i\",\n        \"J\": \"j\",\n        \"K\": \"k\",\n        \"L\": \"l\",\n        \"M\": \"m\",\n        \"N\": \"n\",\n        \"O\": \"o\",\n        \"P\": \"p\",\n        \"Q\": \"q\",\n        \"R\": \"r\",\n        \"S\": \"s\",\n        \"T\": \"t\",\n        \"U\": \"u\",\n        \"V\": \"v\",\n        \"W\": \"w\",\n        \"X\": \"x\",\n        \"Y\": \"y\",\n        \"Z\": \"z\",\n    }\n    unshift_keycodes = {\n        \"!\": \"1\",\n        \"@\": \"2\",\n        \"#\": \"3\",\n        \"$\": \"4\",\n        \"%\": \"5\",\n        \"^\": \"6\",\n        \"&\": \"7\",\n        \"*\": \"8\",\n        \"(\": \"9\",\n        \")\": \"0\",\n        \"_\": \"-\",\n        \"+\": \"=\",\n        \"{\": \"[\",\n        \"}\": \"]\",\n        \"|\": \"\\\\\",\n        \":\": \";\",\n        '\"': \"'\",\n        \"<\": \",\",\n        \">\": \".\",\n    ",
        "type": "code",
        "location": "/player.py:1-60"
    },
    "291": {
        "file_id": 27,
        "content": "The code defines a dictionary of lower and unshift keycodes, allowing for the conversion between them. It also mentions that special keys like \"ctrl + /\" are not recorded, which is a limitation in the system.",
        "type": "comment"
    },
    "292": {
        "file_id": 27,
        "content": "    \"?\": \"/\",\n        \"~\": \"`\",\n    }\n    ctrl_keycodes = {\n        \"\\x01\": \"a\",\n        \"\\x02\": \"b\",\n        \"\\x03\": \"c\",\n        \"\\x04\": \"d\",\n        \"\\x05\": \"e\",\n        \"\\x06\": \"f\",\n        \"\\x07\": \"g\",\n        \"\\x08\": \"h\",\n        \"\\t\": \"i\",\n        \"\\n\": \"j\",\n        \"\\x0b\": \"k\",\n        \"\\x0c\": \"l\",\n        \"\\r\": \"m\",\n        \"\\x0e\": \"n\",\n        \"\\x0f\": \"o\",\n        \"\\x10\": \"p\",\n        \"\\x11\": \"q\",\n        \"\\x12\": \"r\",\n        \"\\x13\": \"s\",\n        \"\\x14\": \"t\",\n        \"\\x15\": \"u\",\n        \"\\x16\": \"v\",\n        \"\\x17\": \"w\",\n        \"\\x18\": \"x\",\n        \"\\x19\": \"y\",\n        \"\\x1a\": \"z\",\n        \"<219>\": \"[\",\n        \"<221>\": \"]\",\n        \"<189>\": \"-\",\n        \"<187>\": \"=\",\n        \"<192>\": \"`\",\n        \"<48>\": \"0\",\n        \"<49>\": \"1\",\n        \"<50>\": \"2\",\n        \"<51>\": \"3\",\n        \"<52>\": \"4\",\n        \"<53>\": \"5\",\n        \"<54>\": \"6\",\n        \"<55>\": \"7\",\n        \"<56>\": \"8\",\n        \"<57>\": \"9\",\n        \"<220>\": \"\\\\\",\n        \"<186>\": \";\",\n        \"<222>\": \"'\",\n        \"<188>\": \",\",\n        \"<190>\": \".\",\n        \"<191>\": \"/",
        "type": "code",
        "location": "/player.py:60-110"
    },
    "293": {
        "file_id": 27,
        "content": "This code defines two dictionaries: one for special characters and another for keyboard keycodes. It maps each keycode to its corresponding character in ASCII format.",
        "type": "comment"
    },
    "294": {
        "file_id": 27,
        "content": "\",\n    }\n    key = unshift_keycodes.get(\n        key, ctrl_keycodes.get(key, lower_keycodes.get(key, key))\n    )\n    return key\n# how to play that?\n# using jsonl?\n# timestep = 0.01\nfrom config import timestep\n# zoom_factor = 1.75\n# you can safely ignore the zoom factor once using this in the reference:\n# https://pynput.readthedocs.io/en/latest/mouse.html#monitoring-the-mouse\nimport os\n# main problem is the hotkey. but the modifiers are certain.\n# you can know that for sure.\nif os.name == \"nt\":\n    import ctypes\n    PROCESS_PER_MONITOR_DPI_AWARE = 2\n    ctypes.windll.shcore.SetProcessDpiAwareness(PROCESS_PER_MONITOR_DPI_AWARE)\n# better use pyautogui for mouse?\nimport jsonlines\nimport time\nimport pynput\nimport pyautogui\n# filePath = \"states.jsonl\"\nfrom config import filePath\nwith jsonlines.open(filePath) as r:\n    stateList = list(r.iter())\n# import math\nkeyboard_controller = pynput.keyboard.Controller()\nmouse_controller = pynput.mouse.Controller()\nmouse_buttons = [\n    pynput.mouse.Button.left, pynput.mouse.Button.righ",
        "type": "code",
        "location": "/player.py:110-153"
    },
    "295": {
        "file_id": 27,
        "content": "This code is initializing a keyboard and mouse controller using the pynput library. It also handles DPI awareness for Windows systems, reads a JSONL file containing states, and initializes a mouse controller which can be controlled by hotkeys. The zoom factor is not important once the reference is used.",
        "type": "comment"
    },
    "296": {
        "file_id": 27,
        "content": "t, pynput.mouse.Button.middle\n]\nmouse_button_states = {button: False for button in mouse_buttons}\nfor state in stateList:\n    time.sleep(timestep)\n    # perform actions.\n    HIDEvents = state[\"HIDEvents\"]\n    # you need to preserve the order. dump all events into one single list.\n    for action_type, action_args in HIDEvents:\n        print(\"ACTION?\", action_type, action_args)\n        if action_type == \"key_press\":\n            if not action_args.startswith(\"Key.\"):\n                keycode = unshift(\n                    action_args if action_args.startswith(\"<\")\n                    and action_args.endswith(\">\") else ast.literal_eval(action_args)\n                )\n                pyautogui.write(keycode)\n            else:\n                keyboard_controller.press(\n                    pynput.keyboard.Key.__dict__[action_args.split(\".\")[-1]]\n                )\n        elif action_type == \"key_release\":\n            if action_args.startswith(\"Key.\"):\n                keyboard_controller.release(\n                    py",
        "type": "code",
        "location": "/player.py:153-179"
    },
    "297": {
        "file_id": 27,
        "content": "This code handles key and mouse events from a state list, preserving their order. It uses Pynput for keyboard and mouse controls, and PyAutoGUI for writing keys. It processes \"key_press\" and \"key_release\" events while also handling mouse button states.",
        "type": "comment"
    },
    "298": {
        "file_id": 27,
        "content": "nput.keyboard.Key.__dict__[action_args.split(\".\")[-1]]\n                )\n        elif action_type == \"mouse_move\":\n            x, y = action_args\n            # x = math.floor(x/zoom_factor)\n            # y = math.floor(y/zoom_factor)\n            mouse_controller.position = (x, y)\n        elif action_type == \"mouse_click\":\n            x, y, button, pressed = action_args\n            # x = math.floor(x/zoom_factor)\n            # y = math.floor(y/zoom_factor)\n            button = pynput.mouse.Button.__dict__[button.split(\".\")[-1]]\n            mouse_button_states[button] = pressed\n            mouse_controller.position = (x, y)\n            if pressed:\n                mouse_controller.press(button)\n            else:\n                mouse_controller.click(button)\n        elif action_type == \"mouse_scroll\":\n            x, y, dx, dy = action_args\n            # x = math.floor(x/zoom_factor)\n            # y = math.floor(y/zoom_factor)\n            # dx = math.floor(dx/zoom_factor)\n            # dy = math.floor(dy/zoom_fa",
        "type": "code",
        "location": "/player.py:179-204"
    },
    "299": {
        "file_id": 27,
        "content": "Code handles different types of actions related to keyboard and mouse input.\n\n- Keyboard action: Executes the corresponding keypress using pynput library.\n- Mouse move action: Updates the position of the mouse controller.\n- Mouse click action: Handles mouse button press or click based on pressed state.\n- Mouse scroll action: Not fully implemented due to zoom_factor calculation missing.",
        "type": "comment"
    }
}