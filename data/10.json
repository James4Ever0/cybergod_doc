{
    "1000": {
        "file_id": 134,
        "content": " CMD + LEN + DATA + bytes([SUM])  # 数据包\n            self.port.write(packet)  # 将命令代码写入串口\n            # return True  # 如果成功，则返回True，否则引发异常\n        def checksum(\n            self,\n            HEAD_add_hex_list: int,\n            ADDR: bytes,\n            CMD: bytes,\n            LEN: bytes,\n            DATA_add_hex_list: int,\n        ):\n            try:\n                SUM = (\n                    sum(\n                        [\n                            HEAD_add_hex_list,\n                            int.from_bytes(ADDR, byteorder=\"big\"),\n                            int.from_bytes(CMD, byteorder=\"big\"),\n                            int.from_bytes(LEN, byteorder=\"big\"),\n                            DATA_add_hex_list,\n                        ]\n                    )\n                    % 256\n                )  # 校验和\n            except Exception as e:\n                print(\"int too big to convert\")\n                raise e\n                # return False\n            return SUM\n    @beartype\n    class Multimedia(CH9329Util):\n    ",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_control.py:404-437"
    },
    "1001": {
        "file_id": 134,
        "content": "Function sends a command packet to the device via serial port, and calculates checksum for each data packet.",
        "type": "comment"
    },
    "1002": {
        "file_id": 134,
        "content": "    def send_data(self, keys: Union[List[ACPIKey], List[MultimediaKey]] = []):\n            if len(keys) == 0:  # clear all multimedia keys.\n                Multimedia.send_data(keys=[ACPIKey.Null])\n                Multimedia.send_data(keys=[MultimediaKey.Null])\n                return\n            isMultimediaKeys = is_bearable(keys, List[MultimediaKey])\n            CMD = b\"\\x03\"  # 命令\n            LEN = b\"\\x04\" if isMultimediaKeys else b\"\\x02\"  # 数据长度\n            byte_length = 3 if isMultimediaKeys else 1\n            key_code = reduce_flags_to_bytes(keys, byte_length=byte_length)\n            DATA = (b\"\\x02\" if isMultimediaKeys else b\"\\x01\") + key_code  # 数据\n            self.communicate(DATA, CMD, LEN)\n        def release(self):\n            self.send_data()\n    # ref: https://github.com/beijixiaohu/CH9329_COMM\n    @beartype\n    class Keyboard(CH9329Util):\n        # def __init__(\n        #     self,\n        #     port: serial.Serial,\n        # ):\n        #     self.port = port\n        def send_data(\n            ",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_control.py:437-466"
    },
    "1003": {
        "file_id": 134,
        "content": "The code defines a class named \"Keyboard\" that communicates with a serial device. The `send_data()` method sends data to the device, and the `release()` method calls `send_data()` without any parameters to release all keys. The `is_bearable()` function determines if the input is a list of MultimediaKeys. The code also uses `reduce_flags_to_bytes()`, `b\"\\x03\"`, `b\"\\x04\"`, and `b\"\\x02\"` for command, data length, and flag reduction operations.",
        "type": "comment"
    },
    "1004": {
        "file_id": 134,
        "content": "self,\n            # [ControlCode.NULL] or [], both works\n            control_codes: List[ControlCode] = [ControlCode.NULL],\n            key_literals: Annotated[\n                List[HIDActionTypes.keys], Is[lambda l: len(l) <= 8 and len(l) >= 0]\n            ] = [],\n        ):\n            # 将字符转写为数据包\n            # HEAD = b\"\\x57\\xAB\"  # 帧头\n            # ADDR = b\"\\x00\"  # 地址\n            CMD = b\"\\x02\"  # 命令\n            LEN = b\"\\x08\"  # 数据长度\n            DATA = b\"\"  # 数据\n            # 控制键\n            # control_byte = reduce_flags_to_bytes(control_codes)\n            control_byte = reduce_flags_to_bytes(control_codes, byte_length=1)\n            DATA += control_byte\n            # if ctrl == '':\n            #     DATA += b'\\x00'\n            # elif isinstance(ctrl, int):\n            #     DATA += bytes([ctrl])\n            # else:\n            #     DATA += self.control_button_hex_dict[ctrl]\n            # DATA固定码\n            DATA += b\"\\x00\"\n            # 读入data\n            # for i in range(0, len(data), 2):\n            #    ",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_control.py:466-496"
    },
    "1005": {
        "file_id": 134,
        "content": "This code is defining a function that converts input data into a data package. It initializes variables for the frame header, address, command, and length of the data. The control_byte variable is created from the provided control_codes using reduce_flags_to_bytes(). The function then appends the control_byte to the DATA variable. If the 'ctrl' variable is empty or an integer, it adds the corresponding bytes to DATA. Finally, it appends a fixed value of 0x00 to the end of DATA and prepares for reading the data in increments of two.",
        "type": "comment"
    },
    "1006": {
        "file_id": 134,
        "content": " DATA += self.normal_button_hex_dict[data[i:i + 2]]\n            for key_literal in key_literals:\n                DATA += KeyLiteralToKCOMKeycode(key_literal)\n            self.communicate(DATA, CMD, LEN)\n            # if len(DATA) < 8:\n            #     DATA += b\"\\x00\" * (8 - len(DATA))\n            # else:\n            #     DATA = DATA[:8]\n            # # 分离HEAD中的值，并计算和\n            # HEAD_hex_list = []\n            # for byte in HEAD:\n            #     HEAD_hex_list.append(byte)\n            # HEAD_add_hex_list = sum(HEAD_hex_list)\n            # # 分离DATA中的值，并计算和\n            # DATA_hex_list = []\n            # for byte in DATA:\n            #     DATA_hex_list.append(byte)\n            # DATA_add_hex_list = sum(DATA_hex_list)\n            # #\n            # try:\n            #     SUM = (\n            #         sum(\n            #             [\n            #                 HEAD_add_hex_list,\n            #                 int.from_bytes(ADDR, byteorder=\"big\"),\n            #                 int.from_bytes(CMD, byteorder=\"b",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_control.py:496-524"
    },
    "1007": {
        "file_id": 134,
        "content": "Appending button hex codes and key literals to data.\nSending data to communicate with hardware.\nCalculating checksum for head and data sections.",
        "type": "comment"
    },
    "1008": {
        "file_id": 134,
        "content": "ig\"),\n            #                 int.from_bytes(LEN, byteorder=\"big\"),\n            #                 DATA_add_hex_list,\n            #             ]\n            #         )\n            #         % 256\n            #     )  # 校验和\n            # except OverflowError:\n            #     raise Exception(\"int too big to convert\")\n            #     # return False\n            # packet = HEAD + ADDR + CMD + LEN + DATA + bytes([SUM])  # 数据包\n            # self.port.write(packet)  # 将命令代码写入串口\n            # # return True  # 如果成功，则返回True，否则引发异常\n        def release(self):\n            self.send_data()\n    # keyboard = ch9329Comm.keyboard.DataComm()\n    keyboard = Keyboard(port=ser)  # TODO: multimedia key support\n    # pass int to override.\n    @beartype\n    class Mouse(CH9329Util, ch9329Comm.mouse.DataComm):\n        def __init__(\n            self, port: serial.Serial, screen_width: pos_int, screen_height: pos_int\n        ):\n            # self.port = port\n            initargs = dict(screen_width=screen_width, screen_height=s",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_control.py:524-551"
    },
    "1009": {
        "file_id": 134,
        "content": "def send_data(self):\n    # Sends data to the hardware capture device.\n    pass",
        "type": "comment"
    },
    "1010": {
        "file_id": 134,
        "content": "creen_height)\n            super().__init__(port=port, **initargs)\n            self.super_instance = ch9329Comm.mouse.DataComm(**initargs)\n        # TODO: scroll support\n        def assert_inbound(self, x: non_neg_int, y: non_neg_int):\n            assert x <= self.X_MAX, f\"exceeding x limit ({self.X_MAX}): {x}\"\n            assert y <= self.Y_MAX, f\"exceeding y limit ({self.Y_MAX}): {y}\"\n        def get_ctrl(\n            self, x: int, y: int, button_codes: List[MouseButton], inbound: bool\n        ) -> int:\n            if inbound:\n                self.assert_inbound(x, y)\n            ctrl: int = reduce_flags_to_bytes(button_codes, byte_length=1)\n            return ctrl\n        def call_super_method(\n            self,\n            funcName: str,\n            x: int,\n            y: int,\n            button_codes: List[MouseButton] = [MouseButton.NULL],\n            inbound: bool = True,\n            use_super_instance: bool = False,\n        ):\n            ctrl = self.get_ctrl(x, y, button_codes, inbound=inbound)\n      ",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_control.py:551-579"
    },
    "1011": {
        "file_id": 134,
        "content": "This code appears to be a part of a class that controls mouse movements and button presses. The `assert_inbound` function checks if the given coordinates are within the maximum limits, while the `get_ctrl` function converts a list of button codes into a single byte value. The `call_super_method` function seems to be a wrapper for calling a superclass method with optional mouse movement and button parameters. However, there is currently no support for scroll functionality (indicated by the TODO comment).",
        "type": "comment"
    },
    "1012": {
        "file_id": 134,
        "content": "      ret = (\n                self.super_instance\n                if use_super_instance\n                else getattr(super(), funcName)\n            )(x, y, ctrl=ctrl, port=self.port)\n            if ret == False:\n                raise Exception(\"Error calling super method: {}\".format(funcName))\n        def send_data_absolute(\n            self,\n            x: non_neg_int,\n            y: non_neg_int,\n            scroll: movement,\n            button_codes: List[MouseButton] = [MouseButton.NULL],\n        ):\n            ctrl = self.get_ctrl(x, y, button_codes=button_codes, inbound=True)\n            # currentFuncName = inspect.currentframe().f_code.co_name\n            # self.call_super_method(currentFuncName, x, y, button_codes)\n            # 将字符转写为数据包\n            # HEAD = b\"\\x57\\xAB\"  # 帧头\n            # ADDR = b\"\\x00\"  # 地址\n            CMD = b\"\\x04\"  # 命令\n            LEN = b\"\\x07\"  # 数据长度\n            DATA = bytearray(b\"\\x02\")  # 数据\n            # 鼠标按键\n            # if ctrl == \"\":\n            #     DATA.append(0)\n     ",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_control.py:579-608"
    },
    "1013": {
        "file_id": 134,
        "content": "This code defines a class method to send data to an absolute position on the screen by specifying x and y coordinates, scroll direction, and button codes. It first determines the control based on the provided parameters and then constructs a message with frame header, address, command, length, and data fields to be sent. If there is an error calling the superclass method, it raises an exception.",
        "type": "comment"
    },
    "1014": {
        "file_id": 134,
        "content": "       # elif isinstance(ctrl, int):\n            DATA.append(ctrl)\n            # else:\n            #     DATA += self.hex_dict[ctrl]\n            # 坐标\n            X_Cur = (4096 * x) // self.X_MAX\n            Y_Cur = (4096 * y) // self.Y_MAX\n            DATA += X_Cur.to_bytes(2, byteorder=\"little\")\n            DATA += Y_Cur.to_bytes(2, byteorder=\"little\")\n            DATA += get_scroll_code(scroll)\n            self.communicate(bytes(DATA), CMD, LEN)\n            # if len(DATA) < 7:\n            #     DATA += b\"\\x00\" * (7 - len(DATA))\n            # else:\n            #     DATA = DATA[:7]\n            # # 分离HEAD中的值，并计算和\n            # HEAD_hex_list = list(HEAD)\n            # HEAD_add_hex_list = sum(HEAD_hex_list)\n            # # 分离DATA中的值，并计算和\n            # DATA_hex_list = list(DATA)\n            # DATA_add_hex_list = sum(DATA_hex_list)\n            # try:\n            #     SUM = (\n            #         sum(\n            #             [\n            #                 HEAD_add_hex_list,\n            #                 int.fro",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_control.py:608-640"
    },
    "1015": {
        "file_id": 134,
        "content": "This code appears to be part of a larger program, likely responsible for handling some type of input and converting it into data that can be communicated over a hardware interface. The code block checks if the 'ctrl' input is an integer and adds it to a list called 'DATA'. It then calculates X and Y coordinates based on given values and appends their byte representation to the 'DATA' list. Lastly, it calls a function named 'get_scroll_code' with another argument 'scroll' and appends the result to the 'DATA' list before calling another function named 'communicate'. The rest of the code is unfinished or unclear in its purpose.",
        "type": "comment"
    },
    "1016": {
        "file_id": 134,
        "content": "m_bytes(ADDR, byteorder=\"big\"),\n            #                 int.from_bytes(CMD, byteorder=\"big\"),\n            #                 int.from_bytes(LEN, byteorder=\"big\"),\n            #                 DATA_add_hex_list,\n            #             ]\n            #         )\n            #         % 256\n            #     )  # 校验和\n            # except OverflowError:\n            #     raise Exception(\"int too big to convert\")\n            # packet = HEAD + ADDR + CMD + LEN + DATA + bytes([SUM])  # 数据包\n            # self.port.write(packet)  # 将命令代码写入串口\n            # # return True  # 如果成功，则返回True，否则引发异常\n        def send_data_relatively(\n            self,\n            x: int,\n            y: int,\n            scroll: movement,\n            button_codes: List[MouseButton] = [MouseButton.NULL],\n        ):\n            ctrl = self.get_ctrl(x, y, button_codes=button_codes, inbound=False)\n            # currentFuncName = inspect.currentframe().f_code.co_name\n            # self.call_super_method(currentFuncName, x, y,\n            #  ",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_control.py:640-664"
    },
    "1017": {
        "file_id": 134,
        "content": "This code is sending control data to hardware, including address (ADDR), command (CMD), length (LEN), data (DATA), and sum (SUM) in the form of a packet. If any integer value is too big to convert, it raises an exception. The function sends this data-related information to a port using write() method.",
        "type": "comment"
    },
    "1018": {
        "file_id": 134,
        "content": "                      button_codes, inbound=False)\n            # 将字符转写为数据包\n            # HEAD = b\"\\x57\\xAB\"  # 帧头\n            # ADDR = b\"\\x00\"  # 地址\n            CMD = b\"\\x05\"  # 命令\n            LEN = b\"\\x05\"  # 数据长度\n            DATA = bytearray(b\"\\x01\")  # 数据\n            # 鼠标按键\n            # if ctrl == \"\":\n            #     DATA.append(0)\n            # elif isinstance(ctrl, int):\n            DATA.append(ctrl)\n            # else:\n            #     DATA += self.hex_dict[ctrl]\n            # x坐标\n            if x == 0:\n                DATA.append(0)\n            elif x < 0:\n                DATA += (0 - abs(x)).to_bytes(1, byteorder=\"big\", signed=True)\n            else:\n                DATA += x.to_bytes(1, byteorder=\"big\", signed=True)\n            # y坐标，这里为了符合坐标系直觉，将<0改为向下，>0改为向上\n            # y = - y\n            # change your ass.\n            # after doing this, we shall perform unittests, to ensure its integrity.\n            if y == 0:\n                DATA.append(0)\n            elif y < 0:\n                DATA += (0 -",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_control.py:664-696"
    },
    "1019": {
        "file_id": 134,
        "content": "Converting string command to HID data packet.\nBuilding HID data packet with mouse button, x and y coordinates.",
        "type": "comment"
    },
    "1020": {
        "file_id": 134,
        "content": " abs(y)).to_bytes(1, byteorder=\"big\", signed=True)\n            else:\n                DATA += y.to_bytes(1, byteorder=\"big\", signed=True)\n            DATA += get_scroll_code(scroll)\n            DATA += b\"\\x00\" * (5 - len(DATA)) if len(DATA) < 5 else DATA[:5]\n            self.communicate(bytes(DATA), CMD, LEN)\n            # # 分离HEAD中的值，并计算和\n            # HEAD_hex_list = list(HEAD)\n            # HEAD_add_hex_list = sum(HEAD_hex_list)\n            # # 分离DATA中的值，并计算和\n            # DATA_hex_list = list(DATA)\n            # DATA_add_hex_list = sum(DATA_hex_list)\n            # try:\n            #     SUM = (\n            #         sum(\n            #             [\n            #                 HEAD_add_hex_list,\n            #                 int.from_bytes(ADDR, byteorder=\"big\"),\n            #                 int.from_bytes(CMD, byteorder=\"big\"),\n            #                 int.from_bytes(LEN, byteorder=\"big\"),\n            #                 DATA_add_hex_list,\n            #             ]\n            #         )\n        ",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_control.py:696-724"
    },
    "1021": {
        "file_id": 134,
        "content": "The code is preparing a byte array for communication with the hardware. It checks if the value of y is negative, converts it to a signed big endian byte, adds scroll-related data, and pads the byte array to be exactly 5 bytes long before communicating it. Additionally, there is commented out code that calculates and sums the hex values from HEAD and DATA arrays.",
        "type": "comment"
    },
    "1022": {
        "file_id": 134,
        "content": "    #         % 256\n            #     )  # 校验和\n            # except OverflowError:\n            #     raise Exception(\"int too big to convert\")\n            # packet = HEAD + ADDR + CMD + LEN + DATA + bytes([SUM])  # 数据包\n            # self.port.write(packet)  # 将命令代码写入串口\n            # # return True  # 如果成功，则返回True，否则引发异常\n        def move_to_basic(\n            self,\n            x: non_neg_int,\n            y: non_neg_int,\n            button_codes: List[MouseButton] = [MouseButton.NULL],\n        ):\n            currentFuncName = inspect.currentframe().f_code.co_name\n            self.call_super_method(\n                currentFuncName, x, y, button_codes, use_super_instance=True\n            )\n        def move_to(\n            self,\n            dest_x: non_neg_int,\n            dest_y: non_neg_int,\n            button_codes: List[MouseButton] = [MouseButton.NULL],\n        ):\n            currentFuncName = inspect.currentframe().f_code.co_name\n            self.call_super_method(\n                currentFuncName, dest_x, dest",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_control.py:724-751"
    },
    "1023": {
        "file_id": 134,
        "content": "Function to move mouse cursor to a specified location\n\n- Defines methods \"move_to_basic\" and \"move_to\" for moving the mouse cursor to specific coordinates.\n- Takes in parameters: x, y coordinates (non_neg_int) and a list of button codes (MouseButton).\n- Uses the \"call_super_method\" function to invoke the parent class method.\n- Inspects the current frame's name for the calling function using the \"inspect\" module.",
        "type": "comment"
    },
    "1024": {
        "file_id": 134,
        "content": "_y, button_codes, use_super_instance=True\n            )\n        # this is right click. we need to override this.\n        def click(\n            self,\n            button: MouseButton,\n            get_delay: Callable[[], float] = lambda: random.uniform(0.1, 0.45),\n        ):\n            self.send_data_relatively(0, 0, [button])\n            time.sleep(get_delay())  # 100到450毫秒延迟\n            self.send_data_relatively(0, 0)\n    # mouse = ch9329Comm.mouse.DataComm(screen_width=1920, screen_height=1080)\n    # (deprecated) monkey patch some method.\n    # from types import MethodType\n    # # to override instance methods.\n    # keyboard.send_data = MethodType(send_data, keyboard)\n    # keyboard.release = MethodType(release, keyboard)\nelse:\n    raise Exception(\"Unknown device type: {deviceType}\".format(deviceType=deviceType))\nser.close()",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_control.py:751-777"
    },
    "1025": {
        "file_id": 134,
        "content": "This code defines a class that simulates mouse clicks, with the ability to customize delay time between click and post-click. It also includes handling for different device types and closing the serial connection after use.",
        "type": "comment"
    },
    "1026": {
        "file_id": 135,
        "content": "/hardware_capture_hid_power_control/test_hidraw.py",
        "type": "filepath"
    },
    "1027": {
        "file_id": 135,
        "content": "The code tests USB devices with specific manufacturer strings, using HID API to interact by printing device information, writing and reading data, and closing the connection. However, it may require adjustments for certain devices due to hard-coded paths.",
        "type": "summary"
    },
    "1028": {
        "file_id": 135,
        "content": "# deprecated. use serial for both controllers\nfrom __future__ import print_function\nimport hid\nimport time\n# enumerate USB devices\n# manufacturer_string -> \"winkeyless.kr\"\n# shall be what we expect.\nfor d in hid.enumerate():\n    keys = list(d.keys())\n    keys.sort()\n    for key in keys:\n        print(\"%s : %s\" % (key, d[key]))\n    print()\ndevices = {\n    0: {\n        \"vendor_id\": 8352,\n        \"product_id\": 16941,\n    },  # 0, could be mouse.\n    1: {\n        \"vendor_id\": 8352,\n        \"product_id\": 16941,\n    },  # 1\n}\n# the same!\n# try opening a device, then perform write and read\n# may you write keyboard and mouse commands to different devices, by using `h.open(d)` (may still be the same as below)\nh = hid.device()\ntry:\n    print(\"Opening the device\")\n    h.open(devices[0][\"vendor_id\"], devices[0][\"product_id\"])\n    # h.open(0x534C, 0x0001)  # TREZOR VendorID/ProductID\n    # print(dir(h))\n    # 'get_feature_report', 'get_indexed_string', 'get_input_report', 'get_manufacturer_string', 'get_product_string', 'get_seri",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_hidraw.py:1-41"
    },
    "1029": {
        "file_id": 135,
        "content": "Enumerating USB devices with specified manufacturer string, comparing expected devices, and attempting to open a device for further operations.",
        "type": "comment"
    },
    "1030": {
        "file_id": 135,
        "content": "al_number_string',\n    # print(h.open_path)\n    print(\"Manufacturer: %s\" % h.get_manufacturer_string())\n    print(\"Product: %s\" % h.get_product_string())\n    print(\"Serial No: %s\" % h.get_serial_number_string())\n    # enable non-blocking mode\n    h.set_nonblocking(1)\n    # write some data to the device\n    # what data is this anyway?\n    print(\"Write the data\")\n    h.write([0, 63, 35, 35] + [0] * 61)\n    # wait\n    time.sleep(0.05)\n    # read back the answer\n    print(\"Read the data\")\n    while True:\n        d = h.read(64)\n        if d:\n            print(d)\n        else:\n            break\n    print(\"Closing the device\")\n    h.close()\nexcept IOError as ex:\n    print(ex)\n    print(\"hid error:\")\n    print(h.error())\n    print(\"\")\n    print(\"You probably don't have the hard-coded device.\")\n    print(\"Update the h.open() line in this script with the one\")\n    print(\"from the enumeration list output above and try again.\")\nprint(\"Done\")",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_hidraw.py:41-80"
    },
    "1031": {
        "file_id": 135,
        "content": "This code tests the interaction with a USB device using HID API. It prints manufacturer, product, and serial number. Writes data to the device, waits for response, reads back the data, and closes the device connection. Code may require adjustment for specific devices as it uses hard-coded device path.",
        "type": "comment"
    },
    "1032": {
        "file_id": 136,
        "content": "/hardware_capture_hid_power_control/test_video_capture.py",
        "type": "filepath"
    },
    "1033": {
        "file_id": 136,
        "content": "The code snippet is attempting to configure a video capture device using OpenCV library, set up video properties, read frames from the camera, save them as images and display using ffplay. However, it's facing issues with not being able to faithfully configure the device.",
        "type": "summary"
    },
    "1034": {
        "file_id": 136,
        "content": "# lsusb -v\n# Actions Microelectronics Co. Display capture-UVC05\n# ls /dev/video*\n# ls /sys/class/video4linux\n# v4l2-ctl --list-devices\n# get resolution/modes\n# v4l2-ctl --list-formats-ext\n# video2&3 are capture card.\nimport cv2\n# can't you reset?\ncamera_id = 2  # use the smallest camera id of particular device (the only working one)\n# without setting!\n# CV_CAP_PROP_FRAME_WIDTH: '640.0'\n# CV_CAP_PROP_FRAME_HEIGHT : '480.0'\n# CV_CAP_PROP_FRAME_FPS : '30.0'\n# CV_CAP_PROP_FRAME_FOURCC : '1196444237.0'\n# CV_CAP_PROP_FRAME_FORMAT : '16.0'\n# camera_id = 0\n# cam 1,3 not working.\ncap = cv2.VideoCapture(camera_id)\n# oops. not working for cam2, cause we are using it in obs? (yes! and cv2 will reset this thing to 640x480 just after opening the camera.)\n# resolution not right...\n# cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1080)\n# cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1920)\n# cv2 is not faithfully changing settings of the capture device.\n# cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)\n# cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1024)\n# cannot strent",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_video_capture.py:1-38"
    },
    "1035": {
        "file_id": 136,
        "content": "Code snippet is attempting to configure a video capture device using OpenCV (cv2) library. It's trying different resolution settings but encountering issues with the device not being faithfully configured.",
        "type": "comment"
    },
    "1036": {
        "file_id": 136,
        "content": "ch!\n# CV_CAP_PROP_FRAME_WIDTH: '1280.0'\n# CV_CAP_PROP_FRAME_HEIGHT : '1024.0'\n# showing values of the properties\nprint(\"CV_CAP_PROP_FRAME_WIDTH: '{}'\".format(cap.get(cv2.CAP_PROP_FRAME_WIDTH)))\nprint(\"CV_CAP_PROP_FRAME_HEIGHT : '{}'\".format(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))\nprint(\"CV_CAP_PROP_FRAME_FPS : '{}'\".format(cap.get(cv2.CAP_PROP_FPS)))\nprint(\"CV_CAP_PROP_FRAME_FOURCC : '{}'\".format(cap.get(cv2.CAP_PROP_FOURCC)))\nprint(\"CV_CAP_PROP_FRAME_FORMAT : '{}'\".format(cap.get(cv2.CAP_PROP_FORMAT)))\n# cv2.CAP_PROP_SETTINGS\nret, frame = cap.read()\n# Display the resulting frame\ncv2.imwrite(output_path := \"output.png\", frame)  # from \"no_signal\" to something!\nimport os\nos.system(f\"ffplay {output_path}\")\n# cv2.imshow('frame', frame)\n# cv2.waitKey(0)",
        "type": "code",
        "location": "/hardware_capture_hid_power_control/test_video_capture.py:38-58"
    },
    "1037": {
        "file_id": 136,
        "content": "Code snippet is setting up video capture properties, reading a frame from the camera and then saving it as an image. It also shows the values of various properties like width, height, FPS (frames per second), fourcc (a code that defines the pixel format) and format of the video stream. Finally, it displays the captured frame using ffplay (a media player).",
        "type": "comment"
    },
    "1038": {
        "file_id": 137,
        "content": "/lego_mindstorm_physical_mouse_keyboard_control/README.md",
        "type": "filepath"
    },
    "1039": {
        "file_id": 137,
        "content": "Exploring an undetectable, cage-based method to control the bot without battery power using keyboard and mouse input.",
        "type": "summary"
    },
    "1040": {
        "file_id": 137,
        "content": "And this thing is proposed by our fellows, which is absolutely undetectable by any anti-cheating software.\nIsolated in the cage, so our dataset is names as such.\nWe will try to explore something inside the cage and get interesting results, like using the keyboard and the mouse while looking at the computer screen.\nMost importantly, [how](https://www.eurobricks.com/forum/index.php?/forums/topic/195337-ev3-ac-power-adapter/) do we make it work [without battery power](https://bricksafe.com/pages/Heppu/wip-/ac-adapter), and how to send commands to the bot?\nIs there ssh access to the bot?\nWe can [control](https://github.com/ChristophGaukel/ev3-python3) the bot without ev3dev operate system",
        "type": "code",
        "location": "/lego_mindstorm_physical_mouse_keyboard_control/README.md:1-11"
    },
    "1041": {
        "file_id": 137,
        "content": "Exploring an undetectable, cage-based method to control the bot without battery power using keyboard and mouse input.",
        "type": "comment"
    },
    "1042": {
        "file_id": 138,
        "content": "/lego_mindstorm_physical_mouse_keyboard_control/test.py",
        "type": "filepath"
    },
    "1043": {
        "file_id": 138,
        "content": "This code is initializing an EV3 motor and sending a direct command to play a sound with a frequency of 440Hz, duration of 1000ms, and volume at level 1. It also defines a motor object for port D on the EV3 brick and starts moving the motor by 100 units at speed 100.",
        "type": "summary"
    },
    "1044": {
        "file_id": 138,
        "content": "from usb_ev3 import *\nops = b\"\".join(\n    (\n        ev3.opSound,\n        ev3.TONE,\n        ev3.LCX(1),  # VOLUME\n        ev3.LCX(440),  # FREQUENCY\n        ev3.LCX(1000),  # DURATION\n    )\n)\nmy_ev3.send_direct_cmd(ops)\n# voice = ev3.Voice(ev3_obj=my_ev3, volume=100)\n# voice.speak(\"hello world\").start(thread=False) # gtts failed to start.\nmt1 = ev3.Motor(port=ev3.PORT_D, ev3_obj = my_ev3)\nprint(\"motor_type:\", mt1.motor_type ) # 7 -> large motor\n# mt1.start_move_by(10,speed = 100)\n# mt1.start_move_by(10,speed = 1)\nmt1.start_move_by(100,speed = 100)\n# you know it could have problems with the environment\n# when it will stop on bad things?",
        "type": "code",
        "location": "/lego_mindstorm_physical_mouse_keyboard_control/test.py:1-27"
    },
    "1045": {
        "file_id": 138,
        "content": "This code is initializing an EV3 motor and sending a direct command to play a sound with a frequency of 440Hz, duration of 1000ms, and volume at level 1. It also defines a motor object for port D on the EV3 brick and starts moving the motor by 100 units at speed 100.",
        "type": "comment"
    },
    "1046": {
        "file_id": 139,
        "content": "/lego_mindstorm_physical_mouse_keyboard_control/usb_ev3.py",
        "type": "filepath"
    },
    "1047": {
        "file_id": 139,
        "content": "Importing EV3 library and initializing an EV3 object with USB protocol.",
        "type": "summary"
    },
    "1048": {
        "file_id": 139,
        "content": "import ev3_dc as ev3\nprotocol_param = dict(protocol=ev3.USB)\nmy_ev3 = ev3.EV3(**protocol_param) # working!\nmy_ev3.verbosity = 1",
        "type": "code",
        "location": "/lego_mindstorm_physical_mouse_keyboard_control/usb_ev3.py:1-5"
    },
    "1049": {
        "file_id": 139,
        "content": "Importing EV3 library and initializing an EV3 object with USB protocol.",
        "type": "comment"
    },
    "1050": {
        "file_id": 140,
        "content": "/lunar_lander_test/test.py",
        "type": "filepath"
    },
    "1051": {
        "file_id": 140,
        "content": "This code imports the gymnasium library and creates a LunarLander environment. It then resets the environment, takes 1000 random actions, steps through each action, checks for termination or truncation, and resets if necessary. The environment can be visualized using Pygame but the image saving is commented out in this code snippet.",
        "type": "summary"
    },
    "1052": {
        "file_id": 140,
        "content": "import gymnasium as gym\n# import pygame\nenv = gym.make(\"LunarLander-v2\", render_mode=\"human\")\nobservation, info = env.reset(seed=42)\nfor _ in range(1000):\n    action = env.action_space.sample()  # this is where you would insert your policy\n    observation, reward, terminated, truncated, info = env.step(action)\n    # let's check.\n    # pygame.image.save(env.screen, \"image.png\")  # type:ignore\n    # exit()\n    # observation: (8,)\n    # reward: float value\n    # no image?\n    if terminated or truncated:\n        observation, info = env.reset()\nenv.close()",
        "type": "code",
        "location": "/lunar_lander_test/test.py:1-21"
    },
    "1053": {
        "file_id": 140,
        "content": "This code imports the gymnasium library and creates a LunarLander environment. It then resets the environment, takes 1000 random actions, steps through each action, checks for termination or truncation, and resets if necessary. The environment can be visualized using Pygame but the image saving is commented out in this code snippet.",
        "type": "comment"
    },
    "1054": {
        "file_id": 141,
        "content": "/metalearning_random_shuffle/README.md",
        "type": "filepath"
    },
    "1055": {
        "file_id": 141,
        "content": "This code describes the goal of performing operations like copy, cut, and shuffle without relying on annotations while potentially reducing entropy.",
        "type": "summary"
    },
    "1056": {
        "file_id": 141,
        "content": "we want to learn the unspeakable. we want to be annotation free.\nso basically we can do following operations:\ncopy, cut, shuffle\nin which the entropy might be reduced.",
        "type": "code",
        "location": "/metalearning_random_shuffle/README.md:1-7"
    },
    "1057": {
        "file_id": 141,
        "content": "This code describes the goal of performing operations like copy, cut, and shuffle without relying on annotations while potentially reducing entropy.",
        "type": "comment"
    },
    "1058": {
        "file_id": 142,
        "content": "/metalearning_random_shuffle/main.py",
        "type": "filepath"
    },
    "1059": {
        "file_id": 142,
        "content": "Generating and printing all possible combinations of letters and digits, copying the dataset twice, cutting the dataset to create a new one, shuffling the dataset.",
        "type": "summary"
    },
    "1060": {
        "file_id": 142,
        "content": "import string\ndataset = list(string.ascii_letters + string.digits)\nprint(dataset)\n# copy\nprint(dataset * 2)\n# cut\nprint(dataset[0:5] + dataset[10:])\n# shuffle\nimport random\nrandom.shuffle(dataset)\nprint(dataset)\n# and this is what you must learn",
        "type": "code",
        "location": "/metalearning_random_shuffle/main.py:1-18"
    },
    "1061": {
        "file_id": 142,
        "content": "Generating and printing all possible combinations of letters and digits, copying the dataset twice, cutting the dataset to create a new one, shuffling the dataset.",
        "type": "comment"
    },
    "1062": {
        "file_id": 143,
        "content": "/propaganda/agi_computer_recordings/launch_server.cmd",
        "type": "filepath"
    },
    "1063": {
        "file_id": 143,
        "content": "Executes WebDAV command to connect to host, port, and path for recordings.",
        "type": "summary"
    },
    "1064": {
        "file_id": 143,
        "content": "webdav-cli --host 192.168.56.1 --port 8111 --username root --password root --path=D:\\works\\agi_computer_recordings\\recordings ",
        "type": "code",
        "location": "/propaganda/agi_computer_recordings/launch_server.cmd:1-1"
    },
    "1065": {
        "file_id": 143,
        "content": "Executes WebDAV command to connect to host, port, and path for recordings.",
        "type": "comment"
    },
    "1066": {
        "file_id": 144,
        "content": "/propaganda/cybergod_propaganda/README.md",
        "type": "filepath"
    },
    "1067": {
        "file_id": 144,
        "content": "This folder contains propaganda materials for Cybergod and The Frozen Forest. They plan to create a video in a step-by-step approach, starting with writing the script, making short footage, and collecting material. They acknowledge the power of LLMs in content creation but want to learn the basics first, beginning with logo creation.",
        "type": "summary"
    },
    "1068": {
        "file_id": 144,
        "content": "this folder contains propaganda material for cybergod and the frozen forest.\nwe plan to create the video in a \"step by step\" approach, which is writing video script along the way of making short footage and collecting material.\nit is important to realize the power of LLM in content creation. however, we shall learn the basics. i mean i am never close to \"fluent\" in video creation. so let's do it!\nfirst create logos for cybergod and the frozen forest",
        "type": "code",
        "location": "/propaganda/cybergod_propaganda/README.md:1-7"
    },
    "1069": {
        "file_id": 144,
        "content": "This folder contains propaganda materials for Cybergod and The Frozen Forest. They plan to create a video in a step-by-step approach, starting with writing the script, making short footage, and collecting material. They acknowledge the power of LLMs in content creation but want to learn the basics first, beginning with logo creation.",
        "type": "comment"
    },
    "1070": {
        "file_id": 145,
        "content": "/propaganda/video_script/README.md",
        "type": "filepath"
    },
    "1071": {
        "file_id": 145,
        "content": "This code provides a link to search for videos on fse.agilestudio.cn and an API endpoint for the same, suggesting using ffmpeg to convert m3u8 links into videos.",
        "type": "summary"
    },
    "1072": {
        "file_id": 145,
        "content": "access: https://fse.agilestudio.cn/search?keyword=%E9%94%AE%E7%9B%98%E5%92%8C%E9%BC%A0%E6%A0%87\napi access: fse-api.agilestudio.cn/api/search (may not work!)\nuse ffmpeg to convert m3u8 links into video.",
        "type": "code",
        "location": "/propaganda/video_script/README.md:1-7"
    },
    "1073": {
        "file_id": 145,
        "content": "This code provides a link to search for videos on fse.agilestudio.cn and an API endpoint for the same, suggesting using ffmpeg to convert m3u8 links into videos.",
        "type": "comment"
    },
    "1074": {
        "file_id": 146,
        "content": "/propaganda/video_script/clyde_script.txt",
        "type": "filepath"
    },
    "1075": {
        "file_id": 146,
        "content": "The video script for Cybergod, an AI keyboard and mouse controller, showcases its concept, usage, and benefits while motivating developers to create code for it.",
        "type": "summary"
    },
    "1076": {
        "file_id": 146,
        "content": "Here's a sample video script: \nTitle: Cybergod - The AI Keyboard and Mouse Controller\nOpening shot: Camera zooms in on a keyboard and mouse on a desk. Camera zooms out to show a person typing on the keyboard and moving the mouse. \nVoiceover: \"Do you ever feel like you waste too much time typing and moving your mouse around when working on your computer?\"\nCut to shot of a man getting frustrated as he types and moves his mouse.\nVoiceover: \"Imagine if there was a program that could learn from your usage data, and automate all of your typing and mouse movements for you.\"\nCut to shot of a woman sitting comfortably on the couch, holding a drink as she watches the program work on her computer.\nVoiceover: \"Introducing Cybergod - the AI keyboard and mouse controller. This innovative program learns from your daily usage data, and automates your typing and mouse movements for you.\"\nCut to a hand typing on the keyboard and moving the mouse, and then cutting to the program running in the background. \nVoiceo",
        "type": "code",
        "location": "/propaganda/video_script/clyde_script.txt:1-19"
    },
    "1077": {
        "file_id": 146,
        "content": "The code is a video script for an AI keyboard and mouse controller called Cybergod. It describes the concept, shows how it can be used, and highlights its benefits.",
        "type": "comment"
    },
    "1078": {
        "file_id": 146,
        "content": "ver: \"This program saves you time, energy, and lets you focus on the more important things in life.\"\nCut to shot of a man smiling as he looks at his computer screen.\nVoiceover: \"Cybergod is the future of computer control, and we encourage developers and programmers to write code for it.\"\nClosing shot: \"Get your hands on Cybergod today, and experience the freedom of automation.\"\nEnd of video.",
        "type": "code",
        "location": "/propaganda/video_script/clyde_script.txt:19-27"
    },
    "1079": {
        "file_id": 146,
        "content": "This code describes the video script for promoting Cybergod, highlighting its benefits and encouraging developers to write code for it.",
        "type": "comment"
    },
    "1080": {
        "file_id": 147,
        "content": "/propaganda/video_script/clyde_script_cn.txt",
        "type": "filepath"
    },
    "1081": {
        "file_id": 147,
        "content": "This is a video script for introducing Cybergod - AI键鼠控制器. It highlights the benefits of using the program to automate typing and mouse movements based on usage data, saving time and energy for users. The script encourages developers and programmers to contribute code for Cybergod.",
        "type": "summary"
    },
    "1082": {
        "file_id": 147,
        "content": "Title: Cybergod - AI键鼠控制器\nOpening shot: 镜头拉近到桌上的键盘和鼠标，然后拉远显示一个人正在键盘和鼠标上操作。\nVoiceover: “你有没有觉得在电脑上打字和用鼠标移动太费时间了？”\nCut to shot of a man getting frustrated as he types and moves his mouse.\nVoiceover: “想象一下，如果有一个程序可以从你的使用数据中学习，为你自动化所有的打字和鼠标操作。”\nCut to shot of a woman sitting comfortably on the couch, holding a drink as she watches the program work on her computer.\nVoiceover: “这就是Cybergod - AI键鼠控制器。这一创新性的程序可以从你的日常使用数据中学习，为你自动化打字和鼠标操作。”\nCut to a hand typing on the keyboard and moving the mouse, and then cutting to the program running in the background.\nVoiceover: “这个程序可以为你节省时间和精力，让你专注于生活中更重要的事情。”\nCut to shot of a man smiling as he looks at his computer screen.\nVoiceover: “Cybergod是电脑控制的未来，我们鼓励开发者和程序员为其编写代码。”\nClosing shot: “立即拥有Cybergod，享受自动化的自由。”\nEnd of video.",
        "type": "code",
        "location": "/propaganda/video_script/clyde_script_cn.txt:1-25"
    },
    "1083": {
        "file_id": 147,
        "content": "This is a video script for introducing Cybergod - AI键鼠控制器. It highlights the benefits of using the program to automate typing and mouse movements based on usage data, saving time and energy for users. The script encourages developers and programmers to contribute code for Cybergod.",
        "type": "comment"
    },
    "1084": {
        "file_id": 148,
        "content": "/propaganda/video_script/compile_script.py",
        "type": "filepath"
    },
    "1085": {
        "file_id": 148,
        "content": "This code seems to be discussing the presence of audio and video but is questioning the location of background music (BGM).",
        "type": "summary"
    },
    "1086": {
        "file_id": 148,
        "content": "# this time we have audio and video.\n# where's the BGM?",
        "type": "code",
        "location": "/propaganda/video_script/compile_script.py:1-2"
    },
    "1087": {
        "file_id": 148,
        "content": "This code seems to be discussing the presence of audio and video but is questioning the location of background music (BGM).",
        "type": "comment"
    },
    "1088": {
        "file_id": 149,
        "content": "/propaganda/video_script/download_video.py",
        "type": "filepath"
    },
    "1089": {
        "file_id": 149,
        "content": "This code downloads videos specified in the 'script.yaml' file and saves them to a directory named \"video\". It then creates an output JSON file containing the mapping of video links to their respective saved file paths.",
        "type": "summary"
    },
    "1090": {
        "file_id": 149,
        "content": "import os\nimport yaml\nscript_path = \"script.yaml\"\ndir_path = \"video\"\nwith open(script_path,'r') as f:\n    data = yaml.load(f, Loader=yaml.BaseLoader)\n# os.system\noutput_path= \"output.json\"\nimport json\nimport rich\nrich.print(data)\noutput_data = {}\nindex = 0\nfor d in data:\n    vlink = d.get('video', None)\n    if vlink:\n        index+=1\n        vpath = f\"{index}.mp4\"\n        video_output = os.path.join(dir_path, vpath)\n        os.system(f'ffmpeg -y -i \"{vlink}\" {video_output}')\n        output_data.update({vlink:video_output})\nwith open(output_path,'w+') as f:\n    f.write(json.dumps(output_data, indent=4, ensure_ascii=False))",
        "type": "code",
        "location": "/propaganda/video_script/download_video.py:1-28"
    },
    "1091": {
        "file_id": 149,
        "content": "This code downloads videos specified in the 'script.yaml' file and saves them to a directory named \"video\". It then creates an output JSON file containing the mapping of video links to their respective saved file paths.",
        "type": "comment"
    },
    "1092": {
        "file_id": 150,
        "content": "/propaganda/video_script/preprocess.py",
        "type": "filepath"
    },
    "1093": {
        "file_id": 150,
        "content": "Reads script from 'script.txt', removes specified spliters, and stores data in a list. Writes the list to 'script.md' with \"- text: \" and \"  video: \" for each item.",
        "type": "summary"
    },
    "1094": {
        "file_id": 150,
        "content": "spliters = \",.，。！~\"\noutput = 'script.md'\nwith open('script.txt', 'r') as f:\n\tdata = f.read()\nfor e in spliters:\n\tdata = data.replace(e, \" \")\ndata = data.strip()\ndata = data.split(\" \")\nwith open(output, 'w+') as f:\n\t#f.write(\"\\n\".join(data))\n\tfor d in data:\n\t\tf.write(f\"- text: {d}\\n\")\n\t\tf.write(\"  video: \\n\")",
        "type": "code",
        "location": "/propaganda/video_script/preprocess.py:2-18"
    },
    "1095": {
        "file_id": 150,
        "content": "Reads script from 'script.txt', removes specified spliters, and stores data in a list. Writes the list to 'script.md' with \"- text: \" and \"  video: \" for each item.",
        "type": "comment"
    },
    "1096": {
        "file_id": 151,
        "content": "/propaganda/video_script/read_text.py",
        "type": "filepath"
    },
    "1097": {
        "file_id": 151,
        "content": "The code imports libraries, loads data from a YAML file, configures a text-to-speech engine, and saves each text as an audio file in a specified directory using voice settings and punctuation for pauses.",
        "type": "summary"
    },
    "1098": {
        "file_id": 151,
        "content": "# import pyttsx3\n# import os\ndir_path = \"audio\"\nimport os\nimport yaml\nscript_path = \"script.yaml\"\nwith open(script_path,'r') as f:\n    data = yaml.load(f, Loader=yaml.BaseLoader)\nimport pyttsx3\n# dir(engine.getProperty(\"voices\")[0]) -> ['age', 'gender', 'id', 'languages', 'name']\n# The voices are related to languages. Set it properly.\n# you want \"en_US\" and \"zh_CN\"\n# [['en_US'], ['it_IT'], ['sv_SE'], ['fr_CA'], ['de_DE'], ['he_IL'], ['id_ID'], ['en_GB'], ['es_AR'], ['nl_BE'], ['en-scotland'], ['en_US'], ['ro_RO'], ['pt_PT'], ['es_ES'], ['es_MX'], ['th_TH'], ['en_AU'], ['ja_JP'], ['sk_SK'], ['hi_IN'], ['it_IT'], ['pt_BR'], ['ar_SA'], ['hu_HU'], ['zh_TW'], ['el_GR'], ['ru_RU'], ['en_IE'], ['es_ES'], ['nb_NO'], ['es_MX'], ['en_IN'], ['en_US'], ['da_DK'], ['fi_FI'], ['zh_HK'], ['en_ZA'], ['fr_FR'], ['zh_CN'], ['en_IN'], ['en_US'], ['nl_NL'], ['tr_TR'], ['ko_KR'], ['ru_RU'], ['pl_PL'], ['cs_CZ']]\n# engine.save_to_file(\"你好 世界\", 'output.wav')\n# engine.runAndWait()\n# engine.setProperty('rate', 125) # setting",
        "type": "code",
        "location": "/propaganda/video_script/read_text.py:1-25"
    },
    "1099": {
        "file_id": 151,
        "content": "This code imports necessary libraries, loads data from a YAML file, and configures a text-to-speech engine. It then saves a speech to an audio file in the specified directory using the configured voice settings. The rate of speech can be set using the 'rate' property.",
        "type": "comment"
    }
}