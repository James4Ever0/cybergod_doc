{
    "1700": {
        "file_id": 228,
        "content": "# vboxmanage startvm \"12c0e77b-5f4a-4d30-b19b-1b105d2042cf\" # Ubuntu 16.04\nnohup xvfb-run --server-num=10 --listen-tcp --server-args=\"-screen 0 1280x800x24\" -f /tmp/.Xauthority vboxsdl --startvm \"Ubuntu 16.04\" &\n# start in headless mode\n# you may not live stream this one! but vrde is available! and you can use ffmpeg for bridging!\n# vboxmanage startvm \"Ubuntu 16.04\" --type headless",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/start_vm.sh:1-5"
    },
    "1701": {
        "file_id": 228,
        "content": "Starts a virtual machine named \"Ubuntu 16.04\" using VirtualBox, in headless mode with display forwarding disabled.",
        "type": "comment"
    },
    "1702": {
        "file_id": 229,
        "content": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/stop_on_ffmpeg_x11_error.py",
        "type": "filepath"
    },
    "1703": {
        "file_id": 229,
        "content": "Checking for \"Failed to query xcb pointer\" error in input data and breaking loop upon detection.",
        "type": "summary"
    },
    "1704": {
        "file_id": 229,
        "content": "error = \"Failed to query xcb pointer\"\nwhile True:\n    data = input()\n    print(data)\n    if error in data:\n        break",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/stop_on_ffmpeg_x11_error.py:1-6"
    },
    "1705": {
        "file_id": 229,
        "content": "Checking for \"Failed to query xcb pointer\" error in input data and breaking loop upon detection.",
        "type": "comment"
    },
    "1706": {
        "file_id": 230,
        "content": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/stop_vm.sh",
        "type": "filepath"
    },
    "1707": {
        "file_id": 230,
        "content": "This script stops a VirtualBox virtual machine named \"12c0e77b-5f4a-4d30-b19b-1b105d2042cf\" running Ubuntu 16.04 and powers it off. If the poweroff fails, it kills related processes to free up resources and prints an error message. The script also notes that it can start the VM in headless mode and mentions using VRDE and ffmpeg for live streaming if needed.",
        "type": "summary"
    },
    "1708": {
        "file_id": 230,
        "content": "timeout 10 vboxmanage controlvm \"12c0e77b-5f4a-4d30-b19b-1b105d2042cf\" poweroff # Ubuntu 16.04\n# FIXME: 掉盘了 一般是\n# 就没有更好的固态硬盘盒么\n# 刷固件需要拿出来硬盘\nif [ \"$?\" -ne 0 ]; then\necho \"ERROR: Failed to stop vm.\"\nps aux | grep -i /usr/lib/virtualbox | grep -v grep | awk '{print $2}' | xargs -iabc kill -s TERM abc\nfi\n# start in headless mode\n# you may not live stream this one! but vrde is available! and you can use ffmpeg for bridging!\n# vboxmanage startvm \"Ubuntu 16.04\" --type headless",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/stop_vm.sh:1-14"
    },
    "1709": {
        "file_id": 230,
        "content": "This script stops a VirtualBox virtual machine named \"12c0e77b-5f4a-4d30-b19b-1b105d2042cf\" running Ubuntu 16.04 and powers it off. If the poweroff fails, it kills related processes to free up resources and prints an error message. The script also notes that it can start the VM in headless mode and mentions using VRDE and ffmpeg for live streaming if needed.",
        "type": "comment"
    },
    "1710": {
        "file_id": 231,
        "content": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/the_frozen_forest.service",
        "type": "filepath"
    },
    "1711": {
        "file_id": 231,
        "content": "This code is a service file for The Frozen Forest dataset, which is a data creation service. It requires the network to be online and depends on syslog.target. It sets environment variables for DISPLAY, XAUTHORITY, PATH, and HOME. The user is \"hua\" and the ExecStart command runs mount_kali_webdav_dirs.sh script. The WorkingDirectory is /home/hua/agi_workspace and it is wanted by graphical.target.",
        "type": "summary"
    },
    "1712": {
        "file_id": 231,
        "content": "[Unit]\nDescription=Data creation service for The Frozen Forest dataset.\nWants=network.target\nAfter=syslog.target network-online.target\n[Service]\nEnvironment=\"DISPLAY=:0\"\nEnvironment=\"XAUTHORITY=/home/hua/.Xauthority\"\nEnvironment=\"PATH=/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin\"\nEnvironment=\"HOME=/home/hua\"\nUser=hua\nExecStart=/usr/bin/env /bin/bash mount_kali_webdav_dirs.sh\nWorkingDirectory=/home/hua/agi_workspace\n[Install]\nWantedBy=graphical.target",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/the_frozen_forest.service:1-16"
    },
    "1713": {
        "file_id": 231,
        "content": "This code is a service file for The Frozen Forest dataset, which is a data creation service. It requires the network to be online and depends on syslog.target. It sets environment variables for DISPLAY, XAUTHORITY, PATH, and HOME. The user is \"hua\" and the ExecStart command runs mount_kali_webdav_dirs.sh script. The WorkingDirectory is /home/hua/agi_workspace and it is wanted by graphical.target.",
        "type": "comment"
    },
    "1714": {
        "file_id": 232,
        "content": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/x11grab.py",
        "type": "filepath"
    },
    "1715": {
        "file_id": 232,
        "content": "Starts an X11 grabber, capturing screen from display 10 and piping the output.",
        "type": "summary"
    },
    "1716": {
        "file_id": 232,
        "content": "cmd = \"env XAUTHORITY=/tmp/.Xauthority ffmpeg -f x11grab -i :10 -f image2pipe pipe:1\"\nimport subprocess\np = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)\nwhile True:\n    print(len(p.stdout.readline()))",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/x11grab.py:1-8"
    },
    "1717": {
        "file_id": 232,
        "content": "Starts an X11 grabber, capturing screen from display 10 and piping the output.",
        "type": "comment"
    },
    "1718": {
        "file_id": 233,
        "content": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/x11grab.sh",
        "type": "filepath"
    },
    "1719": {
        "file_id": 233,
        "content": "The code captures X11 window content from a remote server, saves images to a pipe and plays them in real-time.",
        "type": "summary"
    },
    "1720": {
        "file_id": 233,
        "content": "cd .\nwhile true; do\n    env XAUTHORITY=/tmp/.Xauthority ffmpeg -f x11grab -r 10 -i :10 -f image2pipe pipe:1 | ffplay -f image2pipe -i - -autoexit\n    sleep 1\ndone;\n# still with some lag! need improvement.\n# env XAUTHORITY=/tmp/.Xauthority ffmpeg -f x11grab -i :10 -f image2pipe pipe:1\n# env XAUTHORITY=/tmp/.Xauthority ffplay -f x11grab -i :10 2>&1",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/x11grab.sh:1-9"
    },
    "1721": {
        "file_id": 233,
        "content": "The code captures X11 window content from a remote server, saves images to a pipe and plays them in real-time.",
        "type": "comment"
    },
    "1722": {
        "file_id": 234,
        "content": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/x11grab_loop.sh",
        "type": "filepath"
    },
    "1723": {
        "file_id": 234,
        "content": "The code is starting X virtual framebuffer (Xvfb) server with a specified resolution, running x11grab.sh in it, and also providing an option to monitor for X11 errors using stop_on_ffmpeg_x11_error.py script.",
        "type": "summary"
    },
    "1724": {
        "file_id": 234,
        "content": "cd . # FIX: input/output error\nps aux | grep -i xvfb | grep 11 | grep -v grep | awk '{print $2}' | xargs -iabc kill -s TERM abc\nxvfb-run --server-num=11 --listen-tcp --server-args=\"-screen 0 1280x800x24\" -f /tmp/.Xauthority1 bash x11grab.sh\n# xvfb-run --server-num=11 --listen-tcp --server-args=\"-screen 0 1280x800x24\" -f /tmp/.Xauthority1 bash x11grab.sh | python3 stop_on_ffmpeg_x11_error.py",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/x11grab_loop.sh:1-4"
    },
    "1725": {
        "file_id": 234,
        "content": "The code is starting X virtual framebuffer (Xvfb) server with a specified resolution, running x11grab.sh in it, and also providing an option to monitor for X11 errors using stop_on_ffmpeg_x11_error.py script.",
        "type": "comment"
    },
    "1726": {
        "file_id": 235,
        "content": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/x11grab_loop_viewer.sh",
        "type": "filepath"
    },
    "1727": {
        "file_id": 235,
        "content": "Starts FFplay with X11 grabbing from display 11 and exits when done.",
        "type": "summary"
    },
    "1728": {
        "file_id": 235,
        "content": "env XAUTHORITY=/tmp/.Xauthority1 ffplay -f x11grab -i :11 -autoexit",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/x11grab_loop_viewer.sh:1-1"
    },
    "1729": {
        "file_id": 235,
        "content": "Starts FFplay with X11 grabbing from display 11 and exits when done.",
        "type": "comment"
    },
    "1730": {
        "file_id": 236,
        "content": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/xvfb_test_loop_double_display.py",
        "type": "filepath"
    },
    "1731": {
        "file_id": 236,
        "content": "This script is attempting to run a series of commands using xvfb (X virtual framebuffer) for displaying graphics in a virtual environment. It repeatedly executes the script \"x11grab_loop.sh\" every second until stopped. The commented out section suggests an alternative approach using subprocess and progressbar modules for running commands sequentially with a progress bar.",
        "type": "summary"
    },
    "1732": {
        "file_id": 236,
        "content": "# import subprocess\n# # run this using xvfb.\nimport os\n# script_1 = 'xvfb-run --server-num=10 --listen-tcp --server-args=\"-screen 0 1280x800x24\" -f /tmp/.Xauthority vboxsdl --startvm \"Ubuntu 16.04\"'\n# script_2 = 'env XAUTHORITY=/tmp/.Xauthority ffplay -f x11grab -i :10'\n# script_3 = 'vboxmanage controlvm \"Ubuntu 16.04\" poweroff'\nscript_4 = \"bash x11grab_loop.sh\"\nimport time\n# import progressbar\nwhile True:\n    time.sleep(1)\n    os.system(\"cd .\") # FIX: input/output error\n    os.system(script_4)\n# while True:\n#     p1 = subprocess.run(script_1)\n#     p2 = subprocess.run(script_2)\n#     for _ in progressbar.progressbar(range(100)):\n#         time.sleep(1)\n#     os.system(script_3)",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/xvfb_test_loop_double_display.py:1-28"
    },
    "1733": {
        "file_id": 236,
        "content": "This script is attempting to run a series of commands using xvfb (X virtual framebuffer) for displaying graphics in a virtual environment. It repeatedly executes the script \"x11grab_loop.sh\" every second until stopped. The commented out section suggests an alternative approach using subprocess and progressbar modules for running commands sequentially with a progress bar.",
        "type": "comment"
    },
    "1734": {
        "file_id": 237,
        "content": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/xvfb_test_loop_double_display.sh",
        "type": "filepath"
    },
    "1735": {
        "file_id": 237,
        "content": "Launching Python script for double-display testing with XVFB.",
        "type": "summary"
    },
    "1736": {
        "file_id": 237,
        "content": "python3 xvfb_test_loop_double_display.py",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/xvfb_test_loop_double_display.sh:1-1"
    },
    "1737": {
        "file_id": 237,
        "content": "Launching Python script for double-display testing with XVFB.",
        "type": "comment"
    },
    "1738": {
        "file_id": 238,
        "content": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/xvfbwrapper_vboxmanager_test.py",
        "type": "filepath"
    },
    "1739": {
        "file_id": 238,
        "content": "Code is attempting to run a virtual display (Xvfb) and then launch a virtual machine (Ubuntu 16.04) using VBoxSDL commands within the Xvfb display context. The code also includes a progress bar for a simulated long-running task, but it doesn't seem to be functioning properly.",
        "type": "summary"
    },
    "1740": {
        "file_id": 238,
        "content": "from xvfbwrapper import Xvfb\n# it sucks!\n# vdisplay = Xvfb(display=3)\n# vdisplay.start()\nimport os\ncmd = 'vboxsdl --startvm \"Ubuntu 16.04\"' \nwith Xvfb(display=3) as vdisplay: # not working...\n    os.system(cmd)\n# try:\n#     # launch stuff inside virtual display here.\n#     # os.system('bash start_vm.sh')\n#     import time\n#     import progressbar\n#     for _ in progressbar.progressbar(range(1000)):\n#         time.sleep(1)\n# finally:\n#     vdisplay.stop()",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/kali_vbox_control/xvfbwrapper_vboxmanager_test.py:2-23"
    },
    "1741": {
        "file_id": 238,
        "content": "Code is attempting to run a virtual display (Xvfb) and then launch a virtual machine (Ubuntu 16.04) using VBoxSDL commands within the Xvfb display context. The code also includes a progress bar for a simulated long-running task, but it doesn't seem to be functioning properly.",
        "type": "comment"
    },
    "1742": {
        "file_id": 239,
        "content": "/ubuntu_qemu_utm_arm_record/launch_server.cmd",
        "type": "filepath"
    },
    "1743": {
        "file_id": 239,
        "content": "Executes WebDAV command to connect to host, port, and path for recordings.",
        "type": "summary"
    },
    "1744": {
        "file_id": 239,
        "content": "webdav-cli --host 192.168.56.1 --port 8111 --username root --password root --path=D:\\works\\agi_computer_recordings\\recordings ",
        "type": "code",
        "location": "/propaganda/agi_computer_recordings/launch_server.cmd:1-1"
    },
    "1745": {
        "file_id": 239,
        "content": "Executes WebDAV command to connect to host, port, and path for recordings.",
        "type": "comment"
    },
    "1746": {
        "file_id": 240,
        "content": "/ubuntu_qemu_utm_arm_record/macos_iterate_windows.sh",
        "type": "filepath"
    },
    "1747": {
        "file_id": 240,
        "content": "This script calls the `get_window_id` function from the `screenshot` module and prints its output after filtering for \"Name\" using grep and displays it with less. Alternatively, OBS and OBS-websocket can be used for screen recording with iTerm enabling the capability.",
        "type": "summary"
    },
    "1748": {
        "file_id": 240,
        "content": "python3 -c \"from screenshot import get_window_id; print(get_window_id.get_window_info(options=get_window_id.build_option_bitmask()))\" | grep Name | less\n# or use obs, then use obs-websocket to take screeenshots.\n# enable screen recording capability with iterm.",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/macos_iterate_windows.sh:1-5"
    },
    "1749": {
        "file_id": 240,
        "content": "This script calls the `get_window_id` function from the `screenshot` module and prints its output after filtering for \"Name\" using grep and displays it with less. Alternatively, OBS and OBS-websocket can be used for screen recording with iTerm enabling the capability.",
        "type": "comment"
    },
    "1750": {
        "file_id": 241,
        "content": "/ubuntu_qemu_utm_arm_record/macos_take_screenshot.py",
        "type": "filepath"
    },
    "1751": {
        "file_id": 241,
        "content": "Taking a screenshot of window with ID 9859 and saving it as \"output.png\".",
        "type": "summary"
    },
    "1752": {
        "file_id": 241,
        "content": "from screenshot import screencapture\nwindow_id = 9859\nscreencapture.take_screenshot(window_id, filename=\"output.png\")",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/macos_take_screenshot.py:1-5"
    },
    "1753": {
        "file_id": 241,
        "content": "Taking a screenshot of window with ID 9859 and saving it as \"output.png\".",
        "type": "comment"
    },
    "1754": {
        "file_id": 242,
        "content": "/ubuntu_qemu_utm_arm_record/macos_utm_run_qemu.sh",
        "type": "filepath"
    },
    "1755": {
        "file_id": 242,
        "content": "Both comments describe setting up a QEMU virtual machine with ARM architecture using Ubuntu ARM image, configuring hardware settings and network, and utilizing Spice protocol for display and serial communication.",
        "type": "summary"
    },
    "1756": {
        "file_id": 242,
        "content": "# https://vaibhavkaushal.com/posts/ubuntu-focal-on-apple-silicon-m1/#step-4---launch-acvm\n# EFI_PATH=\"/Volumes/Toshiba XG3/QEMU/EFI/QEMU_EFI.fd\"\nEFI_PATH=\"/Volumes/Toshiba XG3/QEMU/EFI/edk2-aarch64-code.fd\"\nIMAGE_PATH=\"/Volumes/Toshiba XG3/QEMU/Images/335D6651-2B4B-47A7-99B4-CBFB1EFDEFF8.qcow2\"\nqemu-system-aarch64 \\\n  -serial stdio \\\n  -M virt,highmem=off \\\n  -accel hvf \\\n  -cpu cortex-a72 \\\n  -smp 4,cores=4 \\\n  -m 2048 \\\n  -bios \"$EFI_PATH\" \\\n  -device virtio-gpu-pci \\\n  -display default,show-cursor=on \\\n  -device qemu-xhci \\\n  -device usb-kbd \\\n  -device usb-tablet \\\n  -device intel-hda \\\n  -device hda-duplex \\\n  -drive file=\"$IMAGE_PATH\",if=virtio,cache=writethrough \n  # -vnc unix:$HOME/.qemu_vnc\n  # -vnc :1,password=off # 5901\n  # -vnc :1,password=on # 5901\n# no visual?\n# https://www.jianshu.com/p/ccde2786ebf8\n##################\n# make snapshots #\n##################\n# CREATE: qemu-img snapshot -c <SNAPSHOT_NAME> <QCOW2_PATH>\n# LIST: qemu-img snapshot -l <QCOW2_PATH>\n# APPLY: qemu-img snapshot -a <SNAPSHOT_NAME>",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/macos_utm_run_qemu.sh:1-35"
    },
    "1757": {
        "file_id": 242,
        "content": "Launching Ubuntu on Apple M1 using QEMU with EFI boot, virtual devices and a virtio image drive.",
        "type": "comment"
    },
    "1758": {
        "file_id": 242,
        "content": " <QCOW2_PATH>\n# DELETE: qemu-img snapshot -d <SNAPSHOT_NAME> <QCOW2_PATH>\n# https://blog.csdn.net/liu_xing_hui/article/details/32718839\n# refer to: https://qemu.readthedocs.io/en/latest/system/vnc-security.html\n# /Applications/UTM.app/Contents/XPCServices/QEMUHelper.xpc/Contents/MacOS/QEMULauncher.app/Contents/MacOS/QEMULauncher /Applications/UTM.app/Contents/Frameworks/qemu-aarch64-softmmu.framework/Versions/A/qemu-aarch64-softmmu -L /Applications/UTM.app/Contents/Resources/qemu -S -spice unix=on,addr=/Users/jamesbrown/Library/Group Containers/WDNLXAD4W8.com.utmapp.UTM/B54F0831-B34F-404D-B600-5E2886D8AC53.spice,disable-ticketing=on,image-compression=off,playback-compression=off,streaming-video=off,gl=off -chardev spiceport,id=org.qemu.monitor.qmp,name=org.qemu.monitor.qmp.0 -mon chardev=org.qemu.monitor.qmp,mode=control -nodefaults -vga none -device virtio-net-pci,mac=9A:B7:7D:21:25:67,netdev=net0 -netdev vmnet-shared,id=net0 -device virtio-ramfb -cpu host -smp cpus=4,sockets=1,cores=4,th",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/macos_utm_run_qemu.sh:35-42"
    },
    "1759": {
        "file_id": 242,
        "content": "Creates a snapshot of the QCOW2 image with no discard.\nRefers to resources for qemu VNC security and UTM app files.\nLaunches qemu-aarch64-softmmu with specific options and settings.",
        "type": "comment"
    },
    "1760": {
        "file_id": 242,
        "content": "reads=1 -machine virt -accel hvf -drive if=pflash,format=raw,unit=0,file=/Applications/UTM.app/Contents/Resources/qemu/edk2-aarch64-code.fd,readonly=on -drive if=pflash,unit=1,file=/Volumes/Toshiba XG3/UTM VMs/Ubuntu ARM.utm/Data/efi_vars.fd -m 2048 -device intel-hda -device hda-duplex -device nec-usb-xhci,id=usb-bus -device usb-tablet,bus=usb-bus.0 -device usb-mouse,bus=usb-bus.0 -device usb-kbd,bus=usb-bus.0 -device qemu-xhci,id=usb-controller-0 -chardev spicevmc,name=usbredir,id=usbredirchardev0 -device usb-redir,chardev=usbredirchardev0,id=usbredirdev0,bus=usb-controller-0.0 -chardev spicevmc,name=usbredir,id=usbredirchardev1 -device usb-redir,chardev=usbredirchardev1,id=usbredirdev1,bus=usb-controller-0.0 -chardev spicevmc,name=usbredir,id=usbredirchardev2 -device usb-redir,chardev=usbredirchardev2,id=usbredirdev2,bus=usb-controller-0.0 -device usb-storage,drive=drive18D1A7CE-50FE-4567-B033-B2AB9F811108,removable=true,bootindex=0,bus=usb-bus.0 -drive if=none,media=cdrom,id=drive18",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/macos_utm_run_qemu.sh:42-42"
    },
    "1761": {
        "file_id": 242,
        "content": "Creates a QEMU virtual machine with ARM architecture, specifying hardware settings and drive configurations.",
        "type": "comment"
    },
    "1762": {
        "file_id": 242,
        "content": "D1A7CE-50FE-4567-B033-B2AB9F811108,readonly=on -device virtio-blk-pci,drive=drive335D6651-2B4B-47A7-99B4-CBFB1EFDEFF8,bootindex=1 -drive if=none,media=disk,id=drive335D6651-2B4B-47A7-99B4-CBFB1EFDEFF8,file=/Volumes/Toshiba XG3/UTM VMs/Ubuntu ARM.utm/Data/335D6651-2B4B-47A7-99B4-CBFB1EFDEFF8.qcow2,discard=unmap,detect-zeroes=unmap -device virtio-serial -device virtserialport,chardev=vdagent,name=com.redhat.spice.0 -chardev spicevmc,id=vdagent,debug=0,name=vdagent -name Linux -uuid B54F0831-B34F-404D-B600-5E2886D8AC53 -device virtio-rng-pci\n# qemu-system-aarch64 -L /Applications/UTM.app/Contents/Resources/qemu -S -spice unix=on,addr='/Users/jamesbrown/Library/Group Containers/WDNLXAD4W8.com.utmapp.UTM/B54F0831-B34F-404D-B600-5E2886D8AC53.spice',disable-ticketing=on,image-compression=off,playback-compression=off,streaming-video=off,gl=off -chardev spiceport,id=org.qemu.monitor.qmp,name=org.qemu.monitor.qmp.0 -mon chardev=org.qemu.monitor.qmp,mode=control -nodefaults -vga none -device virti",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/macos_utm_run_qemu.sh:42-44"
    },
    "1763": {
        "file_id": 242,
        "content": "Creating a virtual machine with Ubuntu ARM image, using virtio devices and enabling Spice protocol for display and serial communication.",
        "type": "comment"
    },
    "1764": {
        "file_id": 242,
        "content": "o-net-pci,mac=9A:B7:7D:21:25:67,netdev=net0 -netdev vmnet-shared,id=net0 -device virtio-ramfb -cpu host -smp cpus=4,sockets=1,cores=4,threads=1 -machine virt -accel hvf -drive if=pflash,format=raw,unit=0,file='/Applications/UTM.app/Contents/Resources/qemu/edk2-aarch64-code.fd',readonly=on -drive if=pflash,unit=1,file='/Volumes/Toshiba XG3/UTM VMs/Ubuntu ARM.utm/Data/efi_vars.fd' -m 2048 -device intel-hda -device hda-duplex -device nec-usb-xhci,id=usb-bus -device usb-tablet,bus=usb-bus.0 -device usb-mouse,bus=usb-bus.0 -device usb-kbd,bus=usb-bus.0 -device qemu-xhci,id=usb-controller-0 -chardev spicevmc,name=usbredir,id=usbredirchardev0 -device usb-redir,chardev=usbredirchardev0,id=usbredirdev0,bus=usb-controller-0.0 -chardev spicevmc,name=usbredir,id=usbredirchardev1 -device usb-redir,chardev=usbredirchardev1,id=usbredirdev1,bus=usb-controller-0.0 -chardev spicevmc,name=usbredir,id=usbredirchardev2 -device usb-redir,chardev=usbredirchardev2,id=usbredirdev2,bus=usb-controller-0.0 -devic",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/macos_utm_run_qemu.sh:44-44"
    },
    "1765": {
        "file_id": 242,
        "content": "Setting up a virtual machine for UTM, using QEMU, with ARM architecture, PCI device, network configuration, virtio-ramfb display, host CPU, SMP configuration, 2048MB memory, Intel HDA sound, USB devices, XHCI controller and SPICE redirection.",
        "type": "comment"
    },
    "1766": {
        "file_id": 242,
        "content": "e usb-storage,drive=drive18D1A7CE-50FE-4567-B033-B2AB9F811108,removable=true,bootindex=0,bus=usb-bus.0 -drive if=none,media=cdrom,id=drive18D1A7CE-50FE-4567-B033-B2AB9F811108,readonly=on -device virtio-blk-pci,drive=drive335D6651-2B4B-47A7-99B4-CBFB1EFDEFF8,bootindex=1 -drive if=none,media=disk,id=drive335D6651-2B4B-47A7-99B4-CBFB1EFDEFF8,file='/Volumes/Toshiba XG3/UTM VMs/Ubuntu ARM.utm/Data/335D6651-2B4B-47A7-99B4-CBFB1EFDEFF8.qcow2',discard=unmap,detect-zeroes=unmap -device virtio-serial -device virtserialport,chardev=vdagent,name=com.redhat.spice.0 -chardev spicevmc,id=vdagent,debug=0,name=vdagent -name Linux -uuid B54F0831-B34F-404D-B600-5E2886D8AC53 -device virtio-rng-pci",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/macos_utm_run_qemu.sh:44-44"
    },
    "1767": {
        "file_id": 242,
        "content": "Attaching USB storage, defining CD-ROM and primary disk for Ubuntu ARM VM on macOS using QEMU with virtio-serial and Spice support.",
        "type": "comment"
    },
    "1768": {
        "file_id": 243,
        "content": "/ubuntu_qemu_utm_arm_record/main_loop.sh",
        "type": "filepath"
    },
    "1769": {
        "file_id": 243,
        "content": "This script runs an infinite loop that kills all running python3 processes, then restarts the main_recorder.py script. It requires sudo privileges to run as root.",
        "type": "summary"
    },
    "1770": {
        "file_id": 243,
        "content": "while true; do ps aux | grep python3 | awk '{print $2}' | xargs -iabc kill -s TERM abc ; python3 main_recorder.py; done;\n# use sudo!\n# sudo -u root bash",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/main_loop.sh:1-3"
    },
    "1771": {
        "file_id": 243,
        "content": "This script runs an infinite loop that kills all running python3 processes, then restarts the main_recorder.py script. It requires sudo privileges to run as root.",
        "type": "comment"
    },
    "1772": {
        "file_id": 244,
        "content": "/ubuntu_qemu_utm_arm_record/main_recorder.py",
        "type": "filepath"
    },
    "1773": {
        "file_id": 244,
        "content": "The code handles audio, video, and HID recording with Redis signaling, manages folders, starts processes based on preferences, checks statuses, and ensures proper locking and error handling.",
        "type": "summary"
    },
    "1774": {
        "file_id": 244,
        "content": "import time\nimport subprocess\nimport datetime\nimport os\nfrom utils import (\n    set_redis_on,\n    set_redis_off,\n    set_prefix,\n    get_prefix,\n    check_redis_on,\n    check_redis_off,\n    PYTHON_EXECUTABLE,\n    set_redis_off_on_exception,\n    filepaths,\n    MAX_RECORDING_COUNT,\n)\nset_prefix()\nset_redis_off_on_exception(main=True)\nMINIBREAK_SECONDS = 1\nRECORD_SECONDS = 10\nWAIT_TIMEOUT = 1\n# how to signal multiple threads at once? use redis.\nset_redis_off()\ntime.sleep(MINIBREAK_SECONDS)\nRECORDERS = {\"Audio\": False, \"Video\": True, \"HID\": True}\n# RECORDERS = {\"Audio\": False, \"Video\": False, \"HID\": True}\n# RECORDERS = {\"Audio\": True, \"Video\": False, \"HID\": False}\n# RECORDERS = {\"Audio\": True, \"Video\": True, \"HID\": True}\nRANDOM_ACTOR = True\n# keep last 30 recordings.\n# will remove anything more than that.\nrec_folders = [\n    \"{}{}\".format(filepaths.target_prefix, p)\n    for p in os.listdir(filepaths.target_prefix)\n    if os.path.isdir(\"{}{}\".format(filepaths.target_prefix, p))\n]\nrec_folders.sort(key=lambda p: -os.path.getmti",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/main_recorder.py:1-44"
    },
    "1775": {
        "file_id": 244,
        "content": "The code is setting up various configurations and variables for recording audio, video, and HID events. It uses Redis for thread signaling and keeps the last 30 recordings.",
        "type": "comment"
    },
    "1776": {
        "file_id": 244,
        "content": "me(p))\nexpired_rec_folders = rec_folders[MAX_RECORDING_COUNT:]\nprint(\"EXPIRED RECORDING FOLDER COUNT:\", len(expired_rec_folders))\nfor p in expired_rec_folders:\n    print(\"REMOVING EXPIRED RECORDING FOLDER:\", p)\n    os.system(\"rm -rf {}\".format(p))\nif all([signal is not True for _, signal in RECORDERS.items()]):\n    raise Exception(\"Should at least use one recorder.\")\nelse:\n    for key, value in RECORDERS.items():\n        if value:\n            print(\"Recording: %s\" % key)\nif check_redis_off():\n    set_redis_on()\n    time.sleep(MINIBREAK_SECONDS)\n    if check_redis_on():\n        print(\"EXECUTING MAIN PROCESSES\")\n        print(\"RECORD LENGTH: {} secs\".format(RECORD_SECONDS))\n        # execute subcommands. (subprocess)\n        if RECORDERS[\"HID\"]:\n            HIDRecorderProcess = subprocess.Popen(\n                [PYTHON_EXECUTABLE, \"mouse_keyboard_record.py\"]\n            )\n        if RECORDERS[\"Video\"]:\n            VideoRecorderProcess = subprocess.Popen(\n                [PYTHON_EXECUTABLE, \"video_record.py\"]\n    ",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/main_recorder.py:44-71"
    },
    "1777": {
        "file_id": 244,
        "content": "Code is removing expired recording folders and starting main processes based on user's preferences.",
        "type": "comment"
    },
    "1778": {
        "file_id": 244,
        "content": "        )\n        if RECORDERS[\"Audio\"]:\n            AudioRecorderProcess = subprocess.Popen(\n                [PYTHON_EXECUTABLE, \"audio_record.py\"]\n            )\n        if RANDOM_ACTOR:\n            RandomActorProcess = subprocess.Popen(\n                [PYTHON_EXECUTABLE, \"random_actor_redis.py\"]\n            )\n        # time.sleep(RECORD_SECONDS)\n        for _ in range(RECORD_SECONDS):\n            time.sleep(1)\n            if check_redis_off():\n                print(\"Abnormal recorder exit detected.\")\n                print(\"Abort main recorder.\")\n                break\n        print(\"EXITING.\")\n        print(\"SET LOCK AS OFF.\")\n        set_redis_off()\n        time.sleep(MINIBREAK_SECONDS)\n        if check_redis_off():\n            exit_codes = []\n            if RECORDERS[\"HID\"]:\n                hid_exit_code = HIDRecorderProcess.wait(timeout=WAIT_TIMEOUT)\n                exit_codes.append(hid_exit_code)\n            if RECORDERS[\"Video\"]:\n                video_exit_code = VideoRecorderProcess.wait(\n              ",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/main_recorder.py:71-99"
    },
    "1779": {
        "file_id": 244,
        "content": "Checks if audio and random actor recorders should run, then starts them. Waits for RECORD_SECONDS before checking if any recorder abnormally exited. If so, aborts main recorder and sets redis lock as off. After a MINIBREAK_SECONDS delay, checks if the redis lock is still off and exits if it is.",
        "type": "comment"
    },
    "1780": {
        "file_id": 244,
        "content": "      timeout=WAIT_TIMEOUT)\n                exit_codes.append(video_exit_code)\n            if RECORDERS[\"Audio\"]:\n                audio_exit_code = AudioRecorderProcess.wait(\n                    timeout=WAIT_TIMEOUT)\n                exit_codes.append(audio_exit_code)\n            if RANDOM_ACTOR:\n                random_actor_exit_code = RandomActorProcess.wait(\n                    timeout=WAIT_TIMEOUT*3)\n                exit_codes.append(random_actor_exit_code)\n            print()\n            print(\"EXIT CODES:\")\n            if RECORDERS[\"Audio\"]:\n                print(\"AUDIO - {}\".format(audio_exit_code))\n            if RECORDERS[\"Video\"]:\n                print(\"VIDEO - {}\".format(video_exit_code))\n            if RECORDERS[\"HID\"]:\n                print(\"HID - {}\".format(hid_exit_code))\n            if RANDOM_ACTOR:\n                print(\"RANDOM_ACTOR - {}\".format(random_actor_exit_code))\n            print()\n            if any([code != 0 for code in exit_codes]):\n                # you may remove all temp file",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/main_recorder.py:99-121"
    },
    "1781": {
        "file_id": 244,
        "content": "This code checks for the exit codes of various processes (Audio, Video, HID, and RandomActor) using wait() function. It then appends these exit codes to a list called exit_codes. If any of the exit codes are not 0, it prints the exit codes and removes all temporary files.",
        "type": "comment"
    },
    "1782": {
        "file_id": 244,
        "content": "s under recorder folder.\n                prefix = get_prefix()\n                hid_record = \"{}hid_record.jsonl\".format(prefix)\n                audio_record = \"{}audio_record.wav\".format(prefix)\n                video_record = \"{}video_record.mp4\".format(prefix)\n                video_record_script = \"{}video_record_script.sh\".format(prefix)\n                video_timestamps = \"{}video_timestamps.json\".format(prefix)\n                hid_timestamps = \"{}hid_timestamps.json\".format(prefix)\n                audio_timestamps = \"{}audio_timestamps.json\".format(prefix)\n                for fpath in [\n                    hid_record,\n                    audio_record,\n                    video_record,\n                    video_record_script,\n                    video_timestamps,\n                    hid_timestamps,\n                    audio_timestamps,\n                ]:\n                    try:\n                        os.remove(fpath)\n                    except:\n                        pass\n                raise Exceptio",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/main_recorder.py:121-144"
    },
    "1783": {
        "file_id": 244,
        "content": "This code is deleting specific recorded files (hid_record, audio_record, video_record, etc.) in the recorder folder.",
        "type": "comment"
    },
    "1784": {
        "file_id": 244,
        "content": "n(\"COMPUTER RECORDER HAS ABNORMAL EXIT CODE.\")\n            else:\n                print(\"COMPUTER RECORDER EXIT NORMALLY\")\n                # required for ntfs.\n                current_timestamp = (\n                    datetime.datetime.now().isoformat().replace(\":\", \"_\")\n                )\n                records_folder = \"{}{}\".format(\n                    filepaths.target_prefix, current_timestamp)\n                # records_folder = \"{}{}\".format(filepaths.prefix, current_timestamp)\n                print(\"MOVING RECORDS TO: {}\".format(records_folder))\n                os.mkdir(records_folder)\n                for fpath in [\n                    filepaths.hid_record,\n                    filepaths.audio_record,\n                    filepaths.video_record,\n                    filepaths.video_record_script,\n                    filepaths.video_timestamps,\n                    filepaths.hid_timestamps,\n                    filepaths.audio_timestamps,\n                ]:\n                    os.system(\"mv {} {}\".format(fp",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/main_recorder.py:144-165"
    },
    "1785": {
        "file_id": 244,
        "content": "Code snippet checks if the computer recorder exited normally or not. If it exited abnormally, it displays a message indicating an abnormal exit code. If it exits normally, it creates a records folder with the current timestamp and moves recorded files to that folder for organization purposes.",
        "type": "comment"
    },
    "1786": {
        "file_id": 244,
        "content": "ath, records_folder))\n                # print(\"MAKING FINISHED INDICATOR\")\n                # os.system(\"touch {}\".format(os.path.join(records_folder, \"finished\")))\n                # or this is not needed. because it is always hard to savage things from a running instance.\n        else:\n            print(\"FAILED TO SET LOCK AS OFF.\")\n            print(\"FAILED AT FINAL CHECK.\")\n    else:\n        print(\"FAILED TO SET LOCK AS ON.\")\n        print(\"FAILED AT INIT CHECK 2\")\nelse:\n    print(\"FAILED TO SET LOCK AS OFF.\")\n    print(\"FAILED AT INIT CHECK 1\")",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/main_recorder.py:165-177"
    },
    "1787": {
        "file_id": 244,
        "content": "Checks if the lock is set correctly and prints appropriate failure messages.",
        "type": "comment"
    },
    "1788": {
        "file_id": 245,
        "content": "/ubuntu_qemu_utm_arm_record/mount_kali_webdav_dirs.sh",
        "type": "filepath"
    },
    "1789": {
        "file_id": 245,
        "content": "Mount and configure two WebDAV directories, create script and recordings folders, and symlink the mounted WebDAV directories to the newly created folders.",
        "type": "summary"
    },
    "1790": {
        "file_id": 245,
        "content": "echo -e \"110110\\n\" | sudo -S echo \"enable sudo\"\nsudo apt install -y davfs2\nsudo umount /mnt/dav1\nsudo umount /mnt/dav2\nsudo rm -rf /mnt/dav1\nsudo rm -rf /mnt/dav2\nsudo mkdir /mnt/dav1\nsudo mkdir /mnt/dav2\necho -e \"root\\nroot\\n\" | sudo mount -t davfs -o noexec http://10.0.1.6:8110 /mnt/dav1\necho -e \"root\\nroot\\n\" | sudo mount -t davfs -o noexec http://10.0.1.6:8111 /mnt/dav2\nmkdir scripts\nmkdir recordings\nln -s /mnt/dav1 scripts\nln -s /mnt/dav2 recordings\n# just start stuff here.\n# sudo bash main_loop.sh",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/mount_kali_webdav_dirs.sh:1-23"
    },
    "1791": {
        "file_id": 245,
        "content": "Mount and configure two WebDAV directories, create script and recordings folders, and symlink the mounted WebDAV directories to the newly created folders.",
        "type": "comment"
    },
    "1792": {
        "file_id": 246,
        "content": "/ubuntu_qemu_utm_arm_record/mount_yoga_webdav_dir.sh",
        "type": "filepath"
    },
    "1793": {
        "file_id": 246,
        "content": "Enabling sudo, installing necessary Python packages, removing DAVFS pid locks, installing davfs2, creating and preparing mount point directories, and setting up WebDAV shares for storing scripts and recordings.",
        "type": "summary"
    },
    "1794": {
        "file_id": 246,
        "content": "cd agi_computer_control/ubuntu_qemu_utm_arm_record\n# enable sudo\necho -e \"KSDA37287522\\n\" | sudo -S echo \"enable sudo\"\nsudo apt-get install -y python3-tk python3-dev\n# remove davfs pid locks\nsudo rm /var/run/mount.davfs/mnt-dav1.pid\nsudo rm /var/run/mount.davfs/mnt-dav2.pid\nsudo apt install -y davfs2\n#sudo mkdir /mnt/dav1\nsudo mkdir /mnt/dav2\nsudo umount /mnt/dav1\nsudo umount /mnt/dav2\nsudo rm -rf scripts\nsudo rm -rf recordings\n#echo -e \"root\\nroot\\n\" | sudo mount -t davfs -o noexec http://192.168.56.1:8110 /mnt/dav1\necho -e \"root\\nroot\\n\" | sudo mount -t davfs -o noexec http://192.168.56.1:8111 /mnt/dav2\n#mkdir scripts\n#mkdir recordings\n#ln -s /mnt/dav1 scripts\nln -s /mnt/dav2 recordings",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/mount_yoga_webdav_dir.sh:1-28"
    },
    "1795": {
        "file_id": 246,
        "content": "Enabling sudo, installing necessary Python packages, removing DAVFS pid locks, installing davfs2, creating and preparing mount point directories, and setting up WebDAV shares for storing scripts and recordings.",
        "type": "comment"
    },
    "1796": {
        "file_id": 247,
        "content": "/ubuntu_qemu_utm_arm_record/mouse_keyboard_record.py",
        "type": "filepath"
    },
    "1797": {
        "file_id": 247,
        "content": "The code uses the `pyautogui` library to import essential modules, define functions for capturing keyboard and mouse events, and record HID events in a JSON lines file with timestamps. Recording begins when Redis is offline, or an exception is raised if the Redis connection fails or is off.",
        "type": "summary"
    },
    "1798": {
        "file_id": 247,
        "content": "# import datetime\nfrom utils import (\n    filepaths,\n    check_redis_on,\n    check_redis_off,\n    TimestampedContext,\n    set_redis_off_on_exception,\n)\nimport jsonlines\nimport time\nfrom pynput import mouse\nfrom utils import timestep  # this will be sufficient?\nfrom pynput import keyboard\nHIDEvents = []\nset_redis_off_on_exception()\n# problem is the windows zooming factor.\n# is it really the problem?\ndef on_press(key):\n    if type(key) != str:\n        key = str(key)\n    HIDEvents.append((\"key_press\", key))\ndef on_release(key):\n    if type(key) != str:\n        key = str(key)\n    HIDEvents.append((\"key_release\", key))\nkeyboard_listener = keyboard.Listener(on_press=on_press, on_release=on_release)\nkeyboard_listener.start()\ndef on_move(x: int, y: int):\n    HIDEvents.append((\"mouse_move\", [x, y]))\ndef on_click(x: int, y: int, button: mouse.Button, pressed: bool):\n    HIDEvents.append((\"mouse_click\", [x, y, str(button), pressed]))\ndef on_scroll(x: int, y: int, dx: int, dy: int):\n    HIDEvents.append((\"mouse_scroll\", [x, y, d",
        "type": "code",
        "location": "/ubuntu_qemu_utm_arm_record/mouse_keyboard_record.py:1-49"
    },
    "1799": {
        "file_id": 247,
        "content": "The code imports necessary modules and defines functions for capturing keyboard and mouse events, and then starts listening for these events. It appends the recorded events to a list called HIDEvents in the format (\"event_type\", event_data).",
        "type": "comment"
    }
}