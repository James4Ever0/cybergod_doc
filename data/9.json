{
    "900": {
        "file_id": 115,
        "content": "/mouse-and-keyboard-encoding-fft.py",
        "type": "filepath"
    },
    "901": {
        "file_id": 115,
        "content": "The code uses Fast Fourier Transform (FFT) for mouse position encoding, discusses LSTM/GRU neural networks for complex inputs and Fourier transforms, and considers vector space sharing in non-standard ways. It also explores embeddings with token embedding and task type decoding, low-rank adaptation over linear layers for efficiency, and use cases like identifying words/images/actions and positional encodings.",
        "type": "summary"
    },
    "902": {
        "file_id": 115,
        "content": "#!/usr/bin/env python\n# coding: utf-8\n# In[1]:\nimport torch\n# mouse -> sparse encoding -> fft -> ifft -> unified decoder\ndim_0_range = 1000\ndim_1_range = 100\nmouse_coords = [(20,20,None,None), (200,200,30,30)]\n# In[2]:\n# what about sparse encoding?\n# single value -> bunch of binary values\n# elementwise product random vector -> select non-zero ones\nimport random\nrandom.seed(42)\nwindow_size = 200 \nmrange = list(range(window_size+dim_0_range-1))\nrandom.shuffle(mrange)\n# mlist = [mrange[i:i+window_size] for i in range(dim_0_range)]\n# keep it sparse?\nunified_encoding = torch.randn((1,window_size+dim_0_range-1), requires_grad=True)\n# that's how you initialize your \"semantic\" or \"continual\" mouse embeddings.\nmlist = []\nnext_comb = mrange[:window_size]\n# random.shuffle(next_comb)\nmlist.append(next_comb.copy())\nfor i in range(dim_0_range-1):\n#     last_item = mrange[i+window_size-1]\n    alt_item = mrange[i+window_size]\n    last_item_index = random.choice(range(window_size))\n    next_comb[last_item_index] = alt_item\n#     pr",
        "type": "code",
        "location": "/mouse-and-keyboard-encoding-fft.py:1-55"
    },
    "903": {
        "file_id": 115,
        "content": "This code is setting up the mouse coordinates, window size, and creating a sparse encoding for the mouse positions using Fast Fourier Transform (FFT) operations. The code also initializes the unified encoding tensor and starts populating it with random values. It shuffles the range of indices within the window size and appends them to the list 'mlist'.",
        "type": "comment"
    },
    "904": {
        "file_id": 115,
        "content": "int(torch.Tensor([next_comb]))\n#     print(\"SUM?\", sum(next_comb))\n    mlist.append(next_comb.copy())\n# import rich\nprint(\"LENGTH?\", len(mlist))\n# rich.print(\"MLIST?\", mlist)\n# for e in mlist:\n#     print(sum(e))\nmLongTensorList = torch.LongTensor(mlist) # that looks like the thing.\nmLongTensorList.shape\n# In[3]:\ntorch.index_select(unified_encoding, 1, mLongTensorList[0,:])\n# In[4]:\n# how to represent keyboard keydown signals?\n# telephone?\n# embedding plus one trainable sin keydown signal? or using fft?\n# how to represent special tokens? by sin? all by sin?\n# what will happen if you try to share vector space in non-standard way?\n# such as split and concat?\n# you may do split and concat in fft though.\n# such as: value repr by concat -> ifft -> LSTM -> fft -> argmax things\n# ifft let the model \"feel\" the bits, though fft \"extract\" freq and handle bits.\n# there are multiple ways to do this.\n# but fft brings \"imaginary\" part to numbers.\n# you can feed both parts separetely into the network, then combine different",
        "type": "code",
        "location": "/mouse-and-keyboard-encoding-fft.py:55-98"
    },
    "905": {
        "file_id": 115,
        "content": "This code seems to be part of a larger program that involves encoding mouse and keyboard events using Fourier Transform (FFT). It appears to store the encoded events in a list, then create a LongTensorList from it. The author is considering different methods for representing special tokens and discussing the impact of sharing vector spaces in non-standard ways, like split and concat. The code also mentions the use of Fourier Transform for extracting frequency information and handling bits.",
        "type": "comment"
    },
    "906": {
        "file_id": 115,
        "content": " parts.\n# the you may calculate the grad? by adding different part of the loss?\n# or you use \"native\" complex neural networks, to handle the fft transforms.\n# or you simply ignore complex input. only taking real parts?\n# lstm contains hidden state and cell state\n# while GRU only contains hidden state.\n# adding real and imag? or passing through different NN? or same NN?\n# telling you, do it first. we will handle the comparison.\n# so are you going to tell me that my model is just complete\n# that i need not to do too much to collect data and start training?\n# yes. i am going to tell you to start training.\n# you have reached the utopia of fourier transform (rfft/hfft).\n# now let's roll!\n# In[ ]:\n# for ubuntu arm: pyautogui -> python script writing timestamp\n# write to stdout -> pipe to ffmpeg -> write to video\n# find the location of the shared directory of utm\n# how do i know if my model is spitting words instead of images/actions?\n# do we need to take over few \"positional encodings\"?\n# you can add task spec",
        "type": "code",
        "location": "/mouse-and-keyboard-encoding-fft.py:98-129"
    },
    "907": {
        "file_id": 115,
        "content": "The code discusses the use of Fourier transforms in a model, potentially using LSTM or GRU neural networks to handle the complex input. It suggests that the model may not need additional modifications and can start training immediately since it has reached the \"utopia\" of Fourier transform (rfft/hfft). The code also mentions potential use cases for the trained model, like identifying if it's producing words or images/actions, and considering positional encodings.",
        "type": "comment"
    },
    "908": {
        "file_id": 115,
        "content": "ific embeddings with token embedding\n# then decode the task type in the end, classify the token.\n# fft may not be needed, since that will be too much computation.\n# you may just want low rank adaption over some linear layers.\n# fft may be useful for your visual convolution.",
        "type": "code",
        "location": "/mouse-and-keyboard-encoding-fft.py:129-135"
    },
    "909": {
        "file_id": 115,
        "content": "This code snippet is discussing the use of embeddings with token embedding, task type decoding, and possible use of FFT (Fast Fourier Transform) for visual convolution. It also mentions the potential need for low-rank adaptation over linear layers instead of relying on FFT for computation efficiency.",
        "type": "comment"
    },
    "910": {
        "file_id": 116,
        "content": "/mydatamodel.py",
        "type": "filepath"
    },
    "911": {
        "file_id": 116,
        "content": "This code generates a Python class based on the MyDataModel.yaml file, using Pydantic's BaseModel to define the data model classes Data and MyModel.",
        "type": "summary"
    },
    "912": {
        "file_id": 116,
        "content": "# generated by datamodel-codegen:\n#   filename:  mydatamodel.yaml\n#   timestamp: 2023-07-08T05:40:44+00:00\nfrom __future__ import annotations\nfrom pydantic import BaseModel\nclass Data(BaseModel):\n    a: int\n    b: int\nclass MyModel(BaseModel):\n    data: Data",
        "type": "code",
        "location": "/mydatamodel.py:1-16"
    },
    "913": {
        "file_id": 116,
        "content": "This code generates a Python class based on the MyDataModel.yaml file, using Pydantic's BaseModel to define the data model classes Data and MyModel.",
        "type": "comment"
    },
    "914": {
        "file_id": 117,
        "content": "/mydatamodel.yaml",
        "type": "filepath"
    },
    "915": {
        "file_id": 117,
        "content": "This code contains YAML formatted data with two sets of variables: \"data\" and \"data2\". Each set has key-value pairs where the keys are letters (a, b) and values are numbers (1, 2).",
        "type": "summary"
    },
    "916": {
        "file_id": 117,
        "content": "data:\n  a: 1\n  b: 2\n# ---\n# data2:\n#   a: 2\n#   b: 3\n#   d: 4",
        "type": "code",
        "location": "/mydatamodel.yaml:1-10"
    },
    "917": {
        "file_id": 117,
        "content": "This code contains YAML formatted data with two sets of variables: \"data\" and \"data2\". Each set has key-value pairs where the keys are letters (a, b) and values are numbers (1, 2).",
        "type": "comment"
    },
    "918": {
        "file_id": 118,
        "content": "/mypy_check.py",
        "type": "filepath"
    },
    "919": {
        "file_id": 118,
        "content": "The code uses mock testing, lru_cached, and API functions for verification. It defines a class \"MyClass\" with properties age, factors (commented), my_list, and creates a sample tensor function.",
        "type": "summary"
    },
    "920": {
        "file_id": 118,
        "content": "import mypy.api as api\n# you may use mock testing, similar to symbolic execution.\n# you may ensure compatibility between non-mock based operation, or ensure all functions are mock calls.\n# mock functions shall be lru_cached, to speedup overheads.\nresult = api.run(...)  # commandline args.\nimport tensorflow as tf\nfrom tensor_annotations import axes # by deepmind.\nimport tensor_annotations.tensorflow as ttf\nfrom typing import NewType, List\nfrom typing_extensions import Annotated\nuint8 = ttf.uint8\nBatch, Time = Annotated[axes.Batch, 3], Annotated[axes.Time, 5] # problem is, how to share this along with function calls?\nMyAxis = NewType(\"MyAxis\", axes.Axis)\n# from pycontract import contract\n# @contract\n# def my_function(a, b):\n#     \"\"\" Function description.\n#         :type a: int,>0\n#         :type b: list[N],N>0\n#         :rtype: list[N]\n#     \"\"\"\n#     ...\n# def sample_batch() -> ttf.Tensor2[uint8, Time, Batch]:\n#     return tf.zeros((3, 5))\nfrom typing_extensions import Annotated\nfrom annotated_types import Gt,",
        "type": "code",
        "location": "/mypy_check.py:1-39"
    },
    "921": {
        "file_id": 118,
        "content": "Importing the mypy.api as api.\nMock testing can be used for verification and compatibility checking between mock-based and non-mock operations. \nUsing lru_cached to speed up overheads for mock functions.\nCalling the api.run function with command line arguments. \nImporting TensorFlow and tensor_annotations.axes from DeepMind.\nUsing Annotated type from typing_extensions to define Batch and Time axes.\nDefining a new type, MyAxis, using NewType from typing_extensions.\nImporting pycontract for code contract implementation.\nDefining the my_function with its parameters and return types.\nCreating sample_batch function that returns a tensor of type ttf.Tensor2[uint8, Time, Batch]. \nUsing Annotated type from typing_extensions to define Gt type.",
        "type": "comment"
    },
    "922": {
        "file_id": 118,
        "content": " Len, Predicate\nclass MyClass:\n    age: Annotated[int, Gt(18)]                         # Valid: 19, 20, ...\n                                                        # Invalid: 17, 18, \"19\", 19.0, ...\n    # factors: List[Annotated[int, Predicate(is_prime)]]  # Valid: 2, 3, 5, 7, 11, ...\n    #                                                     # Invalid: 4, 8, -2, 5.0, \"prime\", ...\n    my_list: Annotated[List[int], Len(0, 10)]           # Valid: [], [10, 20, 30, 40, 50]\n                                                        # Invalid: (1, 2), [\"abc\"], [0] * 20",
        "type": "code",
        "location": "/mypy_check.py:39-48"
    },
    "923": {
        "file_id": 118,
        "content": "The code defines a class \"MyClass\" with properties age, factors (commented out), and my_list. Age is valid if greater than 18, factors is supposed to be a list of prime numbers but commented out, and my_list is a list of integers between 0 and 10 length.",
        "type": "comment"
    },
    "924": {
        "file_id": 119,
        "content": "/off_streaming_utils.sh",
        "type": "filepath"
    },
    "925": {
        "file_id": 119,
        "content": "Killing streaming_utils session and related processes.\n\nQuestion (0-1): Can you provide a brief explanation of what the code does?",
        "type": "summary"
    },
    "926": {
        "file_id": 119,
        "content": "tmux kill-session -t streaming_utils\nps aux | grep bash | grep -v grep | grep kali_prepare_dirs_loop.sh | awk '{print $2}' | xargs -iabc kill -s TERM abc\ntmux kill-session -t kali_prepare_two_webdav_dirs\n# location of ubuntu vm: 10.0.2.15",
        "type": "code",
        "location": "/off_streaming_utils.sh:1-5"
    },
    "927": {
        "file_id": 119,
        "content": "Killing streaming_utils session and related processes.\n\nQuestion (0-1): Can you provide a brief explanation of what the code does?",
        "type": "comment"
    },
    "928": {
        "file_id": 120,
        "content": "/packup.cmd",
        "type": "filepath"
    },
    "929": {
        "file_id": 120,
        "content": "This code is archiving the \"agi_computer_control\" directory, removing the original 7z file, and moving a backup copy into the directory.",
        "type": "summary"
    },
    "930": {
        "file_id": 120,
        "content": "rm agi_computer_control.7z\ncd ..\n7z a -snl agi_computer_control.7z agi_computer_control\ncd agi_computer_control\nmv ../agi_computer_control.7z .",
        "type": "code",
        "location": "/packup.cmd:1-5"
    },
    "931": {
        "file_id": 120,
        "content": "This code is archiving the \"agi_computer_control\" directory, removing the original 7z file, and moving a backup copy into the directory.",
        "type": "comment"
    },
    "932": {
        "file_id": 121,
        "content": "/packup.sh",
        "type": "filepath"
    },
    "933": {
        "file_id": 121,
        "content": "Removing file, changing directory, archiving files with 7-Zip, and moving file into place.",
        "type": "summary"
    },
    "934": {
        "file_id": 121,
        "content": "rm agi_computer_control.7z\ncd ..\n7z a -snl agi_computer_control.7z agi_computer_control\ncd agi_computer_control\nmv ../agi_computer_control.7z .",
        "type": "code",
        "location": "/packup.sh:1-5"
    },
    "935": {
        "file_id": 121,
        "content": "Removing file, changing directory, archiving files with 7-Zip, and moving file into place.",
        "type": "comment"
    },
    "936": {
        "file_id": 122,
        "content": "/player.py",
        "type": "filepath"
    },
    "937": {
        "file_id": 122,
        "content": "The code uses Pynput to control keyboard/mouse, handles DPI-awareness on Windows and initializes via hotkeys. It maintains event order but lacks \"ctrl + /\" handling, supporting various actions for both keyboard and mouse input.",
        "type": "summary"
    },
    "938": {
        "file_id": 122,
        "content": "# just to play the recorded events out.\n# not doing anything beyond that.\n# special keys are not recorded. what a shame.\nimport ast\nimport os\n# what about \"ctrl + /\" ?\ndef unshift(key):\n    lower_keycodes = {\n        \"A\": \"a\",\n        \"B\": \"b\",\n        \"C\": \"c\",\n        \"D\": \"d\",\n        \"E\": \"e\",\n        \"F\": \"f\",\n        \"G\": \"g\",\n        \"H\": \"h\",\n        \"I\": \"i\",\n        \"J\": \"j\",\n        \"K\": \"k\",\n        \"L\": \"l\",\n        \"M\": \"m\",\n        \"N\": \"n\",\n        \"O\": \"o\",\n        \"P\": \"p\",\n        \"Q\": \"q\",\n        \"R\": \"r\",\n        \"S\": \"s\",\n        \"T\": \"t\",\n        \"U\": \"u\",\n        \"V\": \"v\",\n        \"W\": \"w\",\n        \"X\": \"x\",\n        \"Y\": \"y\",\n        \"Z\": \"z\",\n    }\n    unshift_keycodes = {\n        \"!\": \"1\",\n        \"@\": \"2\",\n        \"#\": \"3\",\n        \"$\": \"4\",\n        \"%\": \"5\",\n        \"^\": \"6\",\n        \"&\": \"7\",\n        \"*\": \"8\",\n        \"(\": \"9\",\n        \")\": \"0\",\n        \"_\": \"-\",\n        \"+\": \"=\",\n        \"{\": \"[\",\n        \"}\": \"]\",\n        \"|\": \"\\\\\",\n        \":\": \";\",\n        '\"': \"'\",\n        \"<\": \",\",\n        \">\": \".\",\n    ",
        "type": "code",
        "location": "/player.py:1-60"
    },
    "939": {
        "file_id": 122,
        "content": "The code defines a dictionary of lower and unshift keycodes, allowing for the conversion between them. It also mentions that special keys like \"ctrl + /\" are not recorded, which is a limitation in the system.",
        "type": "comment"
    },
    "940": {
        "file_id": 122,
        "content": "    \"?\": \"/\",\n        \"~\": \"`\",\n    }\n    ctrl_keycodes = {\n        \"\\x01\": \"a\",\n        \"\\x02\": \"b\",\n        \"\\x03\": \"c\",\n        \"\\x04\": \"d\",\n        \"\\x05\": \"e\",\n        \"\\x06\": \"f\",\n        \"\\x07\": \"g\",\n        \"\\x08\": \"h\",\n        \"\\t\": \"i\",\n        \"\\n\": \"j\",\n        \"\\x0b\": \"k\",\n        \"\\x0c\": \"l\",\n        \"\\r\": \"m\",\n        \"\\x0e\": \"n\",\n        \"\\x0f\": \"o\",\n        \"\\x10\": \"p\",\n        \"\\x11\": \"q\",\n        \"\\x12\": \"r\",\n        \"\\x13\": \"s\",\n        \"\\x14\": \"t\",\n        \"\\x15\": \"u\",\n        \"\\x16\": \"v\",\n        \"\\x17\": \"w\",\n        \"\\x18\": \"x\",\n        \"\\x19\": \"y\",\n        \"\\x1a\": \"z\",\n        \"<219>\": \"[\",\n        \"<221>\": \"]\",\n        \"<189>\": \"-\",\n        \"<187>\": \"=\",\n        \"<192>\": \"`\",\n        \"<48>\": \"0\",\n        \"<49>\": \"1\",\n        \"<50>\": \"2\",\n        \"<51>\": \"3\",\n        \"<52>\": \"4\",\n        \"<53>\": \"5\",\n        \"<54>\": \"6\",\n        \"<55>\": \"7\",\n        \"<56>\": \"8\",\n        \"<57>\": \"9\",\n        \"<220>\": \"\\\\\",\n        \"<186>\": \";\",\n        \"<222>\": \"'\",\n        \"<188>\": \",\",\n        \"<190>\": \".\",\n        \"<191>\": \"/",
        "type": "code",
        "location": "/player.py:60-110"
    },
    "941": {
        "file_id": 122,
        "content": "This code defines two dictionaries: one for special characters and another for keyboard keycodes. It maps each keycode to its corresponding character in ASCII format.",
        "type": "comment"
    },
    "942": {
        "file_id": 122,
        "content": "\",\n    }\n    key = unshift_keycodes.get(\n        key, ctrl_keycodes.get(key, lower_keycodes.get(key, key))\n    )\n    return key\n# how to play that?\n# using jsonl?\n# timestep = 0.01\nfrom config import timestep\n# zoom_factor = 1.75\n# you can safely ignore the zoom factor once using this in the reference:\n# https://pynput.readthedocs.io/en/latest/mouse.html#monitoring-the-mouse\nimport os\n# main problem is the hotkey. but the modifiers are certain.\n# you can know that for sure.\nif os.name == \"nt\":\n    import ctypes\n    PROCESS_PER_MONITOR_DPI_AWARE = 2\n    ctypes.windll.shcore.SetProcessDpiAwareness(PROCESS_PER_MONITOR_DPI_AWARE)\n# better use pyautogui for mouse?\nimport jsonlines\nimport time\nimport pynput\nimport pyautogui\n# filePath = \"states.jsonl\"\nfrom config import filePath\nwith jsonlines.open(filePath) as r:\n    stateList = list(r.iter())\n# import math\nkeyboard_controller = pynput.keyboard.Controller()\nmouse_controller = pynput.mouse.Controller()\nmouse_buttons = [\n    pynput.mouse.Button.left, pynput.mouse.Button.righ",
        "type": "code",
        "location": "/player.py:110-153"
    },
    "943": {
        "file_id": 122,
        "content": "This code is initializing a keyboard and mouse controller using the pynput library. It also handles DPI awareness for Windows systems, reads a JSONL file containing states, and initializes a mouse controller which can be controlled by hotkeys. The zoom factor is not important once the reference is used.",
        "type": "comment"
    },
    "944": {
        "file_id": 122,
        "content": "t, pynput.mouse.Button.middle\n]\nmouse_button_states = {button: False for button in mouse_buttons}\nfor state in stateList:\n    time.sleep(timestep)\n    # perform actions.\n    HIDEvents = state[\"HIDEvents\"]\n    # you need to preserve the order. dump all events into one single list.\n    for action_type, action_args in HIDEvents:\n        print(\"ACTION?\", action_type, action_args)\n        if action_type == \"key_press\":\n            if not action_args.startswith(\"Key.\"):\n                keycode = unshift(\n                    action_args if action_args.startswith(\"<\")\n                    and action_args.endswith(\">\") else ast.literal_eval(action_args)\n                )\n                pyautogui.write(keycode)\n            else:\n                keyboard_controller.press(\n                    pynput.keyboard.Key.__dict__[action_args.split(\".\")[-1]]\n                )\n        elif action_type == \"key_release\":\n            if action_args.startswith(\"Key.\"):\n                keyboard_controller.release(\n                    py",
        "type": "code",
        "location": "/player.py:153-179"
    },
    "945": {
        "file_id": 122,
        "content": "This code handles key and mouse events from a state list, preserving their order. It uses Pynput for keyboard and mouse controls, and PyAutoGUI for writing keys. It processes \"key_press\" and \"key_release\" events while also handling mouse button states.",
        "type": "comment"
    },
    "946": {
        "file_id": 122,
        "content": "nput.keyboard.Key.__dict__[action_args.split(\".\")[-1]]\n                )\n        elif action_type == \"mouse_move\":\n            x, y = action_args\n            # x = math.floor(x/zoom_factor)\n            # y = math.floor(y/zoom_factor)\n            mouse_controller.position = (x, y)\n        elif action_type == \"mouse_click\":\n            x, y, button, pressed = action_args\n            # x = math.floor(x/zoom_factor)\n            # y = math.floor(y/zoom_factor)\n            button = pynput.mouse.Button.__dict__[button.split(\".\")[-1]]\n            mouse_button_states[button] = pressed\n            mouse_controller.position = (x, y)\n            if pressed:\n                mouse_controller.press(button)\n            else:\n                mouse_controller.click(button)\n        elif action_type == \"mouse_scroll\":\n            x, y, dx, dy = action_args\n            # x = math.floor(x/zoom_factor)\n            # y = math.floor(y/zoom_factor)\n            # dx = math.floor(dx/zoom_factor)\n            # dy = math.floor(dy/zoom_fa",
        "type": "code",
        "location": "/player.py:179-204"
    },
    "947": {
        "file_id": 122,
        "content": "Code handles different types of actions related to keyboard and mouse input.\n\n- Keyboard action: Executes the corresponding keypress using pynput library.\n- Mouse move action: Updates the position of the mouse controller.\n- Mouse click action: Handles mouse button press or click based on pressed state.\n- Mouse scroll action: Not fully implemented due to zoom_factor calculation missing.",
        "type": "comment"
    },
    "948": {
        "file_id": 122,
        "content": "ctor)\n            mouse_controller.position = (x, y)\n            mouse_controller.scroll(dx, dy)\n        else:\n            raise Exception(\"Unknown action type: {}\".format(action_type))\n# after all the havok, you should not leave the mouse button pressed, and you should not leave any button onhold.\nmodifier_keys = [\"alt\", \"alt_gr\", \"ctrl\", \"shift\"]\nfor modifier_key in modifier_keys:\n    if keyboard_controller.__getattribute__(f\"{modifier_key}_pressed\"):\n        keyboard_controller.release(pynput.keyboard.Key.__dict__[modifier_key])\nfor button in mouse_buttons:\n    if mouse_button_states[button]:  # pressed, not released yet.\n        mouse_controller.release(button)",
        "type": "code",
        "location": "/player.py:204-220"
    },
    "949": {
        "file_id": 122,
        "content": "Updates mouse and keyboard positions based on action type.\nEnsures mouse button is not held down after movement.\nReleases modifier keys if still pressed.\nChecks for remaining held mouse buttons and releases them.",
        "type": "comment"
    },
    "950": {
        "file_id": 123,
        "content": "/propaganda/agi_computer_recordings/launch_server.cmd",
        "type": "filepath"
    },
    "951": {
        "file_id": 123,
        "content": "Executes WebDAV command to connect to host, port, and path for recordings.",
        "type": "summary"
    },
    "952": {
        "file_id": 123,
        "content": "webdav-cli --host 192.168.56.1 --port 8111 --username root --password root --path=D:\\works\\agi_computer_recordings\\recordings ",
        "type": "code",
        "location": "/propaganda/agi_computer_recordings/launch_server.cmd:1-1"
    },
    "953": {
        "file_id": 123,
        "content": "Executes WebDAV command to connect to host, port, and path for recordings.",
        "type": "comment"
    },
    "954": {
        "file_id": 124,
        "content": "/propaganda/cybergod_propaganda/README.md",
        "type": "filepath"
    },
    "955": {
        "file_id": 124,
        "content": "This folder contains propaganda materials for Cybergod and The Frozen Forest. They plan to create a video in a step-by-step approach, starting with writing the script, making short footage, and collecting material. They acknowledge the power of LLMs in content creation but want to learn the basics first, beginning with logo creation.",
        "type": "summary"
    },
    "956": {
        "file_id": 124,
        "content": "this folder contains propaganda material for cybergod and the frozen forest.\nwe plan to create the video in a \"step by step\" approach, which is writing video script along the way of making short footage and collecting material.\nit is important to realize the power of LLM in content creation. however, we shall learn the basics. i mean i am never close to \"fluent\" in video creation. so let's do it!\nfirst create logos for cybergod and the frozen forest",
        "type": "code",
        "location": "/propaganda/cybergod_propaganda/README.md:1-7"
    },
    "957": {
        "file_id": 124,
        "content": "This folder contains propaganda materials for Cybergod and The Frozen Forest. They plan to create a video in a step-by-step approach, starting with writing the script, making short footage, and collecting material. They acknowledge the power of LLMs in content creation but want to learn the basics first, beginning with logo creation.",
        "type": "comment"
    },
    "958": {
        "file_id": 125,
        "content": "/propaganda/video_script/README.md",
        "type": "filepath"
    },
    "959": {
        "file_id": 125,
        "content": "This code provides a link to search for videos on fse.agilestudio.cn and an API endpoint for the same, suggesting using ffmpeg to convert m3u8 links into videos.",
        "type": "summary"
    },
    "960": {
        "file_id": 125,
        "content": "access: https://fse.agilestudio.cn/search?keyword=%E9%94%AE%E7%9B%98%E5%92%8C%E9%BC%A0%E6%A0%87\napi access: fse-api.agilestudio.cn/api/search (may not work!)\nuse ffmpeg to convert m3u8 links into video.",
        "type": "code",
        "location": "/propaganda/video_script/README.md:1-7"
    },
    "961": {
        "file_id": 125,
        "content": "This code provides a link to search for videos on fse.agilestudio.cn and an API endpoint for the same, suggesting using ffmpeg to convert m3u8 links into videos.",
        "type": "comment"
    },
    "962": {
        "file_id": 126,
        "content": "/propaganda/video_script/clyde_script.txt",
        "type": "filepath"
    },
    "963": {
        "file_id": 126,
        "content": "The video script for Cybergod, an AI keyboard and mouse controller, showcases its concept, usage, and benefits while motivating developers to create code for it.",
        "type": "summary"
    },
    "964": {
        "file_id": 126,
        "content": "Here's a sample video script: \nTitle: Cybergod - The AI Keyboard and Mouse Controller\nOpening shot: Camera zooms in on a keyboard and mouse on a desk. Camera zooms out to show a person typing on the keyboard and moving the mouse. \nVoiceover: \"Do you ever feel like you waste too much time typing and moving your mouse around when working on your computer?\"\nCut to shot of a man getting frustrated as he types and moves his mouse.\nVoiceover: \"Imagine if there was a program that could learn from your usage data, and automate all of your typing and mouse movements for you.\"\nCut to shot of a woman sitting comfortably on the couch, holding a drink as she watches the program work on her computer.\nVoiceover: \"Introducing Cybergod - the AI keyboard and mouse controller. This innovative program learns from your daily usage data, and automates your typing and mouse movements for you.\"\nCut to a hand typing on the keyboard and moving the mouse, and then cutting to the program running in the background. \nVoiceo",
        "type": "code",
        "location": "/propaganda/video_script/clyde_script.txt:1-19"
    },
    "965": {
        "file_id": 126,
        "content": "The code is a video script for an AI keyboard and mouse controller called Cybergod. It describes the concept, shows how it can be used, and highlights its benefits.",
        "type": "comment"
    },
    "966": {
        "file_id": 126,
        "content": "ver: \"This program saves you time, energy, and lets you focus on the more important things in life.\"\nCut to shot of a man smiling as he looks at his computer screen.\nVoiceover: \"Cybergod is the future of computer control, and we encourage developers and programmers to write code for it.\"\nClosing shot: \"Get your hands on Cybergod today, and experience the freedom of automation.\"\nEnd of video.",
        "type": "code",
        "location": "/propaganda/video_script/clyde_script.txt:19-27"
    },
    "967": {
        "file_id": 126,
        "content": "This code describes the video script for promoting Cybergod, highlighting its benefits and encouraging developers to write code for it.",
        "type": "comment"
    },
    "968": {
        "file_id": 127,
        "content": "/propaganda/video_script/clyde_script_cn.txt",
        "type": "filepath"
    },
    "969": {
        "file_id": 127,
        "content": "This is a video script for introducing Cybergod - AI键鼠控制器. It highlights the benefits of using the program to automate typing and mouse movements based on usage data, saving time and energy for users. The script encourages developers and programmers to contribute code for Cybergod.",
        "type": "summary"
    },
    "970": {
        "file_id": 127,
        "content": "Title: Cybergod - AI键鼠控制器\nOpening shot: 镜头拉近到桌上的键盘和鼠标，然后拉远显示一个人正在键盘和鼠标上操作。\nVoiceover: “你有没有觉得在电脑上打字和用鼠标移动太费时间了？”\nCut to shot of a man getting frustrated as he types and moves his mouse.\nVoiceover: “想象一下，如果有一个程序可以从你的使用数据中学习，为你自动化所有的打字和鼠标操作。”\nCut to shot of a woman sitting comfortably on the couch, holding a drink as she watches the program work on her computer.\nVoiceover: “这就是Cybergod - AI键鼠控制器。这一创新性的程序可以从你的日常使用数据中学习，为你自动化打字和鼠标操作。”\nCut to a hand typing on the keyboard and moving the mouse, and then cutting to the program running in the background.\nVoiceover: “这个程序可以为你节省时间和精力，让你专注于生活中更重要的事情。”\nCut to shot of a man smiling as he looks at his computer screen.\nVoiceover: “Cybergod是电脑控制的未来，我们鼓励开发者和程序员为其编写代码。”\nClosing shot: “立即拥有Cybergod，享受自动化的自由。”\nEnd of video.",
        "type": "code",
        "location": "/propaganda/video_script/clyde_script_cn.txt:1-25"
    },
    "971": {
        "file_id": 127,
        "content": "This is a video script for introducing Cybergod - AI键鼠控制器. It highlights the benefits of using the program to automate typing and mouse movements based on usage data, saving time and energy for users. The script encourages developers and programmers to contribute code for Cybergod.",
        "type": "comment"
    },
    "972": {
        "file_id": 128,
        "content": "/propaganda/video_script/compile_script.py",
        "type": "filepath"
    },
    "973": {
        "file_id": 128,
        "content": "This code seems to be discussing the presence of audio and video but is questioning the location of background music (BGM).",
        "type": "summary"
    },
    "974": {
        "file_id": 128,
        "content": "# this time we have audio and video.\n# where's the BGM?",
        "type": "code",
        "location": "/propaganda/video_script/compile_script.py:1-2"
    },
    "975": {
        "file_id": 128,
        "content": "This code seems to be discussing the presence of audio and video but is questioning the location of background music (BGM).",
        "type": "comment"
    },
    "976": {
        "file_id": 129,
        "content": "/propaganda/video_script/download_video.py",
        "type": "filepath"
    },
    "977": {
        "file_id": 129,
        "content": "This code downloads videos specified in the 'script.yaml' file and saves them to a directory named \"video\". It then creates an output JSON file containing the mapping of video links to their respective saved file paths.",
        "type": "summary"
    },
    "978": {
        "file_id": 129,
        "content": "import os\nimport yaml\nscript_path = \"script.yaml\"\ndir_path = \"video\"\nwith open(script_path,'r') as f:\n    data = yaml.load(f, Loader=yaml.BaseLoader)\n# os.system\noutput_path= \"output.json\"\nimport json\nimport rich\nrich.print(data)\noutput_data = {}\nindex = 0\nfor d in data:\n    vlink = d.get('video', None)\n    if vlink:\n        index+=1\n        vpath = f\"{index}.mp4\"\n        video_output = os.path.join(dir_path, vpath)\n        os.system(f'ffmpeg -y -i \"{vlink}\" {video_output}')\n        output_data.update({vlink:video_output})\nwith open(output_path,'w+') as f:\n    f.write(json.dumps(output_data, indent=4, ensure_ascii=False))",
        "type": "code",
        "location": "/propaganda/video_script/download_video.py:1-28"
    },
    "979": {
        "file_id": 129,
        "content": "This code downloads videos specified in the 'script.yaml' file and saves them to a directory named \"video\". It then creates an output JSON file containing the mapping of video links to their respective saved file paths.",
        "type": "comment"
    },
    "980": {
        "file_id": 130,
        "content": "/propaganda/video_script/preprocess.py",
        "type": "filepath"
    },
    "981": {
        "file_id": 130,
        "content": "Reads script from 'script.txt', removes specified spliters, and stores data in a list. Writes the list to 'script.md' with \"- text: \" and \"  video: \" for each item.",
        "type": "summary"
    },
    "982": {
        "file_id": 130,
        "content": "spliters = \",.，。！~\"\noutput = 'script.md'\nwith open('script.txt', 'r') as f:\n\tdata = f.read()\nfor e in spliters:\n\tdata = data.replace(e, \" \")\ndata = data.strip()\ndata = data.split(\" \")\nwith open(output, 'w+') as f:\n\t#f.write(\"\\n\".join(data))\n\tfor d in data:\n\t\tf.write(f\"- text: {d}\\n\")\n\t\tf.write(\"  video: \\n\")",
        "type": "code",
        "location": "/propaganda/video_script/preprocess.py:2-18"
    },
    "983": {
        "file_id": 130,
        "content": "Reads script from 'script.txt', removes specified spliters, and stores data in a list. Writes the list to 'script.md' with \"- text: \" and \"  video: \" for each item.",
        "type": "comment"
    },
    "984": {
        "file_id": 131,
        "content": "/propaganda/video_script/read_text.py",
        "type": "filepath"
    },
    "985": {
        "file_id": 131,
        "content": "The code imports libraries, loads data from a YAML file, configures a text-to-speech engine, and saves each text as an audio file in a specified directory using voice settings and punctuation for pauses.",
        "type": "summary"
    },
    "986": {
        "file_id": 131,
        "content": "# import pyttsx3\n# import os\ndir_path = \"audio\"\nimport os\nimport yaml\nscript_path = \"script.yaml\"\nwith open(script_path,'r') as f:\n    data = yaml.load(f, Loader=yaml.BaseLoader)\nimport pyttsx3\n# dir(engine.getProperty(\"voices\")[0]) -> ['age', 'gender', 'id', 'languages', 'name']\n# The voices are related to languages. Set it properly.\n# you want \"en_US\" and \"zh_CN\"\n# [['en_US'], ['it_IT'], ['sv_SE'], ['fr_CA'], ['de_DE'], ['he_IL'], ['id_ID'], ['en_GB'], ['es_AR'], ['nl_BE'], ['en-scotland'], ['en_US'], ['ro_RO'], ['pt_PT'], ['es_ES'], ['es_MX'], ['th_TH'], ['en_AU'], ['ja_JP'], ['sk_SK'], ['hi_IN'], ['it_IT'], ['pt_BR'], ['ar_SA'], ['hu_HU'], ['zh_TW'], ['el_GR'], ['ru_RU'], ['en_IE'], ['es_ES'], ['nb_NO'], ['es_MX'], ['en_IN'], ['en_US'], ['da_DK'], ['fi_FI'], ['zh_HK'], ['en_ZA'], ['fr_FR'], ['zh_CN'], ['en_IN'], ['en_US'], ['nl_NL'], ['tr_TR'], ['ko_KR'], ['ru_RU'], ['pl_PL'], ['cs_CZ']]\n# engine.save_to_file(\"你好 世界\", 'output.wav')\n# engine.runAndWait()\n# engine.setProperty('rate', 125) # setting",
        "type": "code",
        "location": "/propaganda/video_script/read_text.py:1-25"
    },
    "987": {
        "file_id": 131,
        "content": "This code imports necessary libraries, loads data from a YAML file, and configures a text-to-speech engine. It then saves a speech to an audio file in the specified directory using the configured voice settings. The rate of speech can be set using the 'rate' property.",
        "type": "comment"
    },
    "988": {
        "file_id": 131,
        "content": " up new voice rate\n# # The punctuals make the bot to pause for some time. Maybe you should control that yourself.\n# engine.save_to_file(\"你好，世界\", 'output.wav')\n# engine.runAndWait()\nimport progressbar\nos.system(f\"rm -rf {dir_path}\")\nos.system(f\"mkdir {dir_path}\")\nfor index, elem in progressbar.progressbar(enumerate(data)):\n    text = elem['text'].strip()\n    output_path = f\"{dir_path}/{index}.wav\"\n    # print(\"READING:\", text)\n    engine = pyttsx3.init()\n    engine.setProperty('voice', engine.getProperty(\"voices\")[39].id)\n    engine.save_to_file(text, output_path)\n    engine.runAndWait()\n    del engine",
        "type": "code",
        "location": "/propaganda/video_script/read_text.py:25-41"
    },
    "989": {
        "file_id": 131,
        "content": "The code initializes a text-to-speech engine, reads a list of texts from the data source, and saves each text as an audio file in a specified directory. Punctuation is used to control pauses in speech synthesis.",
        "type": "comment"
    },
    "990": {
        "file_id": 132,
        "content": "/propaganda/video_script/script.txt",
        "type": "filepath"
    },
    "991": {
        "file_id": 132,
        "content": "This code is a promotional advertisement for an AI-powered keyboard and mouse controller named Cybergod (or \"Keyboard God\" in English), claiming it can automate various tasks on a computer, including writing Excel documents, debugging programs, browsing the web, watching videos, and even playing games. The ad highlights its potential applications in both work and leisure settings, ultimately aiming to improve productivity and health by eliminating the need for humans to directly operate computers. A download link is provided on the Github repository mentioned in the comments.",
        "type": "summary"
    },
    "992": {
        "file_id": 132,
        "content": "这个可以自动识别屏幕内容控制键盘鼠标的人工智能火了，它就是最新推出的键鼠真神。键鼠真神又名赛博真神，英文名字叫Cybergod，应用最新一代通用人工智能，性能比肩GPT5，自动控制你的电脑，让你能够在睡觉的时候依然全力工作。给它说一句话，它不仅能够自动帮你写Excel，调试程序，可以自己打开网页，观看视频，甚至还能自己下载游戏，和人类玩家并肩作战。键鼠真神的能力涵盖了需要用到电脑的工作，甚至包括了娱乐。安装了键鼠真神，人类再也不用操控电脑了，避免了因为长时间久坐产生的各种身体疾病。下载键鼠真神，解放你的生产力，让你走向人生巅峰！Github链接我已经放在评论区了，欢迎小伙伴们交流使用感受，记得一键三连哦~",
        "type": "code",
        "location": "/propaganda/video_script/script.txt:1-1"
    },
    "993": {
        "file_id": 132,
        "content": "This code is a promotional advertisement for an AI-powered keyboard and mouse controller named Cybergod (or \"Keyboard God\" in English), claiming it can automate various tasks on a computer, including writing Excel documents, debugging programs, browsing the web, watching videos, and even playing games. The ad highlights its potential applications in both work and leisure settings, ultimately aiming to improve productivity and health by eliminating the need for humans to directly operate computers. A download link is provided on the Github repository mentioned in the comments.",
        "type": "comment"
    },
    "994": {
        "file_id": 133,
        "content": "/propaganda/video_script/script.yaml",
        "type": "filepath"
    },
    "995": {
        "file_id": 133,
        "content": "The YAML file contains Chinese text and video demonstrations for an AI device called \"Cybergod\", which includes a promotional script. The code snippet references a video link with the accompanying text \"记得一键三连哦\".",
        "type": "summary"
    },
    "996": {
        "file_id": 133,
        "content": "- text: 这个可以自动识别屏幕内容控制键盘鼠标的人工智能火了\n  video: https://oss.agilestudio.cn/fse-videos/pixabay/Keyboard-45238/Keyboard-45238.m3u8\n- text: 它就是最新推出的键鼠真神\n  video: https://ssv-video.agilestudio.cn/4910_2e324b/4910_2e324b389.ts\n- text: 键鼠真神又名赛博真神\n  video: https://ssv-video.agilestudio.cn/942_9syz0w/942_9syz0w-00294.ts\n- text: 英文名字叫Cybergod\n  video: https://ssv-video.agilestudio.cn/952_4A6f6O/952_4A6f6O-00511.ts\n- text: 应用最新一代通用人工智能\n  video: https://ssv-video.agilestudio.cn/4910_2e324b/4910_2e324b415.ts\n- text: 性能比肩GPT5\n  video: https://oss.agilestudio.cn/fse-videos/3c363da42970912223541177bddcd2b3/3c363da42970912223541177bddcd2b30.ts\n- text: 自动控制你的电脑\n  video: https://ssv-video.agilestudio.cn/4948_00a6bc/4948_00a6bc495.ts\n- text: 让你能够在睡觉的时候依然全力工作\n  video: https://ssv-video.agilestudio.cn/7610_cdbd07/7610_cdbd07121.ts\n- text: 给它说一句话\n  video: https://ssv-video.agilestudio.cn/993_49a47e/993_49a47e-00019.ts\n- text: 它不仅能够自动帮你写Excel\n  video: https://oss.agilestudio.cn/fse-videos/pixabay/ToWrite-8424/ToWrite-8424-00003.ts\n-",
        "type": "code",
        "location": "/propaganda/video_script/script.yaml:1-21"
    },
    "997": {
        "file_id": 133,
        "content": "This code is a YAML file that contains text and video pairs. The text describes the features of an AI-powered device called \"Cybergod\" in Chinese, while each video presents a visual demonstration.",
        "type": "comment"
    },
    "998": {
        "file_id": 133,
        "content": " text: 调试程序\n- text: 可以自己打开网页\n- text: 观看视频\n  video: https://ssv-video.agilestudio.cn/7274_01cdec/7274_01cdec508.ts\n- text: 甚至还能自己下载游戏\n  video: https://oss.agilestudio.cn/fse-videos/pixabay/Game-37253/Game-37253.m3u8\n- text: 和人类玩家并肩作战\n- text: 键鼠真神的能力涵盖了需要用到电脑的工作\n- text: 甚至包括了娱乐\n- text: 安装了键鼠真神\n  video: https://oss.agilestudio.cn/fse-videos/7ae43148f2daf8fa1507c2521907cb2b/7ae43148f2daf8fa1507c2521907cb2b.m3u8\n- text: 人类再也不用操控电脑了\n- text: 避免了因为长时间久坐产生的各种身体疾病\n  video: https://oss.agilestudio.cn/fse-videos/pixabay/Science-57693/Science-57693.m3u8\n- text: 下载键鼠真神\n  video: https://ssv-video.agilestudio.cn/5436_4393c6/5436_4393c6610.ts\n- text: 解放你的生产力\n  video: https://ssv-video.agilestudio.cn/6945_02df36/6945_02df36183.ts\n- text: 让你走向人生巅峰\n  video: https://oss.agilestudio.cn/fse-videos/pixabay/Worship-54996/Worship-54996.m3u8\n- text: Github链接我已经放在评论区了\n  video: https://ssv-video.agilestudio.cn/7636_953a6a/7636_953a6a180.ts\n- text: 欢迎小伙伴们交流使用感受\n  video: https://oss.agilestudio.cn/fse-videos/dff6696ece5ed72f56183d21813064",
        "type": "code",
        "location": "/propaganda/video_script/script.yaml:21-44"
    },
    "999": {
        "file_id": 133,
        "content": "Video links and descriptions for a promotional script.",
        "type": "comment"
    }
}