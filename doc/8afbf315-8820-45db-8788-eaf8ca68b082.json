{
    "summary": "The code utilizes modules for type safety, defines functions for scroll codes, initializes objects to check device IDs, and handles various data communications using KCOM and HID protocols for mouse control and keyboard transmission.",
    "details": [
        {
            "comment": "- Importing necessary modules and classes\n- Ensuring type safety with `beartype` and `typing`\n- Defining a function `get_scroll_code` to convert movement values into one-byte scroll codes\n- Creating an enumeration `DeviceType` for device types\n- Including comments related to version compatibility, import paths, and error handling.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":0-48",
            "content": "from typing import Callable\nimport math\nimport serial\nfrom beartype import beartype\nfrom beartype.vale import Is\nfrom typing import Annotated, TYPE_CHECKING\nfrom typing_extensions import TypeAlias\nimport sys\nsys.path.append(\"../\")\nif TYPE_CHECKING:\n    from ..hid_utils import *\nelse:\n    from hid_utils import *\n# use xephyr (leafpad, fullscreen) for unit test.\nif sys.version_info >= (3, 11):\n    from enum import StrEnum\nelse:\n    from strenum import StrEnum\n# for branching; ref: https://beartype.readthedocs.io/en/latest/api_door/\nfrom beartype.door import is_bearable\nfrom enum import Enum, auto, Flag\nimport time\nimport random\nfrom functools import reduce\nfrom typing import Union, List, Literal, Tuple\nfrom common_keycodes import KeyLiteralToKCOMKeycode, HIDActionTypes\nimport inspect\n# confusing!\n# TODO: unit test underway\n@beartype\ndef get_scroll_code(c_scroll: movement) -> one_byte:\n    if c_scroll < 0:\n        c_scroll = -c_scroll + 0x80\n    return c_scroll.to_bytes()\nclass DeviceType(StrEnum):\n    power = auto()\n    kc"
        },
        {
            "comment": "This code initializes objects for different devices and checks available device IDs. It then iterates over the list of available serial ports, compares their hardware IDs to a dictionary of expected IDs, and adds the found ports to a dictionary of serialDevices by type. If two or more types have the same hardware ID (ch340), it raises an exception indicating that they cannot be distinguished.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":48-82",
            "content": "om2 = auto()\n    kcom3 = auto()\n    ch9329 = auto()\n# TODO: iterate over available devices, then select.\nimport serial.tools.list_ports\navailable_ports = serial.tools.list_ports.comports()\nserialDeviceHWIDs = {\n    DeviceType.power: \"VID:PID=1A86:5523\",\n    DeviceType.kcom2: (ch340_hwid := \"VID:PID=1A86:7523\"),\n    DeviceType.kcom3: ch340_hwid,\n    DeviceType.ch9329: ch340_hwid,\n}\nserialDevices = {}\nfor comport in available_ports:\n    hwid = comport.hwid\n    for k, v in serialDeviceHWIDs.items():\n        if v in hwid:\n            if k not in serialDevices.keys():\n                serialDevices[k] = comport.device\n            else:\n                raise Exception(\n                    f'Devices undistinguishable by HWID \"{v}\": \"{serialDevices[k]}\" <=> \"{comport.device}\"'\n                )\n# serialDevices = {  # VID:PID=1A86:5523\n#     DeviceType.power: \"/dev/serial/by-id/usb-1a86_5523-if00-port0\",\n#     # kcom2/kcom3 & ch9329 not distinguishable by id (all ch340).\n#     # these are identical. 'VID:PID=1A86:7523' i"
        },
        {
            "comment": "This code is mapping different device types to a serial device and creating a Serial object with that device. The device type is set to \"power\" initially but can be changed to \"DeviceType.ch9329\", \"DeviceType.kcom3\", or \"DeviceType.kcom2\". The code also adds a delay of 5ms between sending data for proper data transmission.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":82-102",
            "content": "n hwid.\n#     DeviceType.kcom2: (ch340 := \"/dev/serial/by-id/usb-1a86_USB_Serial-if00-port0\"),\n#     # another hid device will be: ch9329\n#     DeviceType.kcom3: ch340,\n#     DeviceType.ch9329: ch340,\n# }\ndeviceType = DeviceType.power\n# deviceType = DeviceType.ch9329\n# deviceType = DeviceType.kcom3\n# deviceType = DeviceType.kcom2  # \u4e3a\u4e86\u4fdd\u8bc1\u6570\u636e\u80fd\u6b63\u5e38\u4f20\u8f93\uff0c\u4e24\u6761\u6570\u636e\u53d1\u9001\u95f4\u9694\u6700\u4f4e\u8981\u67095ms \u7684\u5ef6\u65f6\uff1b\u610f\u601d\u5c31\u662f\u4f60\u53d1\u9001\u4e00\u4e2a\u6570\u636e\u540e\u5ef6\u65f65ms \u518d\u53d1\u4e0b\u4e00\u6761\u6570\u636e\u3002\nser = serial.Serial(\n    serialDevices[deviceType],\n    timeout=0.01,\n    **({\"baudrate\": 57600} if deviceType == \"hid\" else {}),\n)\nprint(\"Serial device: %s\" % deviceType)\n# print(dir(ser))\n# ['BAUDRATES', 'BAUDRATE_CONSTANTS', 'BYTESIZES', 'PARITIES', 'STOPBITS', '_SAVED_SETTINGS', ..., '_baudrate', '_break_state', '_bytesize', '_checkClosed', '_checkReadable', '_checkSeekable', '_checkWritable', '_dsrdtr', '_dtr_state', '_exclusive', '_inter_byte_timeout', '_parity', '_port', '_reconfigure_port', '_reset_input_buffer', '_rs485_mode', '_rts_state', '_rtscts', '_set_rs485_mode', '_set_special_baudrate', '_stopbits',"
        },
        {
            "comment": "This code appears to be a part of a serial communication implementation, providing methods for setting and getting various communication settings, such as baudrate, parity, flow control, and more. It also supports reading and writing data from/to the serial port, handling break conditions, DTR and RTS states, and other related operations.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":102-102",
            "content": " '_timeout', '_update_break_state', '_update_dtr_state', '_update_rts_state', '_write_timeout', '_xonxoff', 'applySettingsDict', 'apply_settings', 'baudrate', 'break_condition', 'bytesize', 'cancel_read', 'cancel_write', 'cd', 'close', 'closed', 'cts', 'dsr', 'dsrdtr', 'dtr', 'exclusive', 'fd', 'fileno', 'flush', 'flushInput', 'flushOutput', 'getCD', 'getCTS', 'getDSR', 'getRI', 'getSettingsDict', 'get_settings', 'inWaiting', 'in_waiting', 'interCharTimeout', 'inter_byte_timeout', 'iread_until', 'isOpen', 'is_open', 'isatty', 'name', 'nonblocking', 'open', 'out_waiting', 'parity', 'pipe_abort_read_r', 'pipe_abort_read_w', 'pipe_abort_write_r', 'pipe_abort_write_w', 'port', 'portstr', 'read', 'read_all', 'read_until', 'readable', 'readall', 'readinto', 'readline', 'readlines', 'reset_input_buffer', 'reset_output_buffer', 'ri', 'rs485_mode', 'rts', 'rtscts', 'seek', 'seekable', 'sendBreak', 'send_break', 'setDTR', 'setPort', 'setRTS', 'set_input_flow_control', 'set_low_latency_mode', 'se"
        },
        {
            "comment": "This code defines two functions: 'write_and_read' and 'reduce_flags_to_bytes'. The 'write_and_read' function takes a bytes parameter, writes it to the serial port, prints the written data, reads all available data from the serial port, and then prints the received data. The 'reduce_flags_to_bytes' function takes a list of flags and converts them into bytes using a specified byte order ('little' or 'big') and optional byte length. If the input list is empty, it returns a null byte.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":102-134",
            "content": "t_output_flow_control', 'stopbits', 'tell', 'timeout', 'truncate', 'writable', 'write', 'writeTimeout', 'write_timeout', 'writelines', 'xonxoff']\n# import rich\n# rich.print(ser.__dict__)]\n# print(ser.name) # /dev/serial/by-id/usb-1a86_5523-if00-port0\n# ser.write(b\"hello\")\n@beartype\ndef write_and_read(_bytes: bytes):\n    ser.write(_bytes)\n    print(f\"w> {repr(_bytes)}\")\n    res = ser.readall()\n    print(f\"r> {repr(res)}\")\n    # use int.to_bytes afterwards.\n    # use enum.Flag to replace enum.Enum in this situation.\n@beartype\ndef reduce_flags_to_bytes(  # force this to be non-empty!\n    flags: List[Flag],\n    # flags: Annotated[List[Flag], Is[lambda l: len(l) > 0]],\n    byteorder: Literal[\"little\", \"big\"] = \"little\",\n    byte_length: Union[int, Ellipsis] = ...,\n):\n    # def reduce_flags_to_bytes(opcodes: List[Union[one_byte, two_bytes]]):\n    if flags == []:\n        assert is_bearable(\n            pos_int, byte_length\n        ), f\"invalid byte_length (positive integer): {byte_length}\"\n        return b\"\\x00\" * by"
        },
        {
            "comment": "This code calculates the byte length and encodes an opcode for a device. It then writes and reads data to/from the device, toggling its state if necessary.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":134-169",
            "content": "te_length\n    flag = reduce(lambda a, b: a | b, flags)\n    opcode = flag.value\n    # bytecode = opcode.to_bytes(1 if opcode <= 0xFF else 2)\n    if byte_length is ...:\n        byte_length = (\n            get_byte_length := lambda _bytes: math.ceil(\n                len(hex(_bytes).strip(\"0x\")) / 2\n            )\n        )(opcode)\n        for member in type(flags[0]).__members__.values():\n            if (member_byte_length := get_byte_length(member.value)) > byte_length:\n                byte_length = member_byte_length\n    byte_code = opcode.to_bytes(byte_length, byteorder=byteorder)\n    return byte_code\n# cannot use match here? python 3.10+ required\nif deviceType == DeviceType.power:\n    # will reset on reboot\n    channel = 1  # CH3 does not exist. CH2 is placeholder. (virtually working)\n    # channel = 2\n    # state = \"ON\"\n    # # state = \"OFF\"\n    # write_and_read(f\"CH{channel}=?\".encode())\n    # write_and_read(f\"CH{channel}={state}\".encode())\n    # write_and_read(f\"CH{channel}=?\".encode())\n    # just toggle.\n  "
        },
        {
            "comment": "Sends \"ON\" or \"OFF\" commands to channel, depending on device type.\nDefines KCOMHeader enum for different HID header types and a function kcom_write_and_read().",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":169-195",
            "content": "  write_and_read(f\"CH{channel}=OFF\".encode())\n    write_and_read(f\"CH{channel}=ON\".encode())\nelif deviceType in [DeviceType.kcom2, DeviceType.kcom3]:\n    commonHeader = b\"\\x57\\xab\"\n    class KCOMHeader(Enum):\n        # +4bytes, (2bytes VID, 2bytes PID)\n        modifyIDHeader = commonHeader + b\"\\x10\"\n        keyboardHeader = commonHeader + b\"\\x01\"  # +8bytes\n        mouseRelativeHeader = commonHeader + b\"\\x02\"  # +4bytes\n        # below only working for KCOM3\n        multimediaHeader = commonHeader + b\"\\x03\"  # +(2 or 4)bytes\n        mouseAbsoluteHeader = commonHeader + b\"\\x04\"  # +4bytes\n    @beartype\n    def kcom_write_and_read(\n        header: KCOMHeader, data_code: bytes, length: Union[int, List[int], None]\n    ):\n        if is_bearable(length, int):\n            length = [length]\n        if length is not None:\n            assert (\n                data_length := len(data_code)\n            ) == length, f\"Assumed data lengths: {length}\\nActual length: {data_length}\"\n        write_and_read(header + data_code"
        },
        {
            "comment": "The code defines a function called `changeID` that takes two-byte values for VID (vendor ID) and PID (product ID) as input, prints their values, combines them into `data_code`, and uses the `kcom_write_and_read` function to write and read the `modifyIDHeader`. The code also defines a function called `keyboard` that takes control codes and key literals as inputs. It converts control codes to bytes, maps key literals to KCOM keycodes, and processes them to release all keys or perform specific actions based on the provided arguments.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":195-222",
            "content": ")\n    @beartype\n    def changeID(vid: two_bytes, pid: two_bytes):\n        print(\"change VID=%s, PID=%s\" % (vid, pid))\n        data_code = vid + pid\n        kcom_write_and_read(KCOMHeader.modifyIDHeader, data_code, 4)\n    # class KeyboardKey(Enum):\n    #     ...\n    # leave it empty to release all keys.\n    @beartype\n    def keyboard(\n        control_codes: List[ControlCode] = [ControlCode.NULL],\n        key_literals: Annotated[\n            List[HIDActionTypes.keys], Is[lambda l: len(l) <= 6 and len(l) >= 0]\n        ] = [],\n    ):  # check for \"HID Usage ID\"\n        reserved_byte = b\"\\x00\"\n        # control_code = reduce_flags_to_bytes(control_codes)\n        control_code = reduce_flags_to_bytes(control_codes, byte_length=1)\n        keycodes = [\n            KeyLiteralToKCOMKeycode(key_literal)\n            for key_literal in key_literals\n            if KeyLiteralToKCOMKeycode(key_literal)\n        ]  # could reduce size with walrus operator with higher python version.\n        # keycodes = [v:=KeyLiteralToKCOMKeyc"
        },
        {
            "comment": "This code appears to be part of a larger program that interacts with hardware, specifically related to keyboard and mouse inputs. It defines functions for handling different types of input data and sending them through KCOM (Keyboard/Mouse COMMAND) protocol. The `get_rel_code_kcom` function converts relative movement into bytes for the KCOM protocol, while the `mouse_common` function processes various parameters such as mouse position, scroll, and button codes, then packages them into a format suitable for sending through KCOM.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":222-250",
            "content": "ode(key_literal) for key_literal in key_literals if v]\n        data_code = (\n            control_code\n            + reserved_byte\n            + b\"\".join(keycodes + ([b\"\\x00\"] * (6 - len(keycodes))))\n        )\n        kcom_write_and_read(KCOMHeader.keyboardHeader, data_code, 8)\n    @beartype\n    def get_rel_code_kcom(c_rel: movement):\n        if c_rel < 0:\n            c_rel = 0xFF + c_rel\n        return c_rel.to_bytes()\n    @beartype\n    def mouse_common(\n        x_code: Union[two_bytes, one_byte],\n        y_code: Union[two_bytes, one_byte],\n        scroll: movement,\n        kcom_flag: Literal[\n            KCOMHeader.mouseRelativeHeader, KCOMHeader.mouseAbsoluteHeader\n        ],\n        button_codes: List[MouseButton] = [MouseButton.NULL],\n    ):\n        scroll_code = get_scroll_code(scroll)\n        # button_code = reduce_flags_to_bytes(button_codes)\n        button_code = reduce_flags_to_bytes(button_codes, byte_length=1)\n        # button_opcode = reduce_opcodes(button_codes)\n        # button_code = button_opcod"
        },
        {
            "comment": "This code defines functions for controlling mouse movements, buttons, and scrolling using the KCOM protocol. The `mouse_relative` function handles relative mouse movements, while the `mouse_absolute` function handles absolute mouse coordinates. Both functions also support handling button presses and releases, and scrolling. The code converts these inputs into appropriate byte sequences for sending over the KCOM interface.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":250-286",
            "content": "e.to_bytes()\n        data_code = button_code + x_code + y_code + scroll_code  # all 1byte\n        kcom_write_and_read(\n            kcom_flag,\n            data_code,\n            4 if is_bearable(kcom_flag, KCOMHeader.mouseRelativeHeader) else 6,\n        )\n    @beartype\n    def mouse_relative(\n        x: movement,\n        y: movement,\n        scroll: movement,\n        button_codes: List[MouseButton] = [MouseButton.NULL],\n    ):\n        x_code = get_rel_code_kcom(x)\n        y_code = get_rel_code_kcom(y)\n        mouse_common(\n            x_code,\n            y_code,\n            scroll,\n            kcom_flag=KCOMHeader.mouseRelativeHeader,\n            button_codes=button_codes,\n        )\n    def get_abs_code(c_abs, res):\n        return int((4096 * c_abs) / res).to_bytes(2, byteorder=\"little\")\n    @beartype\n    def mouse_absolute(\n        coordinate: Tuple[non_neg_int, non_neg_int],\n        resolution: Tuple[pos_int, pos_int],\n        scroll: movement,\n        button_codes: List[MouseButton] = [MouseButton.NULL],\n    ):\n   "
        },
        {
            "comment": "The code is defining a function called \"multimedia\" which takes a list of multimedia keys as input. It checks if the length of the key list is 0, and if so, it clears all multimedia keys by adding Null to the key list and calling the function again. If the list contains ACPI or Multimedia keys, it calls another function passing the keys.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":286-320",
            "content": "     \"\"\"\n        coordinate: (x_abs, y_abs)\n        resolution: (width, height)\n        \"\"\"\n        (x_abs, y_abs) = coordinate\n        (width, height) = resolution\n        assert x_abs <= width, f\"Invalid x: {x_abs}\\nWidth: {width}\"\n        assert y_abs <= height, f\"Invalid y: {y_abs}\\nHeight: {height}\"\n        x_code = get_abs_code(x_abs)\n        y_code = get_abs_code(y_abs)\n        # scroll_code = get_rel_code(scroll)\n        mouse_common(\n            x_code,\n            y_code,\n            scroll,\n            kcom_flag=KCOMHeader.mouseAbsoluteHeader,\n            button_codes=button_codes,\n        )\n    # @beartype\n    # def multimedia_raw(data_code: Union[two_bytes, four_bytes]):\n    @beartype\n    def multimedia(keys: Union[List[ACPIKey], List[MultimediaKey]] = []):\n        if len(keys) == 0:  # clear all multimedia keys.\n            multimedia(keys=[ACPIKey.Null])\n            multimedia(keys=[MultimediaKey.Null])\n            return\n        isMultimediaKeys = is_bearable(keys, List[MultimediaKey])\n        by"
        },
        {
            "comment": "This code appears to be part of a larger program and seems to handle data transmission for different devices. If `isMultimediaKeys` is True, 3 keys are processed. Otherwise, only 1 key is processed. The code then generates data code for the selected keys and transmits it using a function called `kcom_write_and_read`. For device type \"ch9329\", it imports necessary classes and defines a class `CH9329Util` which may handle communication with this specific device type.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":320-347",
            "content": "te_length = 3 if isMultimediaKeys else 1\n        # key_code = reduce_flags_to_bytes(keys)\n        key_code = reduce_flags_to_bytes(keys, byte_length=byte_length)\n        data_code = (b\"\\x02\" if isMultimediaKeys else b\"\\x01\") + key_code\n        # multimedia_opcode = reduce_opcodes(multimedia_keys)\n        # data_code = multimedia_opcode.to_bytes(1 if multimedia_opcode <= 0xff else 2)\n        # multimedia_raw(data_code)\n        kcom_write_and_read(\n            KCOMHeader.multimediaHeader, data_code, 4 + (1 + byte_length)\n        )\nelif deviceType == DeviceType.ch9329:\n    import ch9329Comm\n    # import parse\n    from types import MethodType\n    # from types import MethodWrapperType\n    @beartype\n    class CH9329Util:\n        def __init__(self, port: serial.Serial, **kwargs):\n            self.port = port\n            super_class_init = getattr(super(), \"__init__\", None)\n            if super_class_init:\n                # not method-wrapper.\n                if isinstance(super_class_init, MethodType):\n            "
        },
        {
            "comment": "Code is initializing the superclass and defining a method to communicate by transforming data into a packet format.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":347-374",
            "content": "        # sclass_init_str = str(super_class_init)\n                    # sclass_str = str(super())\n                    # sclass_parsed = parse.parse(\"<super: <class '{self}'>, <{base} object>>\", sclass_str)\n                    # base_init_str =\n                    # self.super_class = super_class_init(**kwargs)\n                    super().__init__(**kwargs)\n        def communicate(\n            self,\n            DATA: Annotated[bytes, Is[lambda b: len(b) > 0]],\n            CMD: one_byte,\n            LEN: one_byte,\n        ):\n            # \u5c06\u5b57\u7b26\u8f6c\u5199\u4e3a\u6570\u636e\u5305\n            HEAD = b\"\\x57\\xAB\"  # \u5e27\u5934\n            ADDR = b\"\\x00\"  # \u5730\u5740\n            # CMD = b\"\\x02\"  # \u547d\u4ee4\n            # LEN = b\"\\x08\"  # \u6570\u636e\u957f\u5ea6\n            data_length = ord(LEN)\n            # \u63a7\u5236\u952e\n            # control_byte = reduce_flags_to_bytes(control_codes, byte_length=1)\n            # DATA += control_byte\n            # # if ctrl == '':\n            # #     DATA += b'\\x00'\n            # # elif isinstance(ctrl, int):\n            # #     DATA += bytes([ctrl])\n          "
        },
        {
            "comment": "Checksum calculation and packet construction for a control message.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":374-403",
            "content": "  # # else:\n            # #     DATA += self.control_button_hex_dict[ctrl]\n            # # DATA\u56fa\u5b9a\u7801\n            # DATA += b\"\\x00\"\n            # \u8bfb\u5165data\n            # for i in range(0, len(data), 2):\n            #     DATA += self.normal_button_hex_dict[data[i:i + 2]]\n            # for key_literal in key_literals:\n            #     DATA += KeyLiteralToKCOMKeycode(key_literal)\n            if len(DATA) < data_length:\n                DATA += b\"\\x00\" * (data_length - len(DATA))\n            else:\n                DATA = DATA[:data_length]\n            # \u5206\u79bbHEAD\u4e2d\u7684\u503c\uff0c\u5e76\u8ba1\u7b97\u548c\n            HEAD_hex_list = []\n            for byte in HEAD:\n                HEAD_hex_list.append(byte)\n            HEAD_add_hex_list = sum(HEAD_hex_list)\n            # \u5206\u79bbDATA\u4e2d\u7684\u503c\uff0c\u5e76\u8ba1\u7b97\u548c\n            DATA_hex_list = []\n            for byte in DATA:\n                DATA_hex_list.append(byte)\n            DATA_add_hex_list = sum(DATA_hex_list)\n            SUM = self.checksum(HEAD_add_hex_list, ADDR, CMD, LEN, DATA_add_hex_list)\n            packet = HEAD + ADDR +"
        },
        {
            "comment": "Function sends a command packet to the device via serial port, and calculates checksum for each data packet.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":403-436",
            "content": " CMD + LEN + DATA + bytes([SUM])  # \u6570\u636e\u5305\n            self.port.write(packet)  # \u5c06\u547d\u4ee4\u4ee3\u7801\u5199\u5165\u4e32\u53e3\n            # return True  # \u5982\u679c\u6210\u529f\uff0c\u5219\u8fd4\u56deTrue\uff0c\u5426\u5219\u5f15\u53d1\u5f02\u5e38\n        def checksum(\n            self,\n            HEAD_add_hex_list: int,\n            ADDR: bytes,\n            CMD: bytes,\n            LEN: bytes,\n            DATA_add_hex_list: int,\n        ):\n            try:\n                SUM = (\n                    sum(\n                        [\n                            HEAD_add_hex_list,\n                            int.from_bytes(ADDR, byteorder=\"big\"),\n                            int.from_bytes(CMD, byteorder=\"big\"),\n                            int.from_bytes(LEN, byteorder=\"big\"),\n                            DATA_add_hex_list,\n                        ]\n                    )\n                    % 256\n                )  # \u6821\u9a8c\u548c\n            except Exception as e:\n                print(\"int too big to convert\")\n                raise e\n                # return False\n            return SUM\n    @beartype\n    class Multimedia(CH9329Util):\n    "
        },
        {
            "comment": "The code defines a class named \"Keyboard\" that communicates with a serial device. The `send_data()` method sends data to the device, and the `release()` method calls `send_data()` without any parameters to release all keys. The `is_bearable()` function determines if the input is a list of MultimediaKeys. The code also uses `reduce_flags_to_bytes()`, `b\"\\x03\"`, `b\"\\x04\"`, and `b\"\\x02\"` for command, data length, and flag reduction operations.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":436-465",
            "content": "    def send_data(self, keys: Union[List[ACPIKey], List[MultimediaKey]] = []):\n            if len(keys) == 0:  # clear all multimedia keys.\n                Multimedia.send_data(keys=[ACPIKey.Null])\n                Multimedia.send_data(keys=[MultimediaKey.Null])\n                return\n            isMultimediaKeys = is_bearable(keys, List[MultimediaKey])\n            CMD = b\"\\x03\"  # \u547d\u4ee4\n            LEN = b\"\\x04\" if isMultimediaKeys else b\"\\x02\"  # \u6570\u636e\u957f\u5ea6\n            byte_length = 3 if isMultimediaKeys else 1\n            key_code = reduce_flags_to_bytes(keys, byte_length=byte_length)\n            DATA = (b\"\\x02\" if isMultimediaKeys else b\"\\x01\") + key_code  # \u6570\u636e\n            self.communicate(DATA, CMD, LEN)\n        def release(self):\n            self.send_data()\n    # ref: https://github.com/beijixiaohu/CH9329_COMM\n    @beartype\n    class Keyboard(CH9329Util):\n        # def __init__(\n        #     self,\n        #     port: serial.Serial,\n        # ):\n        #     self.port = port\n        def send_data(\n            "
        },
        {
            "comment": "This code is defining a function that converts input data into a data package. It initializes variables for the frame header, address, command, and length of the data. The control_byte variable is created from the provided control_codes using reduce_flags_to_bytes(). The function then appends the control_byte to the DATA variable. If the 'ctrl' variable is empty or an integer, it adds the corresponding bytes to DATA. Finally, it appends a fixed value of 0x00 to the end of DATA and prepares for reading the data in increments of two.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":465-495",
            "content": "self,\n            # [ControlCode.NULL] or [], both works\n            control_codes: List[ControlCode] = [ControlCode.NULL],\n            key_literals: Annotated[\n                List[HIDActionTypes.keys], Is[lambda l: len(l) <= 8 and len(l) >= 0]\n            ] = [],\n        ):\n            # \u5c06\u5b57\u7b26\u8f6c\u5199\u4e3a\u6570\u636e\u5305\n            # HEAD = b\"\\x57\\xAB\"  # \u5e27\u5934\n            # ADDR = b\"\\x00\"  # \u5730\u5740\n            CMD = b\"\\x02\"  # \u547d\u4ee4\n            LEN = b\"\\x08\"  # \u6570\u636e\u957f\u5ea6\n            DATA = b\"\"  # \u6570\u636e\n            # \u63a7\u5236\u952e\n            # control_byte = reduce_flags_to_bytes(control_codes)\n            control_byte = reduce_flags_to_bytes(control_codes, byte_length=1)\n            DATA += control_byte\n            # if ctrl == '':\n            #     DATA += b'\\x00'\n            # elif isinstance(ctrl, int):\n            #     DATA += bytes([ctrl])\n            # else:\n            #     DATA += self.control_button_hex_dict[ctrl]\n            # DATA\u56fa\u5b9a\u7801\n            DATA += b\"\\x00\"\n            # \u8bfb\u5165data\n            # for i in range(0, len(data), 2):\n            #    "
        },
        {
            "comment": "Appending button hex codes and key literals to data.\nSending data to communicate with hardware.\nCalculating checksum for head and data sections.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":495-523",
            "content": " DATA += self.normal_button_hex_dict[data[i:i + 2]]\n            for key_literal in key_literals:\n                DATA += KeyLiteralToKCOMKeycode(key_literal)\n            self.communicate(DATA, CMD, LEN)\n            # if len(DATA) < 8:\n            #     DATA += b\"\\x00\" * (8 - len(DATA))\n            # else:\n            #     DATA = DATA[:8]\n            # # \u5206\u79bbHEAD\u4e2d\u7684\u503c\uff0c\u5e76\u8ba1\u7b97\u548c\n            # HEAD_hex_list = []\n            # for byte in HEAD:\n            #     HEAD_hex_list.append(byte)\n            # HEAD_add_hex_list = sum(HEAD_hex_list)\n            # # \u5206\u79bbDATA\u4e2d\u7684\u503c\uff0c\u5e76\u8ba1\u7b97\u548c\n            # DATA_hex_list = []\n            # for byte in DATA:\n            #     DATA_hex_list.append(byte)\n            # DATA_add_hex_list = sum(DATA_hex_list)\n            # #\n            # try:\n            #     SUM = (\n            #         sum(\n            #             [\n            #                 HEAD_add_hex_list,\n            #                 int.from_bytes(ADDR, byteorder=\"big\"),\n            #                 int.from_bytes(CMD, byteorder=\"b"
        },
        {
            "comment": "def send_data(self):\n    # Sends data to the hardware capture device.\n    pass",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":523-550",
            "content": "ig\"),\n            #                 int.from_bytes(LEN, byteorder=\"big\"),\n            #                 DATA_add_hex_list,\n            #             ]\n            #         )\n            #         % 256\n            #     )  # \u6821\u9a8c\u548c\n            # except OverflowError:\n            #     raise Exception(\"int too big to convert\")\n            #     # return False\n            # packet = HEAD + ADDR + CMD + LEN + DATA + bytes([SUM])  # \u6570\u636e\u5305\n            # self.port.write(packet)  # \u5c06\u547d\u4ee4\u4ee3\u7801\u5199\u5165\u4e32\u53e3\n            # # return True  # \u5982\u679c\u6210\u529f\uff0c\u5219\u8fd4\u56deTrue\uff0c\u5426\u5219\u5f15\u53d1\u5f02\u5e38\n        def release(self):\n            self.send_data()\n    # keyboard = ch9329Comm.keyboard.DataComm()\n    keyboard = Keyboard(port=ser)  # TODO: multimedia key support\n    # pass int to override.\n    @beartype\n    class Mouse(CH9329Util, ch9329Comm.mouse.DataComm):\n        def __init__(\n            self, port: serial.Serial, screen_width: pos_int, screen_height: pos_int\n        ):\n            # self.port = port\n            initargs = dict(screen_width=screen_width, screen_height=s"
        },
        {
            "comment": "This code appears to be a part of a class that controls mouse movements and button presses. The `assert_inbound` function checks if the given coordinates are within the maximum limits, while the `get_ctrl` function converts a list of button codes into a single byte value. The `call_super_method` function seems to be a wrapper for calling a superclass method with optional mouse movement and button parameters. However, there is currently no support for scroll functionality (indicated by the TODO comment).",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":550-578",
            "content": "creen_height)\n            super().__init__(port=port, **initargs)\n            self.super_instance = ch9329Comm.mouse.DataComm(**initargs)\n        # TODO: scroll support\n        def assert_inbound(self, x: non_neg_int, y: non_neg_int):\n            assert x <= self.X_MAX, f\"exceeding x limit ({self.X_MAX}): {x}\"\n            assert y <= self.Y_MAX, f\"exceeding y limit ({self.Y_MAX}): {y}\"\n        def get_ctrl(\n            self, x: int, y: int, button_codes: List[MouseButton], inbound: bool\n        ) -> int:\n            if inbound:\n                self.assert_inbound(x, y)\n            ctrl: int = reduce_flags_to_bytes(button_codes, byte_length=1)\n            return ctrl\n        def call_super_method(\n            self,\n            funcName: str,\n            x: int,\n            y: int,\n            button_codes: List[MouseButton] = [MouseButton.NULL],\n            inbound: bool = True,\n            use_super_instance: bool = False,\n        ):\n            ctrl = self.get_ctrl(x, y, button_codes, inbound=inbound)\n      "
        },
        {
            "comment": "This code defines a class method to send data to an absolute position on the screen by specifying x and y coordinates, scroll direction, and button codes. It first determines the control based on the provided parameters and then constructs a message with frame header, address, command, length, and data fields to be sent. If there is an error calling the superclass method, it raises an exception.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":578-607",
            "content": "      ret = (\n                self.super_instance\n                if use_super_instance\n                else getattr(super(), funcName)\n            )(x, y, ctrl=ctrl, port=self.port)\n            if ret == False:\n                raise Exception(\"Error calling super method: {}\".format(funcName))\n        def send_data_absolute(\n            self,\n            x: non_neg_int,\n            y: non_neg_int,\n            scroll: movement,\n            button_codes: List[MouseButton] = [MouseButton.NULL],\n        ):\n            ctrl = self.get_ctrl(x, y, button_codes=button_codes, inbound=True)\n            # currentFuncName = inspect.currentframe().f_code.co_name\n            # self.call_super_method(currentFuncName, x, y, button_codes)\n            # \u5c06\u5b57\u7b26\u8f6c\u5199\u4e3a\u6570\u636e\u5305\n            # HEAD = b\"\\x57\\xAB\"  # \u5e27\u5934\n            # ADDR = b\"\\x00\"  # \u5730\u5740\n            CMD = b\"\\x04\"  # \u547d\u4ee4\n            LEN = b\"\\x07\"  # \u6570\u636e\u957f\u5ea6\n            DATA = bytearray(b\"\\x02\")  # \u6570\u636e\n            # \u9f20\u6807\u6309\u952e\n            # if ctrl == \"\":\n            #     DATA.append(0)\n     "
        },
        {
            "comment": "This code appears to be part of a larger program, likely responsible for handling some type of input and converting it into data that can be communicated over a hardware interface. The code block checks if the 'ctrl' input is an integer and adds it to a list called 'DATA'. It then calculates X and Y coordinates based on given values and appends their byte representation to the 'DATA' list. Lastly, it calls a function named 'get_scroll_code' with another argument 'scroll' and appends the result to the 'DATA' list before calling another function named 'communicate'. The rest of the code is unfinished or unclear in its purpose.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":607-639",
            "content": "       # elif isinstance(ctrl, int):\n            DATA.append(ctrl)\n            # else:\n            #     DATA += self.hex_dict[ctrl]\n            # \u5750\u6807\n            X_Cur = (4096 * x) // self.X_MAX\n            Y_Cur = (4096 * y) // self.Y_MAX\n            DATA += X_Cur.to_bytes(2, byteorder=\"little\")\n            DATA += Y_Cur.to_bytes(2, byteorder=\"little\")\n            DATA += get_scroll_code(scroll)\n            self.communicate(bytes(DATA), CMD, LEN)\n            # if len(DATA) < 7:\n            #     DATA += b\"\\x00\" * (7 - len(DATA))\n            # else:\n            #     DATA = DATA[:7]\n            # # \u5206\u79bbHEAD\u4e2d\u7684\u503c\uff0c\u5e76\u8ba1\u7b97\u548c\n            # HEAD_hex_list = list(HEAD)\n            # HEAD_add_hex_list = sum(HEAD_hex_list)\n            # # \u5206\u79bbDATA\u4e2d\u7684\u503c\uff0c\u5e76\u8ba1\u7b97\u548c\n            # DATA_hex_list = list(DATA)\n            # DATA_add_hex_list = sum(DATA_hex_list)\n            # try:\n            #     SUM = (\n            #         sum(\n            #             [\n            #                 HEAD_add_hex_list,\n            #                 int.fro"
        },
        {
            "comment": "This code is sending control data to hardware, including address (ADDR), command (CMD), length (LEN), data (DATA), and sum (SUM) in the form of a packet. If any integer value is too big to convert, it raises an exception. The function sends this data-related information to a port using write() method.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":639-663",
            "content": "m_bytes(ADDR, byteorder=\"big\"),\n            #                 int.from_bytes(CMD, byteorder=\"big\"),\n            #                 int.from_bytes(LEN, byteorder=\"big\"),\n            #                 DATA_add_hex_list,\n            #             ]\n            #         )\n            #         % 256\n            #     )  # \u6821\u9a8c\u548c\n            # except OverflowError:\n            #     raise Exception(\"int too big to convert\")\n            # packet = HEAD + ADDR + CMD + LEN + DATA + bytes([SUM])  # \u6570\u636e\u5305\n            # self.port.write(packet)  # \u5c06\u547d\u4ee4\u4ee3\u7801\u5199\u5165\u4e32\u53e3\n            # # return True  # \u5982\u679c\u6210\u529f\uff0c\u5219\u8fd4\u56deTrue\uff0c\u5426\u5219\u5f15\u53d1\u5f02\u5e38\n        def send_data_relatively(\n            self,\n            x: int,\n            y: int,\n            scroll: movement,\n            button_codes: List[MouseButton] = [MouseButton.NULL],\n        ):\n            ctrl = self.get_ctrl(x, y, button_codes=button_codes, inbound=False)\n            # currentFuncName = inspect.currentframe().f_code.co_name\n            # self.call_super_method(currentFuncName, x, y,\n            #  "
        },
        {
            "comment": "Converting string command to HID data packet.\nBuilding HID data packet with mouse button, x and y coordinates.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":663-695",
            "content": "                      button_codes, inbound=False)\n            # \u5c06\u5b57\u7b26\u8f6c\u5199\u4e3a\u6570\u636e\u5305\n            # HEAD = b\"\\x57\\xAB\"  # \u5e27\u5934\n            # ADDR = b\"\\x00\"  # \u5730\u5740\n            CMD = b\"\\x05\"  # \u547d\u4ee4\n            LEN = b\"\\x05\"  # \u6570\u636e\u957f\u5ea6\n            DATA = bytearray(b\"\\x01\")  # \u6570\u636e\n            # \u9f20\u6807\u6309\u952e\n            # if ctrl == \"\":\n            #     DATA.append(0)\n            # elif isinstance(ctrl, int):\n            DATA.append(ctrl)\n            # else:\n            #     DATA += self.hex_dict[ctrl]\n            # x\u5750\u6807\n            if x == 0:\n                DATA.append(0)\n            elif x < 0:\n                DATA += (0 - abs(x)).to_bytes(1, byteorder=\"big\", signed=True)\n            else:\n                DATA += x.to_bytes(1, byteorder=\"big\", signed=True)\n            # y\u5750\u6807\uff0c\u8fd9\u91cc\u4e3a\u4e86\u7b26\u5408\u5750\u6807\u7cfb\u76f4\u89c9\uff0c\u5c06<0\u6539\u4e3a\u5411\u4e0b\uff0c>0\u6539\u4e3a\u5411\u4e0a\n            # y = - y\n            # change your ass.\n            # after doing this, we shall perform unittests, to ensure its integrity.\n            if y == 0:\n                DATA.append(0)\n            elif y < 0:\n                DATA += (0 -"
        },
        {
            "comment": "The code is preparing a byte array for communication with the hardware. It checks if the value of y is negative, converts it to a signed big endian byte, adds scroll-related data, and pads the byte array to be exactly 5 bytes long before communicating it. Additionally, there is commented out code that calculates and sums the hex values from HEAD and DATA arrays.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":695-723",
            "content": " abs(y)).to_bytes(1, byteorder=\"big\", signed=True)\n            else:\n                DATA += y.to_bytes(1, byteorder=\"big\", signed=True)\n            DATA += get_scroll_code(scroll)\n            DATA += b\"\\x00\" * (5 - len(DATA)) if len(DATA) < 5 else DATA[:5]\n            self.communicate(bytes(DATA), CMD, LEN)\n            # # \u5206\u79bbHEAD\u4e2d\u7684\u503c\uff0c\u5e76\u8ba1\u7b97\u548c\n            # HEAD_hex_list = list(HEAD)\n            # HEAD_add_hex_list = sum(HEAD_hex_list)\n            # # \u5206\u79bbDATA\u4e2d\u7684\u503c\uff0c\u5e76\u8ba1\u7b97\u548c\n            # DATA_hex_list = list(DATA)\n            # DATA_add_hex_list = sum(DATA_hex_list)\n            # try:\n            #     SUM = (\n            #         sum(\n            #             [\n            #                 HEAD_add_hex_list,\n            #                 int.from_bytes(ADDR, byteorder=\"big\"),\n            #                 int.from_bytes(CMD, byteorder=\"big\"),\n            #                 int.from_bytes(LEN, byteorder=\"big\"),\n            #                 DATA_add_hex_list,\n            #             ]\n            #         )\n        "
        },
        {
            "comment": "Function to move mouse cursor to a specified location\n\n- Defines methods \"move_to_basic\" and \"move_to\" for moving the mouse cursor to specific coordinates.\n- Takes in parameters: x, y coordinates (non_neg_int) and a list of button codes (MouseButton).\n- Uses the \"call_super_method\" function to invoke the parent class method.\n- Inspects the current frame's name for the calling function using the \"inspect\" module.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":723-750",
            "content": "    #         % 256\n            #     )  # \u6821\u9a8c\u548c\n            # except OverflowError:\n            #     raise Exception(\"int too big to convert\")\n            # packet = HEAD + ADDR + CMD + LEN + DATA + bytes([SUM])  # \u6570\u636e\u5305\n            # self.port.write(packet)  # \u5c06\u547d\u4ee4\u4ee3\u7801\u5199\u5165\u4e32\u53e3\n            # # return True  # \u5982\u679c\u6210\u529f\uff0c\u5219\u8fd4\u56deTrue\uff0c\u5426\u5219\u5f15\u53d1\u5f02\u5e38\n        def move_to_basic(\n            self,\n            x: non_neg_int,\n            y: non_neg_int,\n            button_codes: List[MouseButton] = [MouseButton.NULL],\n        ):\n            currentFuncName = inspect.currentframe().f_code.co_name\n            self.call_super_method(\n                currentFuncName, x, y, button_codes, use_super_instance=True\n            )\n        def move_to(\n            self,\n            dest_x: non_neg_int,\n            dest_y: non_neg_int,\n            button_codes: List[MouseButton] = [MouseButton.NULL],\n        ):\n            currentFuncName = inspect.currentframe().f_code.co_name\n            self.call_super_method(\n                currentFuncName, dest_x, dest"
        },
        {
            "comment": "This code defines a class that simulates mouse clicks, with the ability to customize delay time between click and post-click. It also includes handling for different device types and closing the serial connection after use.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/test_control.py\":750-776",
            "content": "_y, button_codes, use_super_instance=True\n            )\n        # this is right click. we need to override this.\n        def click(\n            self,\n            button: MouseButton,\n            get_delay: Callable[[], float] = lambda: random.uniform(0.1, 0.45),\n        ):\n            self.send_data_relatively(0, 0, [button])\n            time.sleep(get_delay())  # 100\u5230450\u6beb\u79d2\u5ef6\u8fdf\n            self.send_data_relatively(0, 0)\n    # mouse = ch9329Comm.mouse.DataComm(screen_width=1920, screen_height=1080)\n    # (deprecated) monkey patch some method.\n    # from types import MethodType\n    # # to override instance methods.\n    # keyboard.send_data = MethodType(send_data, keyboard)\n    # keyboard.release = MethodType(release, keyboard)\nelse:\n    raise Exception(\"Unknown device type: {deviceType}\".format(deviceType=deviceType))\nser.close()"
        }
    ]
}