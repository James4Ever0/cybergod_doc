{
    "summary": "This code defines classes and functions for input operations, specifically handling mouse scroll events and translating key literals to XK_KEYSYMs using abstract methods. It checks the starting key and sorts the XK_KEYSYMs based on distance before storing the translation in a dictionary and writing it to a file.",
    "details": [
        {
            "comment": "Code is importing required modules and defining an abstract class called HIDInterface with methods for key press and release.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hid_utils.py\":0-29",
            "content": "# TODO: display grabbing abstract class\n# TODO: for relative control apis, use them as fallback for absolute apis (somehow calibrated, with feedback) when possible\n# TODO: check out ROS package index: https://index.ros.org/packages/\nfrom enum import Enum, auto, Flag\nfrom beartype.vale import Is\nfrom typing_extensions import Annotated, TypeAlias\nfrom conscious_struct import HIDActionTypes, HIDActionBase\nfrom log_utils import logger_print\nfrom typing import Dict, Tuple, Union\nfrom abc import ABC, abstractmethod\n# TODO: use abstract implementation pattern (template)\nclass HIDInterface(ABC):\n    def key_press(self, key_literal: HIDActionTypes.keys):\n        \"\"\"\n        Press one of key literals.\n        \"\"\"\n        return self._key_press(key_literal=key_literal)\n    @abstractmethod\n    def _key_press(self, key_literal: HIDActionTypes.keys):\n        ...\n    def key_release(self, key_literal: HIDActionTypes.keys):\n        \"\"\"\n        Release one of key literals.\n        \"\"\"\n        return self._key_release(key_lite"
        },
        {
            "comment": "This code defines abstract methods for mouse movement, click actions, and key releases in a HID (Human Interface Device) interface. The class must implement these methods to interact with the device. The methods take parameters like position (x, y), button literal, and whether to press or release.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hid_utils.py\":29-70",
            "content": "ral=key_literal)\n    @abstractmethod\n    def _key_release(self, key_literal: HIDActionTypes.keys):\n        ...\n    def mouse_move(self, x: Union[int, float], y: Union[int, float]):\n        \"\"\"\n        Move mouse to absolute position (x, y).\n        \"\"\"\n        return self._mouse_move(x=x, y=y)\n    @abstractmethod\n    def _mouse_move(self, x: Union[int, float], y: Union[int, float]):\n        ...\n    def mouse_click(\n        self,\n        x: Union[int, float],\n        y: Union[int, float],\n        button_literal: HIDActionTypes.mouse_buttons,\n        pressed: bool,\n    ):\n        \"\"\"\n        Press or release one of mouse button literals at absolute position (x, y).\n        \"\"\"\n        return self._mouse_click(\n            x=x, y=y, button_literal=button_literal, pressed=pressed\n        )\n    @abstractmethod\n    def _mouse_click(\n        self,\n        x: Union[int, float],\n        y: Union[int, float],\n        button_literal: HIDActionTypes.mouse_buttons,\n        pressed: bool,\n    ):\n        ...\n    def mouse_scroll(\n    "
        },
        {
            "comment": "The code appears to be part of a larger module and seems to define functions for handling mouse scroll events. It first defines an abstract method for the `_mouse_scroll` function, which takes in x and y coordinates along with dx and dy (amount of scroll) as parameters. The `length_limit` function is defined as a helper function that checks if a byte-like object's length equals to specified length. Additionally, there are imports from Xlib and other modules, but the exact functionality of these is not clear without more context.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hid_utils.py\":70-120",
            "content": "    self,\n        x: Union[int, float],\n        y: Union[int, float],\n        dx: Union[int, float],\n        dy: Union[int, float],\n    ):\n        \"\"\"\n        Scroll mouse (dx, dy) at absolute position (x, y).\n        \"\"\"\n        return self._mouse_scroll(x=x, y=y, dx=dx, dy=dy)\n    @abstractmethod\n    def _mouse_scroll(\n        self,\n        x: Union[int, float],\n        y: Union[int, float],\n        dx: Union[int, float],\n        dy: Union[int, float],\n    ):\n        ...\ndef length_limit(l):\n    return Is[lambda b: len(b) == l]\n# import Xlib\n# python-xlib\nimport os\nsourcefile_dirname = os.path.dirname(os.path.abspath(__file__))\nkey_literal_to_xk_keysym_translation_table_path = os.path.join(\n    sourcefile_dirname, \"KL2XKS.json\"\n)\nfrom functools import lru_cache\nimport json\n@lru_cache\ndef getKL2XKS() -> Dict[str, str]:\n    with open(key_literal_to_xk_keysym_translation_table_path, \"r\") as f:\n        KL2XKS = json.loads(f.read())\n    return KL2XKS\nfrom beartype import beartype\n@beartype\ndef strip_key_literal(key_literal: "
        },
        {
            "comment": "Function \"strip_key_literal\" checks if the given key literal is a special or media key and returns its stripped name. If the key literal has an abnormal enclosed keychar, it raises an exception. If the keychar is Ellipsis, it raises an exception as well. Otherwise, it returns a tuple of whether it's a special or media key, the stripped key character if it is a special key with a \"media_\" prefix, and the original key literal without prefixes if not special.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hid_utils.py\":120-145",
            "content": "HIDActionTypes.keys) -> Tuple[bool, bool, str]:\n    # defer strip/lstrip.\n    # it is not a bug. do not report.\n    is_special, is_media = False, False\n    keychar = ...\n    if key_literal.startswith(prefix := \"Key.\"):\n        is_special = True\n        keychar = key_literal.replace(prefix, \"\")\n        if keychar.startswith(prefix := \"media_\"):\n            is_media = True\n            keychar = keychar.replace(prefix, \"\")\n    if len(key_literal) == 3:\n        if not (key_literal[0] == key_literal[2] != (keychar := key_literal[1])):\n            raise Exception(f\"Abnormal enclosed keychar: {repr(key_literal)}\")\n    if keychar == Ellipsis:\n        raise Exception(f\"Unable to strip key literal: {repr(key_literal)}\")\n    else:\n        return is_special, is_media, keychar\n@beartype\ndef key_literal_to_xk_keysym(key_literal: HIDActionTypes.keys) -> Union[None, str]:\n    # is_special, is_media, stripped_key_literal = strip_key_literal(key_literal)\n    KL2XKS = getKL2XKS()\n    xk_keysym = KL2XKS.get(key_literal, None)\n "
        },
        {
            "comment": "This code defines several type aliases for different byte lengths and some integer ranges. It also has a class called ControlCode which is defined as a Flag. The code seems to be related to handling key literals, XK keysyms, and potentially input validation based on these types.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hid_utils.py\":145-173",
            "content": "   if xk_keysym is None:\n        print(f\"skipping translating key literal {repr(key_literal)} to xk_keysym.\")\n    return xk_keysym\n    # Xlib.XK.string_to_keysym(stripped_key_literal)\n    # generate this translation table statically, then we will review.\ndef byte_with_length_limit(l):\n    return Annotated[bytes, length_limit(l)]\none_byte: TypeAlias = byte_with_length_limit(1)\ntwo_bytes: TypeAlias = byte_with_length_limit(2)\nfour_bytes: TypeAlias = byte_with_length_limit(4)\nsix_bytes: TypeAlias = byte_with_length_limit(6)\neight_bytes: TypeAlias = byte_with_length_limit(8)\nnon_neg_int: TypeAlias = Annotated[int, Is[lambda i: i >= 0]]\npos_int: TypeAlias = Annotated[int, Is[lambda i: i > 0]]\nmovement: TypeAlias = Annotated[\n    int, Is[lambda i: i >= -126 and i <= 126]\n]  # this is hardware limit. software might not be limited. (shall we adapt to software limit instead of hardware)\nclass ControlCode(Flag):\n    # @staticmethod\n    # def _generate_next_value_(name, start, count, last_values):\n    #     return 2"
        },
        {
            "comment": "This code defines classes for different types of buttons (MouseButton, MultimediaKey) using the Flag and Enum classes. It represents each button as a power of 2, with NULL or Null being 0. The code also includes definitions for various multimedia keys organized into three rows.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hid_utils.py\":173-228",
            "content": " ** (count)\n    NULL = 0\n    LEFT_CONTROL = auto()\n    LEFT_SHIFT = auto()\n    LEFT_ALT = auto()\n    LEFT_GUI = auto()\n    RIGHT_CONTROL = auto()\n    RIGHT_SHIFT = auto()\n    RIGHT_ALT = auto()\n    RIGHT_GUI = auto()\nclass MouseButton(Flag):\n    # class MouseButton(Enum):\n    # @staticmethod\n    # def _generate_next_value_(name, start, count, last_values):\n    #     return 2 ** (count)\n    NULL = 0\n    LEFT = auto()\n    RIGHT = auto()\n    MIDDLE = auto()\nclass MultimediaKey(Flag):\n    # class MultimediaKey(Enum):\n    # @staticmethod\n    # def _generate_next_value_(name, start, count, last_values):\n    #     return 2 ** (count)\n    Null = 0\n    # row 1\n    VolumeUp = auto()\n    VolumeDown = auto()\n    Mute = auto()\n    PlayPause = auto()\n    NextTrack = auto()\n    PreviousTrack = auto()\n    CDStop = auto()\n    Eject = auto()\n    # row 2\n    EMail = auto()\n    WWWSearch = auto()\n    WWWFavourites = auto()\n    WWWHome = auto()\n    WWWBack = auto()\n    WWWForward = auto()\n    WWWStop = auto()\n    Refresh = auto()\n    # row 3\n    Med"
        },
        {
            "comment": "The code is defining classes and variables for handling various input operations. It creates classes like MultimediaKey, ACPIKey, Explorer, Calculator, etc., which are used to handle specific types of key inputs. It also generates a table mapping Unicode strings to xk_keysyms. The purpose seems to be related to handling different keys and their associated functions in an input-processing system.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hid_utils.py\":228-272",
            "content": "ia = auto()\n    Explorer = auto()\n    Calculator = auto()\n    ScreenSave = auto()\n    MyComputer = auto()\n    Minimize = auto()\n    Record = auto()\n    Rewind = auto()\nassert len(MultimediaKey.__members__) == 3 * 8 + 1  # include \"Null\"\nclass ACPIKey(Flag):\n    Null = 0  # for clearing all \"ACPI\" keys.\n    Power = auto()\n    Sleep = auto()\n    Wakeup = auto()\nif __name__ == \"__main__\":\n    # generate that table.\n    import Levenshtein as L\n    import keysymdef\n    unicode_str_to_xk_keysym = {}\n    xk_keysyms = []\n    xk_keysyms_lut = {}\n    for xk_keysym, _, unicode_int in keysymdef.keysymdef:\n        unicode_str = None\n        as_unicode_char = False\n        if unicode_int:\n            try:\n                unicode_str = chr(unicode_int)\n                unicode_str_to_xk_keysym[unicode_str] = xk_keysym\n                as_unicode_char = True\n            except:\n                pass\n        xk_keysym_lower = xk_keysym.lower()\n        xk_keysyms_lut[xk_keysym_lower] = xk_keysym\n        # if not as_unicode_char:\n        xk"
        },
        {
            "comment": "The code defines a translation table for converting keyboard literals to their respective meanings. It then defines a function called `translate` that replaces the keywords in a string with their corresponding translations using a dictionary. The code also imports the `re` module and loops over each key literal, stripping any special or media prefixes before checking if it exists in the unicode-to-xk_keysym mapping. If it does, it breaks execution.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hid_utils.py\":272-304",
            "content": "_keysyms.append(xk_keysym_lower)  # for space.\n    KL2XKS = {}\n    # import rich\n    # rich.print(xk_keysyms_lut)\n    # breakpoint()\n    keywords_translation_table = dict(\n        cmd=\"super\",\n        ctrl=\"control\",\n        _left=\"_l\",\n        _right=\"_r\",\n        esc=\"escape\",\n        enter=\"return\",\n        # we do not use xf86 (multimedia) keys. or shall we? how to handle the play/pause button then?\n    )\n    def translate(string: str, translation_table: Dict[str, str]):\n        for k, v in translation_table.items():\n            string = string.replace(k, v)\n        return string\n    import re\n    for key_literal in HIDActionBase.keys:  # nearly instant. no need for progressbar.\n        is_special, is_media, stripped_key_literal = strip_key_literal(key_literal)\n        if is_media:\n            continue\n        # media prefix is removed.\n        # if \"eth\" in stripped_key_literal.lower():\n        #     breakpoint()\n        if stripped_key_literal in unicode_str_to_xk_keysym.keys():\n            keysym = unicod"
        },
        {
            "comment": "This code is translating key literals to XK_KEYSYMs, storing the translation in a dictionary and writing it to a file. It first checks if the key literal starts with \"alt\", \"control\", \"cmd\", or \"shift\" and adds an underscore before the letter if it does. Then it sorts the XK_KEYSYMs based on the distance between their lowercase strings and the stripped_key_literal, selects the closest one and updates a dictionary of key literals to their respective XK_KEYSYMs. Finally, it writes this dictionary to a file.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hid_utils.py\":304-323",
            "content": "e_str_to_xk_keysym[stripped_key_literal]\n        else:\n            # import humps\n            stripped_key_literal = translate(\n                re.sub(\n                    r\"^(alt|control|cmd|shift)$\", r\"\\1_l\", stripped_key_literal.lower()\n                ),\n                keywords_translation_table,\n            )\n            # if \"return\" in stripped_key_literal:\n            #     breakpoint()\n            xk_keysyms.sort(\n                key=lambda keysym: L.distance(keysym.lower(), stripped_key_literal)\n            )\n            keysym = xk_keysyms.pop(0)\n        KL2XKS.update(val := {key_literal: xk_keysyms_lut[keysym]})\n        print(val, key_literal, stripped_key_literal)\n    with open(key_literal_to_xk_keysym_translation_table_path, \"w+\") as f:\n        f.write(json.dumps(KL2XKS, ensure_ascii=False, indent=4))\n    logger_print(\"write to:\", key_literal_to_xk_keysym_translation_table_path)"
        }
    ]
}