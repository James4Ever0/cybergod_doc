{
    "summary": "The code defines a decorator function for caching with expiration time, includes functions for caching, querying server info, and handling GET requests with timeout management and exception handling. In case of fatal errors or unknown exceptions, it attempts to kill the process.",
    "details": [
        {
            "comment": "beat_server_address is defined with host, port, beat_url, info_url, and url_prefix.\nbeat_client_data contains the URL for beat_server_address and other parameters like timeout and access_time_key.\ntimed_lru_cache is a function that extends lru_cache with timeout, maxsize, and typed parameters.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/beat_common.py\":0-31",
            "content": "beat_server_address = dict(\n    host=\"0.0.0.0\",\n    port=(server_port := 8771),\n    beat_url=\"/beat_request\",\n    info_url=\"/info\",\n    url_prefix=f\"http://localhost:{server_port}\",\n)\nbeat_client_data = dict(\n    url=(f\"{beat_server_address['url_prefix']}{beat_server_address['beat_url']}\"),\n    info_url=f\"{beat_server_address['url_prefix']}{beat_server_address['info_url']}\",\n    timeout=2,\n    access_time_key=\"access_time\",\n)\n# BEAT_FAILED = 255\nfrom functools import lru_cache, wraps\nfrom time import monotonic_ns\n# use cacheout instead.\n# ref: https://github.com/dgilland/cacheout\ndef timed_lru_cache(\n    _func=None, *, seconds: int = 7000, maxsize: int = 128, typed: bool = False\n):\n    \"\"\"Extension over existing lru_cache with timeout\n    :param seconds: timeout value\n    :param maxsize: maximum size of the cache\n    :param typed: whether different keys for different types of cache keys\n    \"\"\"\n    def wrapper_cache(f):\n        # create a function wrapped with traditional lru_cache\n        f = lru_cache(maxsize=m"
        },
        {
            "comment": "This code defines a function decorator that adds caching functionality to the decorated function, with expiration time in nanoseconds. If the cache has expired, it clears the cache and sets a new expiration time.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/beat_common.py\":31-60",
            "content": "axsize, typed=typed)(f)\n        # convert seconds to nanoseconds to set the expiry time in nanoseconds\n        f.delta = seconds * 10**9\n        f.expiration = monotonic_ns() + f.delta\n        @wraps(f)  # wraps is used to access the decorated function attributes\n        def wrapped_f(*args, **kwargs):\n            if monotonic_ns() >= f.expiration:\n                # if the current cache expired of the decorated function then\n                # clear cache for that function and set a new cache value with new expiration time\n                f.cache_clear()\n                f.expiration = monotonic_ns() + f.delta\n            return f(*args, **kwargs)\n        wrapped_f.cache_info = f.cache_info\n        wrapped_f.cache_clear = f.cache_clear\n        return wrapped_f\n    # To allow decorator to be used without arguments\n    if _func is None:\n        return wrapper_cache\n    else:\n        return wrapper_cache(_func)\nimport requests\n# from frozendict import frozendict\n# create a session object\nsession = requests.Sessio"
        },
        {
            "comment": "The code contains a function heartbeat_base that caches the result for 1 second and retrieves it from a server. It also has a query_info function to get information from the server, and request_with_timeout_and_get_json_data function that handles HTTP GET requests with timeout handling.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/beat_common.py\":60-89",
            "content": "n()  # effectively faster. really?\n@timed_lru_cache(seconds=1, maxsize=1)\ndef heartbeat_base(uuid: str, action: str, pid: int, role: str):\n    return heartbeat_base_nocache(uuid, action, pid, role)\ndef heartbeat_base_nocache(uuid: str, action: str, pid: int, role: str):\n    params = dict(uuid=uuid, action=action, pid=pid, role=role)\n    url = beat_client_data[\"url\"]\n    data = request_with_timeout_and_get_json_data(params, url)\n    access_time = data[beat_client_data[\"access_time_key\"]]\n    return access_time\ndef query_info():\n    return request_with_timeout_and_get_json_data(dict(), beat_client_data[\"info_url\"])\nfrom log_common import log_and_print_unknown_exception\nimport os\nimport signal\nimport func_timeout\ndef request_with_timeout_and_get_json_data(params: dict, url: str, success_code=200):\n    try:\n        r = session.get(url, params=params, timeout=beat_client_data[\"timeout\"])\n        assert r.status_code == success_code\n        data = r.json()\n    except func_timeout.dafunc.FunctionTimedOut as exc:\n "
        },
        {
            "comment": "This code handles exceptions and potential timeouts in a program. It prints the exception, indicates a fatal error, logs an unknown exception, and then attempts to kill the process with `os.kill()` function.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/beat_common.py\":89-101",
            "content": "       print(exc)\n        print(\"timed out by external wrapper\")\n    except:\n        log_and_print_unknown_exception()\n        print(\"fatal error. cannot beat.\")\n        self_pid = os.getpid()\n        print(f'suicide now. (pid: {self_pid})')\n        kill_by_pid(self_pid)\n    return data\ndef kill_by_pid(pid):\n    kill_signal = getattr(signal, 'SIGKILL', signal.SIGTERM) # adaption for windows\n    os.kill(pid, kill_signal)"
        }
    ]
}