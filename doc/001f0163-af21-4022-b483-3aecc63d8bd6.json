{
    "summary": "The code uses Pynput to control keyboard/mouse, handles DPI-awareness on Windows and initializes via hotkeys. It maintains event order but lacks \"ctrl + /\" handling, supporting various actions for both keyboard and mouse input.",
    "details": [
        {
            "comment": "The code defines a dictionary of lower and unshift keycodes, allowing for the conversion between them. It also mentions that special keys like \"ctrl + /\" are not recorded, which is a limitation in the system.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/player.py\":0-59",
            "content": "# just to play the recorded events out.\n# not doing anything beyond that.\n# special keys are not recorded. what a shame.\nimport ast\nimport os\n# what about \"ctrl + /\" ?\ndef unshift(key):\n    lower_keycodes = {\n        \"A\": \"a\",\n        \"B\": \"b\",\n        \"C\": \"c\",\n        \"D\": \"d\",\n        \"E\": \"e\",\n        \"F\": \"f\",\n        \"G\": \"g\",\n        \"H\": \"h\",\n        \"I\": \"i\",\n        \"J\": \"j\",\n        \"K\": \"k\",\n        \"L\": \"l\",\n        \"M\": \"m\",\n        \"N\": \"n\",\n        \"O\": \"o\",\n        \"P\": \"p\",\n        \"Q\": \"q\",\n        \"R\": \"r\",\n        \"S\": \"s\",\n        \"T\": \"t\",\n        \"U\": \"u\",\n        \"V\": \"v\",\n        \"W\": \"w\",\n        \"X\": \"x\",\n        \"Y\": \"y\",\n        \"Z\": \"z\",\n    }\n    unshift_keycodes = {\n        \"!\": \"1\",\n        \"@\": \"2\",\n        \"#\": \"3\",\n        \"$\": \"4\",\n        \"%\": \"5\",\n        \"^\": \"6\",\n        \"&\": \"7\",\n        \"*\": \"8\",\n        \"(\": \"9\",\n        \")\": \"0\",\n        \"_\": \"-\",\n        \"+\": \"=\",\n        \"{\": \"[\",\n        \"}\": \"]\",\n        \"|\": \"\\\\\",\n        \":\": \";\",\n        '\"': \"'\",\n        \"<\": \",\",\n        \">\": \".\",\n    "
        },
        {
            "comment": "This code defines two dictionaries: one for special characters and another for keyboard keycodes. It maps each keycode to its corresponding character in ASCII format.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/player.py\":59-109",
            "content": "    \"?\": \"/\",\n        \"~\": \"`\",\n    }\n    ctrl_keycodes = {\n        \"\\x01\": \"a\",\n        \"\\x02\": \"b\",\n        \"\\x03\": \"c\",\n        \"\\x04\": \"d\",\n        \"\\x05\": \"e\",\n        \"\\x06\": \"f\",\n        \"\\x07\": \"g\",\n        \"\\x08\": \"h\",\n        \"\\t\": \"i\",\n        \"\\n\": \"j\",\n        \"\\x0b\": \"k\",\n        \"\\x0c\": \"l\",\n        \"\\r\": \"m\",\n        \"\\x0e\": \"n\",\n        \"\\x0f\": \"o\",\n        \"\\x10\": \"p\",\n        \"\\x11\": \"q\",\n        \"\\x12\": \"r\",\n        \"\\x13\": \"s\",\n        \"\\x14\": \"t\",\n        \"\\x15\": \"u\",\n        \"\\x16\": \"v\",\n        \"\\x17\": \"w\",\n        \"\\x18\": \"x\",\n        \"\\x19\": \"y\",\n        \"\\x1a\": \"z\",\n        \"<219>\": \"[\",\n        \"<221>\": \"]\",\n        \"<189>\": \"-\",\n        \"<187>\": \"=\",\n        \"<192>\": \"`\",\n        \"<48>\": \"0\",\n        \"<49>\": \"1\",\n        \"<50>\": \"2\",\n        \"<51>\": \"3\",\n        \"<52>\": \"4\",\n        \"<53>\": \"5\",\n        \"<54>\": \"6\",\n        \"<55>\": \"7\",\n        \"<56>\": \"8\",\n        \"<57>\": \"9\",\n        \"<220>\": \"\\\\\",\n        \"<186>\": \";\",\n        \"<222>\": \"'\",\n        \"<188>\": \",\",\n        \"<190>\": \".\",\n        \"<191>\": \"/"
        },
        {
            "comment": "This code is initializing a keyboard and mouse controller using the pynput library. It also handles DPI awareness for Windows systems, reads a JSONL file containing states, and initializes a mouse controller which can be controlled by hotkeys. The zoom factor is not important once the reference is used.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/player.py\":109-152",
            "content": "\",\n    }\n    key = unshift_keycodes.get(\n        key, ctrl_keycodes.get(key, lower_keycodes.get(key, key))\n    )\n    return key\n# how to play that?\n# using jsonl?\n# timestep = 0.01\nfrom config import timestep\n# zoom_factor = 1.75\n# you can safely ignore the zoom factor once using this in the reference:\n# https://pynput.readthedocs.io/en/latest/mouse.html#monitoring-the-mouse\nimport os\n# main problem is the hotkey. but the modifiers are certain.\n# you can know that for sure.\nif os.name == \"nt\":\n    import ctypes\n    PROCESS_PER_MONITOR_DPI_AWARE = 2\n    ctypes.windll.shcore.SetProcessDpiAwareness(PROCESS_PER_MONITOR_DPI_AWARE)\n# better use pyautogui for mouse?\nimport jsonlines\nimport time\nimport pynput\nimport pyautogui\n# filePath = \"states.jsonl\"\nfrom config import filePath\nwith jsonlines.open(filePath) as r:\n    stateList = list(r.iter())\n# import math\nkeyboard_controller = pynput.keyboard.Controller()\nmouse_controller = pynput.mouse.Controller()\nmouse_buttons = [\n    pynput.mouse.Button.left, pynput.mouse.Button.righ"
        },
        {
            "comment": "This code handles key and mouse events from a state list, preserving their order. It uses Pynput for keyboard and mouse controls, and PyAutoGUI for writing keys. It processes \"key_press\" and \"key_release\" events while also handling mouse button states.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/player.py\":152-178",
            "content": "t, pynput.mouse.Button.middle\n]\nmouse_button_states = {button: False for button in mouse_buttons}\nfor state in stateList:\n    time.sleep(timestep)\n    # perform actions.\n    HIDEvents = state[\"HIDEvents\"]\n    # you need to preserve the order. dump all events into one single list.\n    for action_type, action_args in HIDEvents:\n        print(\"ACTION?\", action_type, action_args)\n        if action_type == \"key_press\":\n            if not action_args.startswith(\"Key.\"):\n                keycode = unshift(\n                    action_args if action_args.startswith(\"<\")\n                    and action_args.endswith(\">\") else ast.literal_eval(action_args)\n                )\n                pyautogui.write(keycode)\n            else:\n                keyboard_controller.press(\n                    pynput.keyboard.Key.__dict__[action_args.split(\".\")[-1]]\n                )\n        elif action_type == \"key_release\":\n            if action_args.startswith(\"Key.\"):\n                keyboard_controller.release(\n                    py"
        },
        {
            "comment": "Code handles different types of actions related to keyboard and mouse input.\n\n- Keyboard action: Executes the corresponding keypress using pynput library.\n- Mouse move action: Updates the position of the mouse controller.\n- Mouse click action: Handles mouse button press or click based on pressed state.\n- Mouse scroll action: Not fully implemented due to zoom_factor calculation missing.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/player.py\":178-203",
            "content": "nput.keyboard.Key.__dict__[action_args.split(\".\")[-1]]\n                )\n        elif action_type == \"mouse_move\":\n            x, y = action_args\n            # x = math.floor(x/zoom_factor)\n            # y = math.floor(y/zoom_factor)\n            mouse_controller.position = (x, y)\n        elif action_type == \"mouse_click\":\n            x, y, button, pressed = action_args\n            # x = math.floor(x/zoom_factor)\n            # y = math.floor(y/zoom_factor)\n            button = pynput.mouse.Button.__dict__[button.split(\".\")[-1]]\n            mouse_button_states[button] = pressed\n            mouse_controller.position = (x, y)\n            if pressed:\n                mouse_controller.press(button)\n            else:\n                mouse_controller.click(button)\n        elif action_type == \"mouse_scroll\":\n            x, y, dx, dy = action_args\n            # x = math.floor(x/zoom_factor)\n            # y = math.floor(y/zoom_factor)\n            # dx = math.floor(dx/zoom_factor)\n            # dy = math.floor(dy/zoom_fa"
        },
        {
            "comment": "Updates mouse and keyboard positions based on action type.\nEnsures mouse button is not held down after movement.\nReleases modifier keys if still pressed.\nChecks for remaining held mouse buttons and releases them.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/player.py\":203-219",
            "content": "ctor)\n            mouse_controller.position = (x, y)\n            mouse_controller.scroll(dx, dy)\n        else:\n            raise Exception(\"Unknown action type: {}\".format(action_type))\n# after all the havok, you should not leave the mouse button pressed, and you should not leave any button onhold.\nmodifier_keys = [\"alt\", \"alt_gr\", \"ctrl\", \"shift\"]\nfor modifier_key in modifier_keys:\n    if keyboard_controller.__getattribute__(f\"{modifier_key}_pressed\"):\n        keyboard_controller.release(pynput.keyboard.Key.__dict__[modifier_key])\nfor button in mouse_buttons:\n    if mouse_button_states[button]:  # pressed, not released yet.\n        mouse_controller.release(button)"
        }
    ]
}