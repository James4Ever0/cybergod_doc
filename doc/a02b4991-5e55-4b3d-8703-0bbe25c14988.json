{
    "summary": "This code imports modules, defines functions to manipulate Python code, performs type checks using pyright linter, handles file updates and outputs formatted code, uses Jinja2 templates for execution, and converts variables into Python.",
    "details": [
        {
            "comment": "This code imports various modules and defines functions to manipulate Python code, such as removing type hints and converting variable names between different cases. It also includes a function to convert camel case to snake case.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/jinja_utils.py\":0-42",
            "content": "from log_utils import logger_print\nimport subprocess\nfrom tempfile import TemporaryDirectory\nimport black\n# from humps import kebabize\nimport jinja2\nimport shutil\nimport os\nimport pyright_utils  # for checking if really installed.\nimport re\n# live share's triple quote issue isn't fixed.\nimport humps  # default to snake case!\nimport ast\ndef remove_typehint(paramDef: str) -> str:\n    tree_def = ast.parse(\"def func({}): ...\".format(paramDef)).body[0]\n    args = []\n    for elem in ast.walk(tree_def):\n        if isinstance(elem, ast.arg):\n            argName = elem.arg  # str\n            args.append(argName)\n    return \",\".join([f\"{argName}={argName}\" for argName in args])\ndef camelize_with_space(string):\n    return humps.camelize(string.replace(\" \", \"-\"))\n# ref: https://www.geeksforgeeks.org/python-program-to-convert-camel-case-string-to-snake-case/\ndef c2s(_str):\n    \"\"\"\n    Camel case to snake case.\n    \"\"\"\n    # return humps.kebabize(_str).replace(\"-\", \"_\")\n    # res = [_str[0].lower()]\n    # for c in _str[1:]:\n    #"
        },
        {
            "comment": "Code comments:\n1. jinja_utils.py:42-83",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/jinja_utils.py\":42-83",
            "content": "     if c in (\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"):\n    #         res.append(\"_\")\n    #         res.append(c.lower())\n    #     else:\n    #         res.append(c)\n    # return \"\".join(res)\n    return humps.decamelize(_str)\ndef s2c(_str, lower: bool):\n    \"\"\"\n    Snake case to camel case.\n    \"\"\"\n    # assert not _str.startswith(\"_\")\n    # lst = _str.split(\"_\")\n    # first_letter = lst[0][0]\n    # lst[0] = (first_letter.lower() if lower else first_letter.upper()) + lst[0][1:]\n    # for i in range(1, len(lst)):\n    #     lst[i] = lst[i].title()\n    # return \"\".join(lst)\n    return getattr(humps, \"camelize\" if lower else \"pascalize\")(_str)\ndef s2cl(_str):\n    \"\"\"\n    Snake case to camel case (starting with lower letter).\n    \"\"\"\n    return s2c(_str, True)\ndef s2cu(_str):\n    \"\"\"\n    Snake case to camel case (starting with upper letter).\n    \"\"\"\n    return s2c(_str, False)\nclass NeverUndefined(jinja2.StrictUndefined):\n    def __init__(self, *args, **kwargs):\n        # ARGS: (\"parameter 'myvar2' was not provided\",)\n        # KWAR"
        },
        {
            "comment": "load_render_and_format function takes template path, output path, render params, banner and optional needFormat (default True) as input. It loads the template from the specified path, renders it with render params as arguments and prints the result to the logger with a banner separator. If output_path exists, it reads its content for backup, else sets backup content as an empty string.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/jinja_utils.py\":83-119",
            "content": "GS: {'name': 'myvar2'}\n        if len(args) == 1:\n            info = args[0]\n        elif \"name\" in kwargs.keys():\n            info = f\"Undefined variable '{kwargs['name']}\"\n        else:\n            infoList = [\"Not allowing any undefined variable.\"]\n            infoList.append(f\"ARGS: {args}\")\n            infoList.append(f\"KWARGS: {kwargs}\")\n            info = \"\\n\".join(infoList)\n        raise Exception(info)\ndef load_render_and_format(\n    template_path: str,\n    output_path: str,\n    render_params: dict,\n    banner: str,\n    needFormat: bool = True,\n):\n    tpl = load_template(template_path)\n    result = tpl.render(**render_params)\n    logger_print()\n    logger_print(\"______________________[{}]\".format(banner))\n    logger_print(result)\n    # import black.Mode\n    output_path_elems = output_path.split(\".\")\n    output_path_elems.insert(-1, \"new\")\n    if os.path.exists(output_path):\n        with open(output_path, \"r\") as f:\n            backup_content = f.read()\n    else:\n        backup_content = \"\"\n    with open(tmp"
        },
        {
            "comment": "Writes formatted code to output file, optionally formats again if not needed format, and performs additional type checking.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/jinja_utils.py\":119-145",
            "content": "_output_path := \".\".join(output_path_elems), \"w+\") as f:\n        f.write(result)\n    if not needFormat:\n        shutil.move(tmp_output_path, output_path)\n        return\n    try:\n        # TODO: add more test, like checking for undefined variables, before rewriting the source file.\n        # TODO: add rollback mechanism in makefile\n        result = black.format_str(result, mode=black.Mode())\n        logger_print(\"Formatter Ok.\")\n        # with TemporaryDirectory() as TP:\n        with open(output_path, \"w+\") as f:\n            f.write(result)\n        # do further type checking.\n        # typechecker_input_path = os.path.join(\n        #     TP, base_output_path := os.path.basename(output_path)\n        # )\n        # with open(typechecker_input_path, \"w+\") as f:\n        #     f.write(typechecker_input_path)\n        # output = subprocess.run(\n        #     [\"pyright\", typechecker_input_path],\n        #     capture_output=True,\n        #     encoding=\"utf-8\",\n        # )\n        run_result = pyright_utils.run(\n       "
        },
        {
            "comment": "This code is executing a type check on a Python file and handling any errors produced by the pyright linter. It first creates a temporary output path, captures all standard error messages, converts these messages to a list of strings, appends Pyright error content if applicable, and then raises an exception with the compiled error messages. If there are no errors, it prints \"Pyright Ok.\" Finally, if an error occurs during execution, it catches the error, prints the stack trace, writes the backup content into the output file, and removes the temporary output file.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/jinja_utils.py\":145-172",
            "content": "     output_path, capture_output=True, encoding=\"utf-8\"\n        )\n        typeErrors = [\n            e.strip().replace(\n                os.path.basename(output_path), os.path.basename(tmp_output_path)\n            )\n            for e in re.findall(\n                pyright_utils.errorRegex, run_result.stdout, re.MULTILINE\n            )\n        ]\n        # breakpoint()\n        if run_result.stderr:\n            typeErrors.append(\"\")\n            typeErrors.append(f\"Pyright error:\\n{run_result.stderr}\")\n        if typeErrors:\n            typeErrors.insert(0, f\"Type error found in file {repr(output_path)}\")\n            raise Exception(f\"\\n{' '*4}\".join(typeErrors))\n        logger_print(\"Pyright Ok.\")\n        os.remove(tmp_output_path)\n    except:\n        import traceback\n        traceback.print_exc()\n        # os.remove(tmp_output_path)\n        with open(output_path, \"w+\") as f:\n            f.write(backup_content)\n        # ref: https://www.geeksforgeeks.org/python-os-utime-method/\n        # do not set this to 0 or so"
        },
        {
            "comment": "The code is checking if the output file is older than the template, and if not, it raises an exception. It also includes functions for string lstrip operation, handling code and template paths, and loading a Jinja2 template.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/jinja_utils.py\":172-208",
            "content": "mething. will cause error.\n        os.utime(\n            output_path,\n            times=(\n                os.path.getatime(template_path) - 1000000,\n                os.path.getmtime(template_path) - 1000000,\n            ),\n        )  # to make this older than template, must update!\n        raise Exception(\n            f\"Code check failed.\\nTemporary cache saved to: '{tmp_output_path}'\"\n        )\n    logger_print(\"=\" * 40)\ndef lstrip(string: str):\n    lines = string.split(\"\\n\")\n    result_lines = []\n    for line in lines:\n        result_lines.append(line.lstrip())\n        # if stripped_line := line.lstrip():\n        # result_lines.append(stripped_line)\n    result = \"\\n\".join(result_lines).strip(\"\\n\")\n    return result\ndef code_and_template_path(base_name):\n    code_path = f\"{base_name}.py\"\n    template_path = f\"{code_path}.j2\"\n    return code_path, template_path\ndef load_template(template_path, extra_func_dict={}):\n    try:\n        assert template_path.endswith(\".j2\")\n    except:\n        Exception(f\"jinja template "
        },
        {
            "comment": "Creates a Jinja2 environment with specified settings, loads template from given path.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/jinja_utils.py\":208-244",
            "content": "path '{template_path}' is malformed.\")\n    env = jinja2.Environment(\n        loader=jinja2.FileSystemLoader(searchpath=[\"./\", \"../\"]),\n        extensions=[\n            \"jinja2_error.ErrorExtension\",\n            \"jinja2.ext.do\",\n            \"jinja2.ext.loopcontrols\",\n        ],\n        trim_blocks=True,\n        lstrip_blocks=True,\n        # undefined=jinja2.StrictUndefined,\n        undefined=NeverUndefined,\n    )\n    tpl = env.get_template(template_path)\n    # def myJoin(mstr, mlist):\n    #     logger_print(\"STR:\", repr(mstr))\n    #     logger_print(\"LIST:\", repr(mlist))\n    #     return mstr.join(mlist)\n    func_dict = dict(\n        list=list,\n        str=str,\n        _dict=dict,\n        _set=set,  # avoid name collision\n        tuple=tuple,\n        ord=ord,\n        len=len,\n        repr=repr,\n        c2s=c2s,\n        # s2c=s2c,\n        s2cl=s2cl,\n        s2cu=s2cu,\n        zip=zip,\n        cws=camelize_with_space,\n        lstrip=lstrip,\n        remove_typehint=remove_typehint,\n        kebabize=humps.kebabize,\n        pa"
        },
        {
            "comment": "This code is defining a function that converts Jinja template variables into executable Python code. It also imports and updates the template's globals with specified functions and executes it using subprocess.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/jinja_utils.py\":244-257",
            "content": "scalize=humps.pascalize,\n        # enumerate=enumerate,\n        # eval=eval,\n        # join=myJoin\n        ** extra_func_dict,\n    )\n    tpl.globals.update(func_dict)\n    return tpl\ndef test(cmd: list, exec=\"python3\" if os.name != \"nt\" else \"python\"):\n    cmd = [exec] + cmd\n    p = subprocess.run(cmd)\n    p.check_returncode()"
        }
    ]
}