{
    "summary": "The code imports Redis libraries, defines functions for recordings and controls, includes a TimestampedContext class for timestamped log files management, and provides an exception handling function that shuts down Redis upon main program exceptions.",
    "details": [
        {
            "comment": "This code imports various libraries and defines functions for working with a Redis database, setting and getting prefixes, and handling file paths. It also sets the maximum recording count to 30. The code loads configuration from a JSON file called \"config.json\" and uses UUIDs to generate unique temporary directories for recordings.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/ubuntu_qemu_utm_arm_record/utils.py\":0-49",
            "content": "# timestamp, redis, constants.\n# PYTHON_EXECUTABLE = 'python3' # just in case.\nimport json\nimport time\nfrom typing import Union\nimport functools\nimport redis\nimport os\nimport sys\nPYTHON_EXECUTABLE = sys.executable\n@functools.lru_cache(maxsize=1)\ndef get_redis_client():\n    r = redis.Redis(host=\"localhost\", port=6379, db=0)\n    return r\n# it is the main recorder which will pack all recordings into hdf5 file format after success.\nPREFIX_KEY = \"RECORD_PREFIX\"\nimport uuid\ndef set_prefix():\n    r = get_redis_client()\n    prefix = \"/tmp/{}/\".format(str(uuid.uuid4()).replace(\"-\", \"_\"))\n    print(\"SET PREFIX: {}\".format(prefix))\n    os.mkdir(prefix)\n    r.set(PREFIX_KEY, prefix)\ndef get_prefix():\n    r = get_redis_client()\n    val = r.get(PREFIX_KEY)\n    if val:\n        dval = val.decode('utf-8')\n        print(\"GET PREFIX: {}\".format(dval))\n        return dval\n    return val\nCONFIG_PATH = \"config.json\"\nwith open(CONFIG_PATH, 'r') as f:\n    config = json.load(f)\nMAX_RECORDING_COUNT = 30\nclass filepaths:\n    # prefix = config['fil"
        },
        {
            "comment": "This code defines a class that manages the recording and control of HID, audio, and video data. It sets up various file paths for storing the recordings and their timestamps. The code also includes functions for setting and getting values from Redis, a data store, to signal if the main recorder is on or off.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/ubuntu_qemu_utm_arm_record/utils.py\":49-91",
            "content": "epaths_prefix']\n    # @property\n    prefix = get_prefix()\n    target_prefix = config['filepaths_prefix']\n    # prefix = \"./test_record/\"\n    hid_record = \"{}hid_record.jsonl\".format(prefix)\n    audio_record = \"{}audio_record.wav\".format(prefix)\n    video_record = \"{}video_record.mp4\".format(prefix)\n    video_record_script = \"{}video_record_script.sh\".format(prefix)\n    video_timestamps = \"{}video_timestamps.json\".format(prefix)\n    hid_timestamps = \"{}hid_timestamps.json\".format(prefix)\n    audio_timestamps = \"{}audio_timestamps.json\".format(prefix)\nlock_key = \"HID_MAIN_RECORDER_LOCK\"\nsig_on = \"ON\"\nsig_off = \"OFF\"\ntimestep = 0.03\n# filePath = \"states.jsonl\"\ndef set_redis_off():\n    r = get_redis_client()\n    r.set(lock_key, sig_off)\ndef set_redis_on():\n    r = get_redis_client()\n    r.set(lock_key, sig_on)\ndef get_redis_value() -> Union[None, str]:\n    r = get_redis_client()\n    val = r.get(lock_key)\n    if val:\n        val = val.decode(\"utf-8\")\n    return val\ndef check_redis_off():\n    return get_redis_value() == "
        },
        {
            "comment": "This code defines a class, TimestampedLogCreater, that tracks and saves timestamps in a file. The `commit()` method records a new timestamp every second, while the `read()` method loads previous timestamps from the file if it exists.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/ubuntu_qemu_utm_arm_record/utils.py\":91-128",
            "content": "sig_off\ndef check_redis_on():\n    return get_redis_value() == sig_on\nclass TimestampedLogCreater:\n    def __init__(self, file_name, indent_output=True):\n        self.file_name = file_name\n        self.timestamp_list = []\n        self.indent_output = indent_output\n        self.last_int_timestamp = -1\n    def clear(self):\n        self.timestamp_list = []\n    def commit(self):\n        timestamp = time.time()\n        # show info every 1 second.\n        int_timestamp = int(timestamp)\n        if int_timestamp > self.last_int_timestamp:\n            print(\"Appending timestamp at `{}`:\".format(\n                self.file_name), timestamp)\n            self.last_int_timestamp = int_timestamp\n        self.timestamp_list.append(timestamp)\n    def read(self):\n        with open(self.file_name, \"r\") as f:\n            string = f.read()\n            data = json.loads(string)\n        for elem in data:\n            assert type(elem) == float\n        self.timestamp_list = data\n        return data\n    def write(self):\n        with open(se"
        },
        {
            "comment": "Creates a TimestampedContext class for managing timestamped log files. If file exists and is not a file, raises an exception. If file exists and is a file, removes it. Opens the file in write mode and writes JSON-formatted timestamp list to it. Prints log write location upon successful writing.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/ubuntu_qemu_utm_arm_record/utils.py\":128-153",
            "content": "lf.file_name, \"w+\") as f:\n            string = json.dumps(\n                self.timestamp_list, indent=4 if self.indent_output else None\n            )\n            f.write(string)\n        print(\"TIMESTAMPED LOG WRITE TO: {}\".format(self.file_name))\n# create some context manager, for exporting the timestamped log.\nclass TimestampedContext:\n    def __init__(self, file_name):\n        self.file_name = file_name\n        print(\"INIT TIMESTAMPED CONTEXT AT: {}\".format(self.file_name))\n        if os.path.exists(file_name):\n            if os.path.isfile(file_name):\n                print(\"REMOVING OLD TIMESTAMPED CONTEXT AT: {}\".format(\n                    self.file_name))\n                os.remove(file_name)\n            else:\n                raise Exception(\n                    \"PATH {} EXISTS AND IS NOT A FILE.\".format(self.file_name)\n                )\n        self.mTimestampedLogCreater = TimestampedLogCreater(self.file_name)\n    def __enter__(self):\n        print(\"ENTER TIMESTAMPED CONTEXT AT: {}\".format(self.file"
        },
        {
            "comment": "Function to create a timestamped log file and handle exceptions.\n\nThis code defines two functions - `TimestampedContext` and `set_redis_off_on_exception`. \n\n1. The `TimestampedContext` function is a context manager that creates a log file with a timestamp in its name. It writes to the file on exit. If an exception occurs, it will print an error message instead of writing to the log file.\n2. The `set_redis_off_on_exception` function sets up an exception hook that shuts down the Redis server and turns it off when an exception is thrown in the main program.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/ubuntu_qemu_utm_arm_record/utils.py\":153-182",
            "content": "_name))\n        return self.mTimestampedLogCreater\n    def __exit__(self, exc_type, exc_value, exc_traceback):\n        # we don't have to take care of this.\n        if exc_type == None:\n            self.mTimestampedLogCreater.write()\n        else:\n            print(\"ERROR IN TIMESTAMPED CONTEXT\")\n            print(\"NOT WRITING TIMESTAMPED LOG AT {}\".format(self.file_name))\n        print(\"EXITING TIMESTAMPED CONTEXT\")\ndef set_redis_off_on_exception(main=False):\n    def exception_hook(exc_type, exc_value, tb):\n        # print('Traceback:')\n        # filename = tb.tb_frame.f_code.co_filename\n        # name = tb.tb_frame.f_code.co_name\n        # line_no = tb.tb_lineno\n        # print(f\"File {filename} line {line_no}, in {name}\")\n        # # Exception type and value\n        # print(f\"{exc_type.__name__}, Message: {exc_value}\")\n        if main:\n            if os.path.exists(get_prefix()):\n                os.system(\"rm -rf {}\".format(get_prefix()))\n        set_redis_off()\n        import traceback\n        print(\"*** "
        },
        {
            "comment": "This code is handling unhandled exceptions by printing the last traceback.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/ubuntu_qemu_utm_arm_record/utils.py\":182-193",
            "content": "Traceback: ***\")\n        # traceback.print_tb(tb)\n        # breakpoint()\n        traceback.print_last()\n        # traceback.print_exc()\n        # traceback.print_tb(tb, limit=10)\n        # print(dir(tb))\n        # tb.print_tb()\n        # traceback.print_exc()\n        # tb.print_exc_info()\n    sys.excepthook = exception_hook"
        }
    ]
}