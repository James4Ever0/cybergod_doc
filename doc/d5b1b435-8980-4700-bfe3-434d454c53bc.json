{
    "summary": "This code handles Docker service management across different OS, including stopping, restarting, and killing. It uses platform-specific commands but experiences hanging issues on Win11. The code ensures successful launch through multiple trials with a wait period on Windows or macOS.",
    "details": [
        {
            "comment": "Code snippet is related to controlling and restarting the Docker daemon on different operating systems. It provides different methods for MacOS and Linux systems to stop, start or kill the Docker application or service respectively.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/rerun_docker_daemon.py\":0-18",
            "content": "# TODO: eliminate stale containers by restarting docker every 10 sessions.\nMACOS_DOCKER_APP_BINARY = \"/Applications/Docker.app/Contents/MacOS/Docker\"\n# killall Docker && open -j -a Docker\n# ps aux | grep Docker.app | grep -v grep | awk '{print $2}' | xargs -Iabc kill abc\nHIDE_DOCKER_ASCRIPT = \"\"\"\ntell application \"System Events\"\n    set visible of processes where name is \"Docker Desktop\" to false\nend tell\n\"\"\"\nWINDOW_TITLE_KW = \"Docker Desktop\"\n# killall docker\n# MACOS_TERM_DOCKER_APP = \"\"\" bash -c 'ps aux | grep Docker.app | grep -v grep | awk \"{print \\\\$2}\" | xargs -I abc kill abc' \"\"\"\nMACOS_KILL_DOCKER_APP = \"\"\" bash -c 'ps aux | grep Docker.app | grep -v grep | awk \"{print \\\\$2}\" | xargs -I abc kill -s KILL abc' \"\"\"\nimport subprocess\nLINUX_CONTROL_DOCKER_SERVICE_CMDGEN = lambda action: f\"sudo systemctl {action} docker\"\nLINUX_RESTART_DOCKER_COMMAND = LINUX_CONTROL_DOCKER_SERVICE_CMDGEN(\"restart\")\nLINUX_STOP_DOCKER_COMMAND = LINUX_CONTROL_DOCKER_SERVICE_CMDGEN(\"stop\")\nLINUX_START_DOCKER_COMMAND = LINU"
        },
        {
            "comment": "This code aims to stop, restart, or kill the Docker service on Windows systems. It first checks the operating system, then defines a command to kill the Docker process, and lists the required binary \"docker\". The function `execute_os_command_and_assert_safe_exit` is used to execute operating system commands while asserting safe exit codes. However, it mentions that the code does not work on Win11, as the command for killing Docker seems to be hanging.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/rerun_docker_daemon.py\":18-48",
            "content": "X_CONTROL_DOCKER_SERVICE_CMDGEN(\"start\")\n# DOES NOT WORK ON WIN11\n# kill com.docker.backend.exe? seems to be hanging\n# WINDOWS_TERM_DOCKER_COMMAND = 'taskkill /FI \"IMAGENAME eq Docker*\"'\nWINDOWS_KILL_DOCKER_COMMAND = 'taskkill /FI \"IMAGENAME eq Docker*\" /F'\n# start program minimized? instead use pygetwindow to hide the window once found.\n# find 'Docker Desktop.exe'\n# which docker -> ../../ -> 'Docker Desktop.exe'\n# WINDOWS_RESTART_DOCKER_COMMAND = 'powershell -Command \"Restart-Service -Name *docker*\"' # need elevated permissions\n# Stop-Service & Start-Service\n# net stop com.docker.service/docker & net start com.docker.service/docker\nimport platform\nimport elevate\nimport shutil\nimport os\nkill_safe_codes = [0]\nstart_safe_codes = [0]\nsysname = platform.system()\nREQUIRED_BINARIES = [\"docker\"]\nelevate_needed = False\nDOCKER_DESKTOP_EXE = \"Docker Desktop.exe\"\nfrom typing import List\ndef execute_os_command_and_assert_safe_exit(cmd: str, safe_codes: List[int] = [0]):\n    ret = os.system(cmd)  # use cmd.exe on windows"
        },
        {
            "comment": "Checking if Docker window exists and handling Windows specific commands for killing and starting Docker.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/rerun_docker_daemon.py\":48-82",
            "content": ".\n    assert (\n        ret in safe_codes\n    ), f\"Abnormal exit code {ret} while executing following command:\\n{cmd}\"\nkill_docker_cmds = []\nstart_docker_cmds = []\nif sysname in [\"Windows\", \"Darwin\"]:\n    import pygetwindow\nelse:\n    def check_if_docker_window_exists():\n        return False\nif sysname == \"Windows\":\n    REQUIRED_BINARIES.append(\"taskkill\")\n    docker_path = shutil.which(\"docker\")\n    docker_bin_path = os.path.dirname(docker_path)\n    docker_desktop_dir_path = os.path.split(os.path.split(docker_bin_path)[0])[0]\n    docker_desktop_exe_path = os.path.join(docker_desktop_dir_path, DOCKER_DESKTOP_EXE)\n    assert os.path.exists(\n        docker_desktop_exe_path\n    ), f'Failed to find docker desktop executable at: \"{docker_desktop_exe_path}\"'\n    # kill_docker_cmds.append(WINDOWS_TERM_DOCKER_COMMAND)\n    kill_docker_cmds.append(WINDOWS_KILL_DOCKER_COMMAND)\n    start_docker_cmds.append(f'start \"\" \"{docker_desktop_exe_path}\"')  # bloody chatgpt.\n    def hide_docker():\n        for win in pygetwindow.getW"
        },
        {
            "comment": "The code is checking if the Docker window exists and hiding it based on the operating system. It also defines commands for starting and stopping Docker, depending on the system (Windows, Linux, or macOS).",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/rerun_docker_daemon.py\":82-119",
            "content": "indowsWithTitle(WINDOW_TITLE_KW):\n            win: pygetwindow.Win32Window\n            win.hide()\n    def check_if_docker_window_exists():\n        wins = pygetwindow.getWindowsWithTitle(WINDOW_TITLE_KW)\n        exist = len(wins) > 0\n        return exist\nelif sysname == \"Linux\":\n    REQUIRED_BINARIES.append(\"systemctl\")\n    elevate_needed = True\n    kill_docker_cmds.append(LINUX_STOP_DOCKER_COMMAND)\n    start_docker_cmds.append(LINUX_START_DOCKER_COMMAND)\n    def hide_docker():\n        ...\nelif sysname == \"Darwin\":\n    import applescript\n    HIDE_DOCKER_ASCRIPT_OBJ = applescript.AppleScript(HIDE_DOCKER_ASCRIPT)\n    kill_safe_codes.append(256)\n    REQUIRED_BINARIES.extend([\"killall\", \"open\", MACOS_DOCKER_APP_BINARY])\n    kill_docker_cmds.extend(\n        [\n            \"killall Docker\",\n            \"killall docker\",\n            #  MACOS_TERM_DOCKER_APP,\n            MACOS_KILL_DOCKER_APP,\n        ]\n    )\n    # start_docker_cmds.append(MACOS_DOCKER_APP_BINARY)\n    start_docker_cmds.append(\"open -j -a Docker\")\n    start_"
        },
        {
            "comment": "This code appears to be for controlling the Docker daemon. It includes functions to start, stop, and check if the Docker window is open. The code also handles different platforms (possibly MacOS and others) by appending specific commands or raising an exception for unknown platforms. There are also lists of keywords to recognize when checking if Docker has been killed or not.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/rerun_docker_daemon.py\":119-156",
            "content": "docker_cmds.append(f\"open -j -a {MACOS_DOCKER_APP_BINARY}\")\n    start_docker_cmds.append(\"open -a Docker\")\n    start_docker_cmds.append(f\"open -a {MACOS_DOCKER_APP_BINARY}\")\n    def hide_docker():\n        HIDE_DOCKER_ASCRIPT_OBJ.run()\n    def check_if_docker_window_exists():\n        exist = any([WINDOW_TITLE_KW in t for t in pygetwindow.getAllTitles()])\n        return exist\nelse:\n    raise Exception(f\"Unknown platform: {sysname}\")\ndef kill_docker():\n    for cmd in kill_docker_cmds:\n        execute_os_command_and_assert_safe_exit(cmd, kill_safe_codes)\ndef start_docker():\n    for cmd in start_docker_cmds:\n        execute_os_command_and_assert_safe_exit(cmd, start_safe_codes)\nDOCKER_KILLED_KWS = [\n    \"the docker daemon is not running\",\n    \"Cannot connect to the Docker daemon\",\n    \"error during connect\",\n]\ndef verify_docker_killed(timeout=5, encoding=\"utf-8\", inverse: bool = False):\n    output = (\n        subprocess.Popen(\n            [\"docker\", \"ps\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE\n        )\n   "
        },
        {
            "comment": "This code checks if Docker is running and handles the case when it's not running or when it's a daemon. It attempts to verify the Docker launch multiple times, with a specified number of retries and sleep time between each retry. If it fails after all retries, it raises an exception.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/rerun_docker_daemon.py\":156-191",
            "content": "     .communicate(timeout=timeout)[1]\n        .decode(encoding)\n    )\n    killed = any([kw in output for kw in DOCKER_KILLED_KWS])\n    if not inverse:\n        if not killed:\n            raise Exception(\n                f\"Docker not killed.\\nCaptured output from command `docker ps`:\\n{output}\"\n            )\n    else:\n        if killed:\n            raise Exception(\n                f\"Docker not started.\\nCaptured output from command `docker ps`:\\n{output}\"\n            )\nimport time\ndef verify_docker_launched(retries=10, sleep=3, daemon=False):\n    success = False\n    for i in range(retries):\n        try:\n            if not daemon:\n                exist = check_if_docker_window_exists()\n                print(f\"window exists? {exist}\")\n            else:\n                exist = False\n            if not exist:\n                verify_docker_killed(inverse=True)\n            success = True\n            break\n        except Exception as e:\n            if i < retries - 1:\n                print(f\"Retrying in {sleep} seconds...\")\n"
        },
        {
            "comment": "The code attempts to check if required binaries are available in the PATH and restart Docker. It first checks for the existence of each binary, raises an error if any is missing, and then restarts and verifies the Docker daemon. If running on Windows or macOS, it also hides the Docker window after verification.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/rerun_docker_daemon.py\":191-231",
            "content": "                time.sleep(sleep)\n            else:\n                raise e\n    return success\ndef restart_docker():\n    check_required_binaries()\n    print(\"prerequisites checked\")\n    kill_docker()\n    print(\"docker killed\")\n    verify_docker_killed()\n    print(\"kill has been verified\")\n    start_docker()\n    print(\"docker restarted\")\nimport shutil\ndef check_required_binaries():\n    for name in REQUIRED_BINARIES:\n        resolved_path = shutil.which(name)\n        assert resolved_path, f\"{name} is not available in PATH.\"\n        assert os.path.exists(\n            resolved_path\n        ), f\"{name} does not exist.\\nfilepath: {resolved_path}\"\n        print(f\"'{name}' found\")\n# working!\ndef restart_and_verify():\n    # this could be faulty! still stuck even if docker is killed on macOS\n    restart_docker()\n    if sysname in [\"Windows\", \"Darwin\"]:\n        verify_docker_launched()\n        print(\"docker restart verified\")\n        hide_docker()\n        print(\"docker window minimized\")\n    verify_docker_launched(daemon=True)\n"
        },
        {
            "comment": "This code is checking the restart and successful operation of the Docker daemon. It restarts the daemon twice, performs checks, and waits for 3 seconds between trials to ensure stable results.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/rerun_docker_daemon.py\":231-244",
            "content": "    print(\"docker daemon restart verified\")\nif elevate_needed:\n    elevate.elevate(graphical=False)\nif __name__ == \"__main__\":\n    # kill & perform checks if you really have killed docker.\n    # restart & check if restart is successful.\n    # do it once more.\n    for i in range(2):\n        print(f\"trial #{i}\")\n        restart_and_verify()\n        time.sleep(3)  # m1 is running too damn fast. or is it?"
        }
    ]
}