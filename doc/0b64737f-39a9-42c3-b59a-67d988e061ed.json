{
    "summary": "The code initializes a FastAPI app with timezone, roles, and PIDs, manages UUIDs, handles HTTP requests, updates statuses, raises exceptions for mismatches, calculates client status in a network, tracks alive/dead counts, schedules tasks to monitor status, and runs the app using uvicorn.",
    "details": [
        {
            "comment": "Imports necessary packages and initializes a FastAPI application with timezone and scheduling functionalities.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/beat_server.py\":0-44",
            "content": "import fastapi\n# TODO: replace this with gui-attached panel & advanced rescue/countermeasures\napp = fastapi.FastAPI()\nimport datetime\nfrom beat_common import beat_server_address, beat_client_data\nimport pytz\n# with respect to our dearly Py3.6\ntimezone_str = \"Asia/Shanghai\"\n# timezone = pytz.timezone(timezone_str:='Asia/Shanghai')\ntimezone = pytz.timezone(timezone_str)\nimport schedule\n# import threading\nfrom typing import Literal\ndef get_now_and_timestamp():\n    now = get_now()\n    timestamp = now.timestamp()\n    return now, timestamp\nUUID_TO_TIMESTAMP = {}\nUUID_TO_REGISTERED_TIMESTAMP = {}\nUUID_TO_STATUS = {}  # alive -> True; dead -> False\nUUID_TO_PID = {}\nUUID_TO_ROLE = {}\nALIVE_THRESHOLD = 30 * 2  # 30 is a bit of low.\n@app.get(beat_server_address[\"info_url\"])\ndef get_info():\n    schedule.run_pending()\n    _, timestamp = get_now_and_timestamp()\n    return {\n        \"info\": {\n            k: {\n                \"status\": v,\n                \"pid\": UUID_TO_PID[k],\n                \"role\": UUID_TO_ROLE[k],\n                "
        },
        {
            "comment": "This code handles HTTP requests for a beat server, which seems to involve managing UUIDs, roles, and PIDs. It receives requests with specific actions (hello, heartbeat, or kill) and from certain roles (killer, client, or possibly server). It updates the status of the UUID accordingly and raises an exception if there's a mismatch in PID or role values.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/beat_server.py\":44-74",
            "content": "\"timestamp\": UUID_TO_TIMESTAMP[k],\n            }\n            for k, v in UUID_TO_STATUS.items()\n        },\n        \"timestamp\": timestamp,\n    }\n# TODO: delegate this kill signal to other process\n# TODO: pass pid with uuid\n# TODO: get unassigned uuid from here, instead of anywhere else\n# TODO: distributed watchdog & recursive keep alive signal mechanism\n# TODO: count revive time & frequencies\n@app.get(beat_server_address[\"beat_url\"])\ndef beat_request(\n    uuid: str,\n    action: Literal[\"hello\", \"heartbeat\", \"kill\"],\n    role: Literal[\"killer\", \"client\", \"server\"],  # can also be server?\n    pid: int,\n):\n    # start = time.time()\n    strtime, timestamp = get_strtime_and_timestamp()\n    if action != \"kill\":\n        for data_dict, it, it_name in [\n            (UUID_TO_PID, pid, \"PID\"),\n            (UUID_TO_ROLE, role, \"ROLE\"),\n        ]:\n            if uuid not in data_dict.keys():\n                data_dict[uuid] = it\n            elif (old_it := data_dict[uuid]) != it:\n                raise Exception(f\"{it_name} mis"
        },
        {
            "comment": "Code handles client actions (\"hello\", \"kill\", \"heartbeat\") and performs corresponding operations on the dictionaries. If an unknown action is received, it raises an exception.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/beat_server.py\":74-99",
            "content": "match! (old: {old_it}, new: {it})\")\n    if action == \"hello\":\n        print(f\"client {uuid} hello at:\", strtime)\n        UUID_TO_REGISTERED_TIMESTAMP[uuid] = timestamp\n    elif action == \"kill\":\n        print(f\"client {uuid} killed at:\", strtime)\n        for data_dict in [\n            UUID_TO_TIMESTAMP,\n            UUID_TO_REGISTERED_TIMESTAMP,\n            UUID_TO_STATUS,\n            UUID_TO_PID,\n            UUID_TO_ROLE,\n        ]:\n            if uuid in data_dict.keys():\n                del data_dict[uuid]\n    elif action == \"heartbeat\":\n        print(f\"received heartbeat from {uuid} at time {strtime}\")\n    else:\n        raise Exception(f\"client {uuid} with unknown action:\" + action)\n    # end = time.time()\n    if action != \"kill\":\n        if uuid not in UUID_TO_REGISTERED_TIMESTAMP.keys():\n            print(f\"client {uuid} not registered. registering.\")\n            UUID_TO_REGISTERED_TIMESTAMP[uuid] = timestamp\n            # raise Exception(f\"client {uuid} not registered.\")\n        UUID_TO_TIMESTAMP[uuid] ="
        },
        {
            "comment": "Function get_strtime_and_timestamp():\n- Returns current date and time as a string and timestamp.\n\nFunction get_now():\n- Returns the current datetime object with the correct timezone.\n\nFunction check_alive():\n- Checks clients' statuses based on their uptime and remaining lifetimes.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/beat_server.py\":99-130",
            "content": " timestamp\n    # print(f'request processing time: {end-start} secs', )\n    return {beat_client_data[\"access_time_key\"]: strtime}\ndef get_strtime_and_timestamp():\n    now, timestamp = get_now_and_timestamp()\n    strtime = now.strftime(r\"%Y-%m-%d %H:%M:%S\")\n    return strtime, timestamp\ndef get_now():\n    now = datetime.datetime.now(tz=timezone)\n    return now\ndef check_alive():\n    now_strtime, now_timestamp = get_strtime_and_timestamp()\n    alive_roles = []\n    dead_roles = []\n    print(f\"checking clients at {now_strtime}\")\n    for uuid, registered_timestamp in UUID_TO_REGISTERED_TIMESTAMP.items():\n        timestamp = UUID_TO_TIMESTAMP.get(uuid, registered_timestamp)\n        role = UUID_TO_ROLE.get(uuid, \"unknown\")\n        pid = UUID_TO_PID.get(uuid, -1)\n        uptime = now_timestamp - registered_timestamp\n        alive = True\n        life = ALIVE_THRESHOLD - (now_timestamp - timestamp)\n        if life < 0:\n            alive = False\n        UUID_TO_STATUS[uuid] = alive\n        up_status = f\"up: {uptime:.3f} s"
        },
        {
            "comment": "Code snippet is checking the status of clients in a network and providing summary statistics. It tracks the client's uuid, role, pid (Process ID), if it's alive or dead, and how many seconds remaining/dead for. The code also calculates and prints the total number of alive and dead clients. It schedules tasks to check alive status every 1/3 of ALIVE_THRESHOLD time interval.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/beat_server.py\":130-168",
            "content": "ecs\"\n        pid_info = f\"pid: {pid}\"\n        if alive:\n            print(\n                f\"client {uuid} alive ({pid_info}, {life:.3f} secs to death, {up_status})\"\n            )\n            alive_roles.append(role)\n        else:\n            print(\n                f\"client {uuid} ({pid_info}, {up_status}) dead for {-life:.3f} seconds\"\n            )\n            dead_roles.append(role)\n    status_list = UUID_TO_STATUS.values()\n    print(\"summary\".center(60, \"=\"))\n    print(\"total clients:\", len(status_list))\n    print(\"alive clients:\", *role_statistics(alive_roles))\n    print(\"dead clients:\", *role_statistics(dead_roles))\nfrom typing import List\ndef role_statistics(roles: List[str]):\n    details = \", \".join([f\"{r}: {roles.count(r)}\" for r in set(roles)])\n    return len(roles), f\"({details})\" if details else \"\"\n# import time\nschedule.every(int(ALIVE_THRESHOLD / 3)).seconds.do(check_alive)\n# def check_alive_thread():\n#     while True:\n#         time.sleep(1)\n#         schedule.run_pending()\nif __name__ == \"__main__"
        },
        {
            "comment": "Importing uvicorn and running the app with specific host and port values.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/beat_server.py\":168-173",
            "content": "\":\n    import uvicorn\n    # thread = threading.Thread(target=check_alive_thread, daemon=True)\n    # thread.start()\n    uvicorn.run(app, **{k: beat_server_address[k] for k in [\"host\", \"port\"]})"
        }
    ]
}