{
    "summary": "Code creates 2D arrays 'arr' and 'arr2', defines class 'Array' with addition and absolute value methods, and uses numpy and Literal casting. It retrieves annotations from 'myArr' and suggests using Jinja2 macros for type checking/annotation work to prevent errors.",
    "details": [
        {
            "comment": "Code is defining variables `arr` and `arr2` as numpy arrays with shapes 5x10 and 10x5 respectively.\nFunction `add_arrays` takes two numpy arrays of shape 5x10 as input and returns an output numpy array also of shape 5x10.\nVariable `myarr` is assigned the result of calling function `add_arrays` with arrays `arr` and `arr`.\nFunction `reveal_type(myarr)` reveals the actual type of variable `myarr`.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/array_shape_typecheck.py\":0-37",
            "content": "from typing_extensions import reveal_type\nimport numpy as np\n# from typing import Tuple\n# from numpy.typing import NDArray, DTypeLike\nfrom nptyping import NDArray, Shape, Float  # type: ignore\nfrom typing import Any\nM = 5\nN = 10\narr: NDArray[Shape[\"5, 10\"], Any] = np.zeros((M, N))\narr2: NDArray[Shape[\"10, 5\"], Any] = np.zeros((N, M))\n# no annotation!\nimport beartype  # type:ignore\n@beartype.beartype  # check before run?\ndef add_arrays(\n    arr1: NDArray[Shape[\"5, 10\"], Any], arr2: NDArray[Shape[\"5, 10\"], Any]\n) -> NDArray[Shape[\"5, 10\"], Any]:\n    result = arr1 + arr2\n    return result\nmyarr = add_arrays(arr, arr)  # no issue?\n# myarr = add_arrays(arr, arr2)  # only beartype shows issue.\nreveal_type(myarr)\n# from jaxtyping import Array\n# not typechecking. import from jax.\n# from jax import Array  # type: ignore\n# import jaxtyping  # type: ignore\n# from typing_extensions import TypeAlias\nfrom typing import cast\n# mTypeAlias: TypeAlias = jaxtyping.Float[Array, \"dim1 dim2\"]\n# arr3 = cast(mTypeAlias, np.array([[1, 2,"
        },
        {
            "comment": "37-46: Define 2D array 'arr3' with type 'mTypeAlias'.\n47-59: Define 2D array 'arr4' with type 'jaxtyping.Float[Array, \"dim1 dim3\"]'.\n60-68: Define a function 'add2' that takes two 'mTypeAlias' arguments and returns 'mTypeAlias'.\n69-72: Add arrays 'arr3' and 'arr4' using the 'add2' function, but the result is not working as expected.\n75-80: Define generic class 'Array' with type variables for data type and shape tuple.\n81-85: Define '__abs__' method in 'Array' class to return an array of the same data type and shape.\n86-90: Define '__add__' method in 'Array' class to perform addition of two arrays with matching data type and shape.\n92-100: Define 'arr9' as a casted 2D array using numpy and 'Literal' from typing for specific dimensions.\n101-111: Define 'arr10' as a casted 2D array using numpy and 'Literal' from typing for specific dimensions.\n112-114: Add 'arr9' and 'arr10', and store the result in 'arr11'.\n115-117: Add 'arr9' to itself, and store the result in 'arr11'.\n118-123: Define a new type 'myType' using Annotated from typing_extensions for np.ndarray with specific dimensions.\n124-126: Create an instance of 'myType', initialize it with zeros, and store the result in 'myArr'.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/array_shape_typecheck.py\":37-79",
            "content": " 3]]))\n# # arr3: mTypeAlias = np.array([[1, 2, 3]])\n# arr4: jaxtyping.Float[Array, \"dim1 dim3\"] = np.array([[1, 2, 3, 5]])\n# @beartype.beartype\n# def add2(a: mTypeAlias, b: mTypeAlias) -> mTypeAlias:\n#     return a + b\n# # arr5 = add2(arr3, arr4)\n# arr5 = add2(arr3, arr3)  # still not working.\n# from typing import TypeVar, Generic\n# from typing_extensions import TypeVarTuple, Unpack\n# DType = TypeVar(\"DType\")\n# Shape = TypeVarTuple(\"Shape\")\n# class Array(Generic[DType, Unpack[Shape]]):\n#     def __abs__(self) -> Array[DType, Unpack[Shape]]:\n#         ...\n#     def __add__(\n#         self, other: Array[DType, Unpack[Shape]]\n#     ) -> Array[DType, Unpack[Shape]]:\n#         ...\n# from typing import Literal\n# arr9 = cast(Array[int, Literal[1], Literal[3]], np.array([[1, 2, 3]]))\n# arr10 = cast(Array[int, Literal[1], Literal[4]], np.array([[1, 2, 3, 4]]))\n# arr11 = arr9 + arr10  # checked!\n# arr11 = arr9+arr9\nfrom typing_extensions import Annotated\nmyType = Annotated[np.ndarray, 20, 30]\nmyArr: myType = np.zeros((20"
        },
        {
            "comment": "The code is attempting to retrieve annotations from a variable 'myArr'. It first prints the current annotations using `__annotations__` and then mentions the idea of preventing errors by delegating type checking/annotation work to Jinja2 using macros for generating annotations.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/array_shape_typecheck.py\":79-85",
            "content": ", 30))\n# how to get that annotated value?\n# print('ANNOTATION?',myArr.__annotations__)\nprint(__annotations__)\n# {'arr': NDArray[Shape['5, 10'], Any], 'arr2': NDArray[Shape['10, 5'], Any], 'myArr': typing_extensions.Annotated[numpy.ndarray, 20, 30]}\n# one such way to prevent errors is to delegate some type checking/annotation work to jinja2. use macro to generate annotations."
        }
    ]
}