{
    "summary": "The code is a Python script for Docker emulation, providing functions to manage containers and an interactive program. It also includes exception handling with predefined safe types and logging functionality.",
    "details": [
        {
            "comment": "This code appears to be a Python script for emulating an interactive program and working with Docker containers. It imports several modules, performs system checks, and asserts that required binary files like \"docker\" are available in the PATH. The script also checks if the system is running 32-bit or lower and assumes legacy docker support in such cases. It mentions a TODO for profiling the program and includes comments suggesting potential improvements.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py\":0-45",
            "content": "# this will freeze the terminal. what the heck is going wrong?\n# maybe we need to profile this program.\n# you should wait longer while doing init check.\n# maybe you can do some system responsiveness check.\n# check if the system is performing as quick as it should.\nimport gc\n# import getpass\n# TODO: container & process profiler\nimport os\nimport sys\nimport traceback\nimport shutil\nimport easyprocess\nimport elevate\n# timeout this function.\n# from functools import partial\nimport func_timeout\n# import docker  # pip3 install docker\nimport progressbar\nfrom naive_actor import NaiveActor\nfrom vocabulary import AsciiVocab\nREQUIRED_BINARIES = [\"docker\"]\nfor name in REQUIRED_BINARIES:\n    assert shutil.which(\n        name\n    ), f\"{name} is not available in PATH.\"  # you can specify absolute path here\nLEGACY_DOCKER = False\nif sys.maxsize < 2**32:\n    print(\"Your system is 32bit or lower.\")\n    print(\"Assume using legacy docker.\")\n    LEGACY_DOCKER = True\n    if os.name == \"posix\":\n        # check if is sudo\n        print(\"*nix sys"
        },
        {
            "comment": "Code checks if the current user is root and prints a message if not. If not root, it elevates privileges using the \"elevate\" function. It also defines an auto-separated string class for adding strings separated by a specific delimiter.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py\":45-75",
            "content": "tem detected.\")\n        # you don't need to do root checking\n        # username = os.environ.get(\"USER\", os.environ.get(\"USERNAME\", \"unknown\"))\n        # username = getpass.getuser()\n        # # ref: https://www.geeksforgeeks.org/how-to-get-the-current-username-in-python/\n        # is_sudo = username == \"root\"\n        # if not is_sudo:\n        #     msg = f\"You ({username}) are not sudo. Docker may malfunction.\"\n        #     # raise Exception(msg)\n        #     print(msg)\n        #     print(\"Elevating now.\")\n        elevate.elevate(graphical=False)\nclass _AutoSeparatedString(str):\n    __slots__ = [\"sep\"]\n    # def __init__(self, *args, **kwargs):\n    #     self.sep = kwargs.pop('sep')\n    def __add__(self, other):\n        s_self, s_other = str(self), str(other)\n        val = s_self.__add__(self.sep + s_other)\n        return self.__class__(val)\n    def __radd__(self, other):\n        s_self, s_other = str(self), str(other)\n        val = s_other.__add__(self.sep + s_self)\n        return self.__class__(val)\ncla"
        },
        {
            "comment": "This code seems to define a class called AutoSpacedString that separates strings by space. It also defines functions for interacting with Docker, such as listing and killing containers. However, there are warnings about potential issues with the Docker CLI on MacOS and suggestions to use SSH-based interaction with containers instead.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py\":75-115",
            "content": "ss AutoSpacedString(_AutoSeparatedString):\n    sep = \" \"\n    # def __init__(self, *args, **kwargs):\n    #     kwargs['sep'] = ' '\n    #     super().__init__(*args, **kwargs)\n# a = AutoSpacedString('a')\n# # a = AutoSeparatedString('a')\n# print(a)\n# print(a+a)\n# print(a+a+a)\n# you had better adopt async/await syntax.\n# import time\nfrom log_common import *\ndef docker_cmd(*args):\n    return \" \".join([\"docker\", *args])\ndef docker_container_cmd(*args):\n    return docker_cmd(\"container\", *args)\nif LEGACY_DOCKER:\n    LIST_CONTAINER = docker_cmd(\"ps -a\")\n    KILL_CONTAINER = docker_cmd(\"rm -f\")\n    # KILL_CONTAINER = docker_cmd(\"kill\")\nelse:\n    LIST_CONTAINER = docker_container_cmd(\"ls\")\n    KILL_CONTAINER = docker_container_cmd(\"kill\")\n# this error has been recorded.\n# we cannot just leave it like this.\n# we need some watchdog thread.\n# DOCKER CLI ON MACOS IS NOT RESPONSIVE!\n# WHAT TO DO WITH THIS?\n# DO NOT FOOL ME INTO BUYING E5-2650V2 OR REGECC RAMS!\n# suggestion: use ssh-based interaction with containers.\n# suggestion: "
        },
        {
            "comment": "This code attempts to kill and prune all Docker containers on macOS. If it fails, it retries twice before relaunching the Docker service.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py\":115-141",
            "content": "restart docker service on macos.\n# TODO: make unittests for failsafe protocols and watchdogs\n# TODO: check docker binary if it is in PATH\n# TODO: count failures of microtasks like this method and create remedy routines which trying to repair and continue execution\nfrom rerun_docker_daemon import restart_and_verify\ndef killAndPruneAllContainers(trial_count=2):\n    fail_counter = 0\n    for i in range(trial_count):\n        print(f\"try to kill docker containers ({i+1} time(s))\")\n        try:\n            success = _killAndPruneAllContainers()\n            assert success, \"Failed to execute docker kill and prune\"\n            print(\"successfully killed all containers\")\n            return success\n        except:\n            fail_counter += 1\n    if fail_counter >= trial_count:  # in fact, it can only equal to the count.\n        print(\"relaunching docker\")\n        restart_and_verify()\n        return killAndPruneAllContainers(trial_count)\n@func_timeout.func_set_timeout(timeout=10)\ndef _killAndPruneAllContainers():  #"
        },
        {
            "comment": "This code is used to clean up stopped Docker containers. It checks for running containers and attempts to stop them using either `os.system` or `docker container kill -s SIGKILL`. If a container takes too long to shut down, it will print a warning message indicating that the container might not be running. Additionally, if the LEGACY_DOCKER flag is False (non-legacy Docker), it will forcefully remove all stopped containers using `docker container prune -f`. However, this code is deprecated and may have compatibility issues with Windows systems as it doesn't connect to the Docker socket properly.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py\":141-165",
            "content": " not working for legacy docker.\n    success = False\n    proc = easyprocess.EasyProcess(LIST_CONTAINER).call(timeout=4)\n    if proc.return_code == 0:\n        success = True  # usually this is the challange.\n    # proc = easyprocess.EasyProcess(\"docker container ls -a\").call()\n    if proc.stdout:\n        lines = proc.stdout.split(\"\\n\")[1:]\n        container_ids = [line.split(\" \")[0] for line in lines]\n        for cid in progressbar.progressbar(container_ids):\n            cmd = f\"{KILL_CONTAINER} {cid}\"\n            try:\n                func_timeout.func_timeout(3, os.system, args=(cmd,))\n            except func_timeout.FunctionTimedOut:\n                print(\n                    f'timeout while killing container \"{cid}\".\\nmaybe the container is not running.'\n                )\n            # os.system(f\"docker container kill -s SIGKILL {cid}\")\n        if not LEGACY_DOCKER:\n            os.system(\"docker container prune -f\")\n    return success\n# BUG: deprecated! may not connect to docker socket on windows.\n# @part"
        },
        {
            "comment": "The code defines a class `AlpineActor` that extends `NaiveActor`. It initializes the actor by calling `killAndPruneAllContainers()`, which stops and prunes all Docker containers, and then sets up an Alpine container using the command `\"docker run --rm -it alpine:3.7\"`. The class also contains TODOs for detecting if the container is down, retrieving the container ID, and checking if a real container session exists.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py\":165-189",
            "content": "ial(func_timeout.func_timeout, 10)\n# def killAndPruneAllContainers():\n#     # def stopAndPruneAllContainers():\n#     all_containers = client.containers.list(all=True)\n#     print(\"killing running containers...\")\n#     for container in progressbar.progressbar(all_containers):\n#         try:\n#             container.kill()\n#         except:\n#             log_and_print_unknown_exception()\n#             # container not running. can be pruned.\n#             # usually.\n#         # container.stop()\n#     print(\"pruning stopped containers...\")\n#     client.containers.prune()\nclass AlpineActor(NaiveActor):\n    def __init__(self):\n        killAndPruneAllContainers()\n        super().__init__(\"docker run --rm -it alpine:3.7\")\n        # TODO: detect if the container is down by heartbeat-like mechanism\n        # TODO: retrieve created container id\n        # TODO: detect if we have the real container instead of fake container (do we have a real container session? or just dummy session with no docker behind), using pexpect"
        },
        {
            "comment": "This code defines a class representing an actor in an interactive program. It includes methods to check the container state, loop over reading and writing content, and safely handle certain exceptions. The function run_actor_forever can be used to run the actor's loop forever.\n\nThe class has a destructor (__del__) that kills and prunes all containers when the object is deleted. It also has an _init_check method that checks the container's state, expecting a prompt, and ensuring that the user running inside the container is root. The loop method repeatedly reads content from the actor and writes new content.\n\nThe SAFE_EXCEPTION_TYPES variable lists specific types of exceptions that should be considered safe and not interrupt the program's execution. There are comments suggesting that OSError might not be the only type to include, and that for Windows systems, weexpect.wexpect_util.EOF should also be included in SAFE_EXCEPTION_TYPES.\n\nThe run_actor_forever function can be used to run the actor's loop forever, continuously interacting with the container. However, there is a comment suggesting that this function might not be used or needed anymore.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py\":189-225",
            "content": "'s default capability.\n    def __del__(self):\n        killAndPruneAllContainers()\n        super().__del__()\n    def _init_check(self):\n        print(\"checking container\")\n        steps = [\n            lambda: self.process.expect(\"/ # \"),\n            lambda: self.process.write(f\"whoami{os.linesep}\"),\n            lambda: self.process.expect(\"root\"),\n        ]\n        for step in progressbar.progressbar(steps):\n            step()\n    @NaiveActor.timeit\n    def loop(self):\n        _ = self.read()\n        write_content = AsciiVocab.generate()\n        write_content = write_content.encode()\n        self.write(write_content)\n        return True\nSAFE_EXCEPTION_TYPES = [OSError]  # are you sure? this can be many. not just io errors\n# SAFE_EXCEPTION_TYPES = []\nif os.name == \"nt\":\n    import wexpect\n    SAFE_EXCEPTION_TYPES.append(wexpect.wexpect_util.EOF)  # you can try to ignore this.\n# from typing import Generator\ndef run_actor_forever(actor_class):\n    # killAndPruneAllContainers()\n    if hasattr(actor_class, \"__next__\")"
        },
        {
            "comment": "This code defines a function `internal_loop` that runs an actor. It creates an instance of the given `actor_class`, sets timeouts for the inner functions, and executes it within a while loop. If interrupted or if an exception occurs during execution, it will return \"INTERRUPTED\" or print \"restarting actor\", respectively.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py\":225-263",
            "content": ":\n        # if isinstance(actor_class, Generator):\n        make_actor = lambda: next(actor_class)\n    else:\n        make_actor = lambda: actor_class()\n    # breakpoint()\n    # we just cannot use such long timeout limit.\n    # need watchdog alternative.\n    @func_timeout.func_set_timeout(timeout=131)\n    def internal_loop():\n        ret = None\n        # actor = actor_class()\n        actor = make_actor()\n        @func_timeout.func_set_timeout(timeout=100)\n        def run_actor():\n            try:\n                actor.run()\n            except KeyboardInterrupt:\n                print(\"exit on user demand\")\n                return \"INTERRUPTED\"\n            except Exception as e:\n                safe = check_if_is_safe_exception(e)\n        ret = run_actor()\n        del actor\n        if ret is None:\n            print()\n            print(\"restarting actor\")\n        gc.collect()\n        return ret\n    while True:\n        ret = None\n        try:\n            ret = internal_loop()\n            if ret == \"INTERRUPTED\":\n             "
        },
        {
            "comment": "The code is part of a larger function that handles exceptions during program execution. It checks if the exception thrown belongs to a predefined list of safe exception types, and if so, it prints the traceback and message before continuing. If the exception is not on the list, it calls log_and_print_unknown_exception().",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/basic_interactive_program_emulation_and_image_with_docker_support/alpine_actor.py\":263-288",
            "content": "   break\n        except Exception as e:\n            safe = check_if_is_safe_exception(e)\ndef check_if_is_safe_exception(e):\n    safe = False\n    # for exc_type in SAFE_EXCEPTION_TYPES:\n    #     if isinstance(e, exc_type):\n    if type(e) in SAFE_EXCEPTION_TYPES:\n        safe = True\n    if safe:\n        traceback.print_exc()\n        print(\"safe exception:\", e)\n    else:\n        log_and_print_unknown_exception()\n    return safe\nif __name__ == \"__main__\":\n    run_actor_forever(AlpineActor)\n#     import cProfile\n#     fpath = \"alpine_actor.profile\"\n#     # # print(\"running\")\n#     prof = cProfile.run(\"AlpineActor()\", filename=fpath)\n#     # print(\"hello world\")"
        }
    ]
}