{
    "summary": "The code handles audio, video, and HID recording with Redis signaling, manages folders, starts processes based on preferences, checks statuses, and ensures proper locking and error handling.",
    "details": [
        {
            "comment": "The code is setting up various configurations and variables for recording audio, video, and HID events. It uses Redis for thread signaling and keeps the last 30 recordings.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/ubuntu_qemu_utm_arm_record/main_recorder.py\":0-43",
            "content": "import time\nimport subprocess\nimport datetime\nimport os\nfrom utils import (\n    set_redis_on,\n    set_redis_off,\n    set_prefix,\n    get_prefix,\n    check_redis_on,\n    check_redis_off,\n    PYTHON_EXECUTABLE,\n    set_redis_off_on_exception,\n    filepaths,\n    MAX_RECORDING_COUNT,\n)\nset_prefix()\nset_redis_off_on_exception(main=True)\nMINIBREAK_SECONDS = 1\nRECORD_SECONDS = 10\nWAIT_TIMEOUT = 1\n# how to signal multiple threads at once? use redis.\nset_redis_off()\ntime.sleep(MINIBREAK_SECONDS)\nRECORDERS = {\"Audio\": False, \"Video\": True, \"HID\": True}\n# RECORDERS = {\"Audio\": False, \"Video\": False, \"HID\": True}\n# RECORDERS = {\"Audio\": True, \"Video\": False, \"HID\": False}\n# RECORDERS = {\"Audio\": True, \"Video\": True, \"HID\": True}\nRANDOM_ACTOR = True\n# keep last 30 recordings.\n# will remove anything more than that.\nrec_folders = [\n    \"{}{}\".format(filepaths.target_prefix, p)\n    for p in os.listdir(filepaths.target_prefix)\n    if os.path.isdir(\"{}{}\".format(filepaths.target_prefix, p))\n]\nrec_folders.sort(key=lambda p: -os.path.getmti"
        },
        {
            "comment": "Code is removing expired recording folders and starting main processes based on user's preferences.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/ubuntu_qemu_utm_arm_record/main_recorder.py\":43-70",
            "content": "me(p))\nexpired_rec_folders = rec_folders[MAX_RECORDING_COUNT:]\nprint(\"EXPIRED RECORDING FOLDER COUNT:\", len(expired_rec_folders))\nfor p in expired_rec_folders:\n    print(\"REMOVING EXPIRED RECORDING FOLDER:\", p)\n    os.system(\"rm -rf {}\".format(p))\nif all([signal is not True for _, signal in RECORDERS.items()]):\n    raise Exception(\"Should at least use one recorder.\")\nelse:\n    for key, value in RECORDERS.items():\n        if value:\n            print(\"Recording: %s\" % key)\nif check_redis_off():\n    set_redis_on()\n    time.sleep(MINIBREAK_SECONDS)\n    if check_redis_on():\n        print(\"EXECUTING MAIN PROCESSES\")\n        print(\"RECORD LENGTH: {} secs\".format(RECORD_SECONDS))\n        # execute subcommands. (subprocess)\n        if RECORDERS[\"HID\"]:\n            HIDRecorderProcess = subprocess.Popen(\n                [PYTHON_EXECUTABLE, \"mouse_keyboard_record.py\"]\n            )\n        if RECORDERS[\"Video\"]:\n            VideoRecorderProcess = subprocess.Popen(\n                [PYTHON_EXECUTABLE, \"video_record.py\"]\n    "
        },
        {
            "comment": "Checks if audio and random actor recorders should run, then starts them. Waits for RECORD_SECONDS before checking if any recorder abnormally exited. If so, aborts main recorder and sets redis lock as off. After a MINIBREAK_SECONDS delay, checks if the redis lock is still off and exits if it is.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/ubuntu_qemu_utm_arm_record/main_recorder.py\":70-98",
            "content": "        )\n        if RECORDERS[\"Audio\"]:\n            AudioRecorderProcess = subprocess.Popen(\n                [PYTHON_EXECUTABLE, \"audio_record.py\"]\n            )\n        if RANDOM_ACTOR:\n            RandomActorProcess = subprocess.Popen(\n                [PYTHON_EXECUTABLE, \"random_actor_redis.py\"]\n            )\n        # time.sleep(RECORD_SECONDS)\n        for _ in range(RECORD_SECONDS):\n            time.sleep(1)\n            if check_redis_off():\n                print(\"Abnormal recorder exit detected.\")\n                print(\"Abort main recorder.\")\n                break\n        print(\"EXITING.\")\n        print(\"SET LOCK AS OFF.\")\n        set_redis_off()\n        time.sleep(MINIBREAK_SECONDS)\n        if check_redis_off():\n            exit_codes = []\n            if RECORDERS[\"HID\"]:\n                hid_exit_code = HIDRecorderProcess.wait(timeout=WAIT_TIMEOUT)\n                exit_codes.append(hid_exit_code)\n            if RECORDERS[\"Video\"]:\n                video_exit_code = VideoRecorderProcess.wait(\n              "
        },
        {
            "comment": "This code checks for the exit codes of various processes (Audio, Video, HID, and RandomActor) using wait() function. It then appends these exit codes to a list called exit_codes. If any of the exit codes are not 0, it prints the exit codes and removes all temporary files.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/ubuntu_qemu_utm_arm_record/main_recorder.py\":98-120",
            "content": "      timeout=WAIT_TIMEOUT)\n                exit_codes.append(video_exit_code)\n            if RECORDERS[\"Audio\"]:\n                audio_exit_code = AudioRecorderProcess.wait(\n                    timeout=WAIT_TIMEOUT)\n                exit_codes.append(audio_exit_code)\n            if RANDOM_ACTOR:\n                random_actor_exit_code = RandomActorProcess.wait(\n                    timeout=WAIT_TIMEOUT*3)\n                exit_codes.append(random_actor_exit_code)\n            print()\n            print(\"EXIT CODES:\")\n            if RECORDERS[\"Audio\"]:\n                print(\"AUDIO - {}\".format(audio_exit_code))\n            if RECORDERS[\"Video\"]:\n                print(\"VIDEO - {}\".format(video_exit_code))\n            if RECORDERS[\"HID\"]:\n                print(\"HID - {}\".format(hid_exit_code))\n            if RANDOM_ACTOR:\n                print(\"RANDOM_ACTOR - {}\".format(random_actor_exit_code))\n            print()\n            if any([code != 0 for code in exit_codes]):\n                # you may remove all temp file"
        },
        {
            "comment": "This code is deleting specific recorded files (hid_record, audio_record, video_record, etc.) in the recorder folder.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/ubuntu_qemu_utm_arm_record/main_recorder.py\":120-143",
            "content": "s under recorder folder.\n                prefix = get_prefix()\n                hid_record = \"{}hid_record.jsonl\".format(prefix)\n                audio_record = \"{}audio_record.wav\".format(prefix)\n                video_record = \"{}video_record.mp4\".format(prefix)\n                video_record_script = \"{}video_record_script.sh\".format(prefix)\n                video_timestamps = \"{}video_timestamps.json\".format(prefix)\n                hid_timestamps = \"{}hid_timestamps.json\".format(prefix)\n                audio_timestamps = \"{}audio_timestamps.json\".format(prefix)\n                for fpath in [\n                    hid_record,\n                    audio_record,\n                    video_record,\n                    video_record_script,\n                    video_timestamps,\n                    hid_timestamps,\n                    audio_timestamps,\n                ]:\n                    try:\n                        os.remove(fpath)\n                    except:\n                        pass\n                raise Exceptio"
        },
        {
            "comment": "Code snippet checks if the computer recorder exited normally or not. If it exited abnormally, it displays a message indicating an abnormal exit code. If it exits normally, it creates a records folder with the current timestamp and moves recorded files to that folder for organization purposes.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/ubuntu_qemu_utm_arm_record/main_recorder.py\":143-164",
            "content": "n(\"COMPUTER RECORDER HAS ABNORMAL EXIT CODE.\")\n            else:\n                print(\"COMPUTER RECORDER EXIT NORMALLY\")\n                # required for ntfs.\n                current_timestamp = (\n                    datetime.datetime.now().isoformat().replace(\":\", \"_\")\n                )\n                records_folder = \"{}{}\".format(\n                    filepaths.target_prefix, current_timestamp)\n                # records_folder = \"{}{}\".format(filepaths.prefix, current_timestamp)\n                print(\"MOVING RECORDS TO: {}\".format(records_folder))\n                os.mkdir(records_folder)\n                for fpath in [\n                    filepaths.hid_record,\n                    filepaths.audio_record,\n                    filepaths.video_record,\n                    filepaths.video_record_script,\n                    filepaths.video_timestamps,\n                    filepaths.hid_timestamps,\n                    filepaths.audio_timestamps,\n                ]:\n                    os.system(\"mv {} {}\".format(fp"
        },
        {
            "comment": "Checks if the lock is set correctly and prints appropriate failure messages.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/ubuntu_qemu_utm_arm_record/main_recorder.py\":164-176",
            "content": "ath, records_folder))\n                # print(\"MAKING FINISHED INDICATOR\")\n                # os.system(\"touch {}\".format(os.path.join(records_folder, \"finished\")))\n                # or this is not needed. because it is always hard to savage things from a running instance.\n        else:\n            print(\"FAILED TO SET LOCK AS OFF.\")\n            print(\"FAILED AT FINAL CHECK.\")\n    else:\n        print(\"FAILED TO SET LOCK AS ON.\")\n        print(\"FAILED AT INIT CHECK 2\")\nelse:\n    print(\"FAILED TO SET LOCK AS OFF.\")\n    print(\"FAILED AT INIT CHECK 1\")"
        }
    ]
}