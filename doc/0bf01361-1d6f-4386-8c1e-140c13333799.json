{
    "summary": "The code sets the Pyright version, tracks errors, and creates a regex pattern. It imports modules for parsing, subprocess execution, and cache creation. The code then checks for undefined variables, finds type errors using regex, logs them, and asserts based on an error message.",
    "details": [
        {
            "comment": "- Set the minimum required Pyright version.\n- Define a list of errors to track.\n- Create a regular expression pattern for matching error messages.\n- Import necessary modules for parsing and subprocess execution.\n- Define functions for parsing versions and checking if a current version meets the minimum requirement.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/pyright_utils.py\":0-36",
            "content": "from log_utils import logger_print\nMIN_PYRIGHT_VERSION = \"1.1.317\"  # if lower than this version then raise exception.\npyright_errors = [\"reportImportCycles\", \"reportUndefinedVariable\"]\nerrorRegex = r\"^(.+?(?:{}).+)$\".format(\"|\".join(pyright_errors))\n# use `os.strerror` to translate os-specific error code obtained by `subprocess.run`\nimport parse\nimport re\ndef parse_version(version: str):\n    p = parse.parse(\"{x:d}.{y:d}.{z:d}\", version)\n    return [p[k] for k in \"xyz\"]\ndef check_version(current_version: str, minimum_version: str):\n    cp = parse_version(current_version)\n    mp = parse_version(minimum_version)\n    for cv, mv in zip(cp, mp):\n        if cv < mv:\n            return False\n    return True\nimport pyright\nfrom typing import Any, Union\nimport subprocess\n# monkey patch start\ndef run(\n    *args: str, **kwargs: Any\n) -> Union[\"subprocess.CompletedProcess[bytes]\", \"subprocess.CompletedProcess[str]\"]:\n    ROOT_CACHE_DIR = pyright.utils.get_cache_dir() / \"pyright-python\"\n    version = pyright.__pyright_vers"
        },
        {
            "comment": "The code checks the version of Pyright installed and creates a cache directory based on that version. It then locates the CLI entrypoint (index.js) and runs it using pyright's node module, returning the result. The monkey patch allows the pyright.cli.run function to be called with arguments and keyword arguments for running the Pyright CLI. A short test is included at the end to demonstrate the functionality of the code.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/pyright_utils.py\":36-66",
            "content": "ion__\n    if not check_version(version, MIN_PYRIGHT_VERSION):\n        raise Exception(\n            f\"Pyright version {version} does not meet minimum version {MIN_PYRIGHT_VERSION}\\nPlease upgrade using `pip install -U pyright`\"\n        )\n    # current_version = pyright.node.get_pkg_version(pkg_dir / 'package.json')\n    # cache_dir = ROOT_CACHE_DIR / current_version\n    cache_dir = ROOT_CACHE_DIR / version\n    cache_dir.mkdir(exist_ok=True, parents=True)\n    pkg_dir = cache_dir / \"node_modules\" / \"pyright\"\n    script = pkg_dir / \"index.js\"\n    if not script.exists():\n        raise RuntimeError(f\"Expected CLI entrypoint: {script} to exist\")\n    result = pyright.node.run(\"node\", str(script), *args, **kwargs)\n    return result\npyright.cli.run = run\n# monkey patch end\n# short test.\nif __name__ == \"__main__\":\n    args = [\"../test_undefined.py\"]\n    # args = ['ies_optim.py']\n    kwargs = dict(capture_output=True)\n    run_result = pyright.cli.run(*args, capture_output=True, encoding=\"utf-8\")\n    import rich\n    logger"
        },
        {
            "comment": "This code checks if there are any undefined variable errors in the Pyright output. If an error message containing \"does not exist\" is found in stderr, it raises an exception with the error message. It then finds all occurrences of the regular expression 'errorRegex' in stdout using re.findall, and logs these type errors. Finally, it asserts that the first type error ends with a specific error message.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/pyright_utils.py\":66-76",
            "content": "_print(run_result)\n    # errorRegex = r\".+?reportUndefinedVariable.+\"\n    # if \"does not exist\" in run_result.stderr:\n    if run_result.stderr:\n        raise Exception(f\"Pyright error:\\n{run_result.stderr}\")\n    typeErrors = re.findall(errorRegex, run_result.stdout, re.MULTILINE)\n    # breakpoint()\n    logger_print(typeErrors)\n    assert typeErrors[0].endswith(\n        'test_undefined.py:1:5 - error: \"b\" is not defined (reportUndefinedVariable)'\n    )"
        }
    ]
}