{
    "summary": "This code sets up a FastAPI server for event monitoring, handles HTTP events, logs validation errors and stores data in a JSON file upon reaching 5 keys, and runs an Uvicorn server on localhost at a specified port.",
    "details": [
        {
            "comment": "This code sets up a FastAPI server that listens for mouse and keyboard events. It uses the CORSMiddleware to allow requests from any origin, method, and header. The server also defines two Pydantic models, MouseEventData and KeyboardEventData, for handling event data.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/the_frozen_forest_intro/keylogger_server.py\":0-54",
            "content": "# you are expected to receive mouse/keyboard events\n#\nserverPort = 4471\nimport fastapi\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom typing import Callable, Any, Dict, Union, Literal\norigins = [\"*\"]\napp = fastapi.FastAPI()\napp.add_middleware(\n    CORSMiddleware, allow_origins=origins, allow_methods=origins, allow_headers=origins\n)\nfrom pydantic import BaseModel\nclass MouseEventData(BaseModel):\n    screenX: int\n    screenY: int\n    clientX: int\n    clientY: int\n    ctrlKey: bool\n    shiftKey: bool\n    altKey: bool\n    metaKey: bool\n    button: int\n    buttons: int\n    relatedTarget: Any\n    pageX: int\n    pageY: int\n    x: int\n    y: int\n    offsetX: int\n    offsetY: int\n    movementX: int\n    movementY: int\n    fromElement: Any\n    toElement: Dict[str, Any]\n    layerX: int\n    layerY: int\nclass KeyboardEventData(BaseModel):\n    key: str\n    code: str\n    location: int\n    ctrlKey: bool\n    shiftKey: bool\n    altKey: bool\n    metaKey: bool\n    repeat: bool\n    isComposing: bool\n    charCode: int\n    keyCode: int\n    DOM_KEY"
        },
        {
            "comment": "Code defines various event types and their payload structures for a browser monitoring system.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/the_frozen_forest_intro/keylogger_server.py\":54-98",
            "content": "_LOCATION_STANDARD: int\n    DOM_KEY_LOCATION_LEFT: int\n    DOM_KEY_LOCATION_RIGHT: int\n    DOM_KEY_LOCATION_NUMPAD: int\nclass EventPayload(BaseModel):\n    eventType: str\n    data: dict\nclass MouseEventPayload(BaseModel):\n    eventType: Literal[\"mousedown\", \"mouseup\", \"mousemove\"]\n    data: MouseEventData\nclass KeyboardEventPayload(BaseModel):\n    eventType: Literal[\"keydown\", \"keyup\"]\n    # eventType: Literal['keydown', 'keyup', 'keypress']\n    data: KeyboardEventData\n# tradeoff when using string types: you need to call update_forward_refs()\n# import uuid\nclass EventModel(BaseModel):\n    # eventType: str\n    timestamp: float\n    # timestamp: str\n    # data: str\n    client_id: str\nclass ScreenshotEvent(EventModel):\n    screenshot_data: str\n    # screenshot_data: str\nclass BrowserEvent(EventModel):\n    # client_id: uuid.UUID\n    # payload: Union[MouseEventPayload, KeyboardEventPayload]\n    payload: Union[MouseEventPayload, KeyboardEventPayload, EventPayload]\n    # payload: EventPayload\n# obviously not right.\n#    \"dat"
        },
        {
            "comment": "This code defines a class called `ValidationErrorLoggingRoute` which extends the `APIRoute` class from FastAPI. It overrides the default route handler to log any exceptions that occur during the execution of the original route handler. If the request body is in JSON format, it will be formatted and printed along with the exception. The code also sets a variable `terminal_column_size` to 80.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/the_frozen_forest_intro/keylogger_server.py\":98-129",
            "content": "a\": {\n#     \"isTrusted\": true\n# }\nfrom fastapi import Request, Response\nfrom fastapi.routing import APIRoute\n# from log_utils import terminal_column_size\nterminal_column_size = 80\nimport json\nclass ValidationErrorLoggingRoute(APIRoute):\n    def get_route_handler(self) -> Callable:\n        original_route_handler = super().get_route_handler()\n        async def custom_route_handler(request: Request) -> Response:\n            try:\n                return await original_route_handler(request)\n            # except RequestValidationError as exc:\n            except Exception as e:\n                is_json = False\n                try:\n                    body = await request.json()\n                    body = json.dumps(body, indent=4, ensure_ascii=False)\n                    is_json = True\n                except:\n                    body = await request.body()\n                print(\n                    \"request{}\".format(\"_json\" if is_json else \"\")\n                    .upper()\n                    .center(terminal_column_siz"
        },
        {
            "comment": "This code is for a FastAPI web application. It defines routes and handlers for submitting screenshot events and receiving browser input events. The app uses the ValidationErrorLoggingRoute class to log any validation errors that occur during request processing, and it returns an \"ok\" response for successful requests.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/the_frozen_forest_intro/keylogger_server.py\":129-164",
            "content": "e, \"_\"),\n                    body,\n                    sep=\"\\n\",\n                )\n                print(\n                    \"exception\".upper().center(terminal_column_size, \"_\"), e, sep=\"\\n\"\n                )\n                # detail = {\"errors\": exc.errors(), \"body\": body.decode()}\n                # raise HTTPException(status_code=422, detail=detail)\n                raise e\n        return custom_route_handler\napp.router.route_class = ValidationErrorLoggingRoute\n# sample_data_path = 'sample_event_data.json'\n# sample_data = {}\n# @app.get('/getIdentifier')\n# def get_identifier(client_id:str):\n#     return dict(client_id=client_id)\nSTATUS_OK_RESPONSE = {'status': 'ok'}\n@app.post(\"/submitScreenshot\")\ndef receiveScreenshotEvent(request_data: ScreenshotEvent):\n    return STATUS_OK_RESPONSE\n@app.post(\"/browserInputEvent\")\n# def receiveBrowserInputEvent(body:Dict[str, Any]):\n# def receiveBrowserInputEvent(\n#     eventType: str,\n#     timestamp: str,\n#     data: str,\n# ):\ndef receiveBrowserInputEvent(request_data: Brows"
        },
        {
            "comment": "This code is handling HTTP events, printing received event data, and storing a sample of the data in a JSON file when the number of keys reaches 5. It also returns an OK response. The code runs an Uvicorn server on localhost at a specified port.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/the_frozen_forest_intro/keylogger_server.py\":164-182",
            "content": "erEvent):\n    # print(\"received body:\", eventType, timestamp, data)\n    print(\"received body:\", request_data)\n    # eventType = request_data.payload.eventType\n    # data = request_data.payload.data\n    # sample_data[eventType] = data\n    # if len(sample_data.keys()) == 5:\n    #     with open(sample_data_path, 'w+') as f:\n    #         f.write(json.dumps(sample_data, ensure_ascii=False, indent=4))\n    #     print(\"sample data saved to\", sample_data_path)\n    #     exit(0)\n    return STATUS_OK_RESPONSE\nif __name__ == \"__main__\":\n    import uvicorn\n    print(\"server address: http://localhost:%d\" % serverPort)\n    uvicorn.run(app, host=\"0.0.0.0\", port=serverPort)"
        }
    ]
}