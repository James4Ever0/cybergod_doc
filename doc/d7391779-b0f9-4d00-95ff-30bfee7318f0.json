{
    "summary": "The code translates hardware keycodes into compatible ones for a computer system using JSON files, manages unsupported keys, and ensures standardized names while also updating translation tables with mappings and handling errors.",
    "details": [
        {
            "comment": "This code reads and translates hardware keycodes into compatible keycodes for a computer system. It loads translation tables from a JSON file and handles unsupported keys by either ignoring them or raising exceptions.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/common_keycodes.py\":0-40",
            "content": "import sys\nsys.path.append(\"../\")\n# TODO: add feedback to unsupported keys.\n# for now, just ignore these. don't do anything.\nfrom conscious_struct import HIDActionTypes\nimport json\ntrans_outpath = \"translation_keys.json\"\nfrom functools import lru_cache\n@lru_cache(maxsize=1)\ndef load_translation_table():\n    with open(trans_outpath, \"r\") as f:\n        content = f.read()\n        data = json.loads(content)\n        tk = \"translation_table\"\n        data[tk] = {k: bytes.fromhex(v) for k, v in data[tk].items()}\n        return data\nfrom beartype import beartype\n@beartype\ndef KeyLiteralToKCOMKeycode(keyLiteral: HIDActionTypes.keys):\n    translation_data = load_translation_table()\n    translation_table, missing = (\n        translation_data[\"translation_table\"],\n        translation_data[\"missing\"],\n    )\n    if keyLiteral in translation_table.keys():\n        return translation_table[keyLiteral]\n    elif keyLiteral in missing:\n        raise Exception(\"Calling missing keyLiteral:\", keyLiteral)\n    else:\n        raise Exception"
        },
        {
            "comment": "The code reads a JSON file called \"keys.json\", parses the key names and HID usage IDs, and creates a translation table for keycodes. It also performs some string manipulation to standardize key names (e.g., replacing \"Arrow\" with empty string, converting spaces to underscores).",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/common_keycodes.py\":40-76",
            "content": "(\"Unknown keyLiteral: \" + keyLiteral)\nfrom beartype.door import is_bearable\nif __name__ == \"__main__\":\n    # import json5\n    with open(\"keys.json\", \"r\") as f:\n        content = f.read()\n        kcom_keycodes = json.loads(content)\n    kcom_translation_table = {}\n    import re\n    def subs_brackets(e):\n        s, _ = re.subn(r\"\\(.*\\)\", \"\", e)\n        s = s.strip()\n        return s\n    for record in kcom_keycodes:\n        keyname = subs_brackets(record[\"Key Name\"])\n        keycode = bytes.fromhex(record[\"HID Usage ID\"])\n        possible_translations = []\n        keyname = keyname.replace(\"Arrow\", \"\").strip()\n        base_trans0 = keyname.replace(\" \", \"_\").lower()\n        base_trans = (\n            base_trans0.replace(\"gui\", \"cmd\")\n            .replace(\"control\", \"ctrl\")\n            .replace(\"escape\", \"esc\")\n            .replace(\"keyboard\", \"media\")\n            .replace(\"mute\", \"volume_mute\")\n            .replace(\"volume_dn\", \"volume_down\")\n            .replace(\"return\", \"enter\")\n        )\n        missing_key_litera"
        },
        {
            "comment": "This code checks if a given keyname starts with \"Key\" and doesn't have forbidden prefixes, then appends it to the list of possible translations. If not, it adds it to the missing_key_literals list.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/common_keycodes.py\":76-102",
            "content": "ls = [\n        ]\n        def check_is_common_keyname(keyname: str):\n            if keyname.startswith(\"Key\"):\n                keyname = keyname.strip(\"Key.\")\n                for forbidden_prefix in [\"ctrl\", \"cmd\", \"shift\", \"alt\", \"media\"]:\n                    if keyname.startswith(forbidden_prefix):\n                        return False\n            return True\n        def do_append(t):\n            _k = f\"Key.{t}\"\n            if check_is_common_keyname(_k):\n                possible_translations.append(t)\n                possible_translations.append(_k)\n            else:\n                for k in [t, _k]:\n                    if is_bearable(k, HIDActionTypes.keys):\n                        missing_key_literals.append(k)\n        do_append(base_trans)\n        for direction in [\"right_\", \"left_\"]:\n            if base_trans.startswith(direction):\n                base_trans = base_trans.replace(direction, \"\") + f\"_{direction[0]}\"\n                if direction == \"left_\":\n                    basekey = base_trans.split(\"_"
        },
        {
            "comment": "Code generates translation table for hardware capture power control keys based on common keycodes. It handles possible translations and checks if all key literals are covered by the translation table.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/common_keycodes.py\":102-130",
            "content": "\")[0]\n                    do_append(basekey)\n                do_append(base_trans)\n        if not base_trans0.startswith(\"F\"):\n            if len(keyname) == 3 and keyname[1] == \" \":\n                val = keyname[0]\n                trans = f\"\"\"'{val}'\"\"\" if val != \"'\" else f'''\"{val}\"'''\n                possible_translations.append(trans)\n        for translation in possible_translations:\n            kcom_translation_table[translation] = keycode\n    # coverage test.\n    error_msg = []\n    translation_table_cleaned = {}\n    import rich\n    # extra_missing_key_literals = []\n    for key_literal in HIDActionTypes.keys.__args__:\n        if key_literal not in kcom_translation_table:\n            # if key_literal not in missing_key_literals:\n            if check_is_common_keyname(key_literal):\n                error_msg.append(f\"{key_literal} not covered by translation table.\")\n            else:\n                missing_key_literals.append(key_literal)\n        else:\n            keycode = kcom_translation_table[key_lite"
        },
        {
            "comment": "Updating translation table with key mappings, handling errors, and outputting cleaned table in JSON format.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/hardware_capture_hid_power_control/common_keycodes.py\":130-145",
            "content": "ral]\n            translation_table_cleaned.update({key_literal: keycode})\n    if error_msg:\n        raise Exception(\"\\n\" + \"\\n\".join(error_msg))\n    print(\"cleaned translation table:\")\n    rich.print(translation_table_cleaned)\n    # use bytes.fromhex() to deserialize.\n    output_data = {\n        \"translation_table\": {k: v.hex() for k, v in translation_table_cleaned.items()},\n        \"missing\": missing_key_literals\n        # \"missing\": missing_key_literals + extra_missing_key_literals,\n    }\n    with open(trans_outpath, \"w+\") as f:\n        content = json.dumps(output_data, indent=4)\n        f.write(content)\n    print(\"write to:\", trans_outpath)"
        }
    ]
}