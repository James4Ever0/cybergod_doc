{
    "summary": "This code imports audio processing and error handling libraries, sets recording parameters, checks input devices, initializes a PyAudio stream for recording, reads audio data from the stream and writes to WAV file with timestamps, periodically commits, handles errors, prints warning if Redis is off, stops, closes resources upon completion or failure.",
    "details": [
        {
            "comment": "Imports libraries for audio processing and error handling, sets recording parameters, checks the audio input device list, and defines a function to get the index of an input device based on a pattern.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/ubuntu_qemu_utm_arm_record/audio_record.py\":0-42",
            "content": "import parse\nfrom pyaudio_get_device_info import get_audio_input_device_list\nimport platform\nfrom utils import (\n    filepaths,\n    check_redis_on,\n    check_redis_off,\n    TimestampedContext,\n    set_redis_off_on_exception,\n)\nimport pyaudio\nimport wave\nset_redis_off_on_exception()\nchunk = 1024  # Record in chunks of 1024 samples\nsample_format = pyaudio.paInt16  # 16 bits per sample\nchannels = 2\nfs = 44100  # Record at 44100 samples per second\n# seconds = 3\n# no seconds limit.\n# filename = \"output.wav\"\np = pyaudio.PyAudio()  # Create an interface to PortAudio\n# sudo modprobe snd-aloop\n# use loopback device 0?\nsystem = platform.system()\ninput_device_list = get_audio_input_device_list(p)\ndef get_input_device_index(input_device_list, pattern):\n    for index, device_name in input_device_list:\n        if parse.parse(pattern, device_name):\n            print(\"SELECT AUDIO INPUT DEVICE: %s\" % device_name)\n            return index\n    raise Exception(\"Cannot find audio input device index with pattern:\", pattern)\nif system =="
        },
        {
            "comment": "Code is checking the system type and selecting the appropriate input device for audio recording. It then initializes a PyAudio stream for recording and creates a Wave file object to store the recorded data. The code is written in such a way that it can handle different operating systems, with specific input devices and configurations for each platform (Windows, macOS, Linux).",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/ubuntu_qemu_utm_arm_record/audio_record.py\":42-77",
            "content": " \"Windows\":\n    raise Exception(\"Windows is currently not supported.\")\nelif system == \"Darwin\":\n    input_device_index = get_input_device_index(input_device_list, \"BlackHole {}\")\nelif system == \"Linux\":\n    input_device_index = get_input_device_index(\n        input_device_list, \"Loopback: PCM (hw:{},1)\"\n    )\n# input_device_index = 2 # shall you automate this?\n#\n# Loopback: PCM (hw:{},1)\nprint(\"Recording\")\nstream = p.open(\n    format=sample_format,\n    channels=channels,  # this is microphone. how to record internal audio?\n    rate=fs,\n    frames_per_buffer=chunk,  # this is the chunk.\n    # macos: 0 for blackhole. but you must set blackhole as output.\n    input_device_index=input_device_index,\n    input=True,\n)\n# frames = []  # Initialize array to store frames\nwf = wave.open(filepaths.audio_record, \"wb\")\nwf.setnchannels(channels)\nwf.setsampwidth(p.get_sample_size(sample_format))\nwf.setframerate(fs)\n# Store data in chunks for 3 seconds\n# for i in range(0, int(fs / chunk * seconds)):\nif check_redis_on():\n    with T"
        },
        {
            "comment": "Reading audio data from stream, writing to WAV file, and committing timestamps periodically. If Redis is off, print a warning message. Stop, close, and terminate resources upon completion or failure.",
            "location": "\"/media/root/Toshiba XG3/works/cybergod_doc/src/ubuntu_qemu_utm_arm_record/audio_record.py\":77-97",
            "content": "imestampedContext(filepaths.audio_timestamps) as t:\n        while check_redis_off() is False:\n            data = stream.read(chunk)\n            wf.writeframes(data)\n            # wf.writeframes(b\"\".join(frames))\n            # frames.append(data)\n            t.commit()\n        # Stop and close the stream\n        stream.stop_stream()\n        stream.close()\n        # Terminate the PortAudio interface\n        p.terminate()\n        print(\"Finished recording\")\n        # Save the recorded data as a WAV file\n        wf.close()\n        print(\"Saved audio recording to: {}\".format(filepaths.audio_record))\nelse:\n    print(\"AudioRecorder: Can't start. Redis signal is off.\".upper())"
        }
    ]
}